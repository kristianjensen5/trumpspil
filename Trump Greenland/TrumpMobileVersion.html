<!DOCTYPE html>
<html lang="da">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black">
<title>Trump Greenland Mobile</title>
<style>
  html,body{margin:0;padding:0;height:100%;background:#dff4ff;color:#111;font:14px/1.4 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;overflow:hidden;touch-action:none;user-select:none;}
  canvas{display:block;width:100%;height:100%;touch-action:none}
  
  /* Mobile-optimized UI positioning */
  .ui{
    position:fixed;left:8px;bottom:8px;z-index:10;
    background:rgba(0,0,0,.85);color:#fff;padding:8px 10px;border-radius:8px;font-size:11px;line-height:1.3;
    box-shadow:0 2px 8px rgba(0,0,0,.5);backdrop-filter:blur(4px);max-width:280px;
    transform:translateZ(0); /* Hardware acceleration */
  }
  .ui kbd{background:rgba(255,255,255,.2);padding:0 .3em;border-radius:4px;font-size:10px}
  
  /* Mobile inventory - smaller and repositioned */
  .inv{
    position:fixed;right:8px;top:15%;z-index:9;
    background:rgba(0,0,0,.85);color:#fff;border-radius:8px;padding:6px 4px;
    display:flex;flex-direction:column;gap:4px;align-items:center;
    max-height:60vh;overflow-y:auto;backdrop-filter:blur(4px);
    box-shadow:0 2px 8px rgba(0,0,0,.5);transform:translateZ(0);
  }
  .inv.hidden{display:none}
  .slot{
    width:50px;height:45px;border-radius:6px;background:rgba(255,255,255,.15);
    display:flex;flex-direction:column;align-items:center;justify-content:center;gap:1px;padding:3px;
    box-sizing:border-box;overflow:hidden;flex-shrink:0;
  }
  .slot span{font-size:7px;opacity:.9;text-align:center;line-height:1;max-width:100%;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;color:#fff}
  .slot b{font-size:8px;text-align:center;max-width:100%;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;color:#fff}
  .slot b, .slot span{display:block;text-shadow:0 1px 1px rgba(0,0,0,.7)}
  .slot.empty{background:rgba(255,255,255,.08);border:1px dashed rgba(255,255,255,.3)}
  .slot canvas{display:block;margin:0 auto;}
  
  /* Mobile HUD - repositioned */
  .hud{position:fixed;right:8px;top:8px;z-index:10;display:flex;gap:6px;align-items:flex-start;flex-wrap:wrap;flex-direction:column}
  .chip{background:rgba(0,0,0,.85);color:#fff;border-radius:8px;padding:4px 8px;font-size:10px;font-weight:500;box-shadow:0 2px 4px rgba(0,0,0,.4);transform:translateZ(0)}
  
  /* Mobile areas display */
  .areas{position:fixed;left:50%;top:8px;transform:translateX(-50%);z-index:10;display:flex;gap:4px;flex-wrap:wrap;justify-content:center;max-width:95vw}
  .pill{background:rgba(0,0,0,.85);color:#fff;border-radius:8px;padding:4px 8px;font-size:10px;font-weight:500;white-space:nowrap;box-shadow:0 2px 4px rgba(0,0,0,.4);transform:translateZ(0)}
  
  /* Mobile doom bar */
  .doombar{position:fixed;left:50%;top:40px;transform:translateX(-50%);z-index:10;
    background:rgba(0,0,0,.9);color:#fff;border-radius:8px;padding:6px 8px;
    box-shadow:0 2px 8px rgba(0,0,0,.5);backdrop-filter:blur(4px);
    display:flex;align-items:center;gap:6px;font-size:10px;font-weight:500;transform:translateZ(0)}
  .doombar-progress{width:120px;height:8px;border-radius:4px;background:#1e5631;overflow:hidden;box-shadow:inset 0 0 0 1px rgba(0,0,0,.7)}
  .doombar-fill{display:block;height:100%;background:#c62828;width:0%;transition:width 0.2s ease}
  
  /* Touch Controls */
  .mobile-controls{
    position:fixed;bottom:0;left:0;width:100%;height:120px;z-index:15;
    background:linear-gradient(to top, rgba(0,0,0,.7), transparent);
    display:flex;justify-content:space-between;align-items:flex-end;
    padding:10px 15px;box-sizing:border-box;transform:translateZ(0);
  }
  
  .dpad{
    display:grid;grid-template:"u u u" "l c r" ". d .";gap:5px;width:120px;height:90px;
  }
  .dpad-btn{
    background:rgba(255,255,255,.2);border:2px solid rgba(255,255,255,.4);
    border-radius:8px;display:flex;align-items:center;justify-content:center;
    font-size:16px;color:#fff;text-shadow:0 1px 2px rgba(0,0,0,.8);
    user-select:none;touch-action:manipulation;position:relative;
    backdrop-filter:blur(2px);transition:all 0.1s ease;
  }
  .dpad-btn:active{background:rgba(255,255,255,.4);transform:scale(0.95)}
  .dpad-btn.up{grid-area:u}
  .dpad-btn.down{grid-area:d}  
  .dpad-btn.left{grid-area:l}
  .dpad-btn.right{grid-area:r}
  
  .action-buttons{
    display:flex;flex-direction:column;gap:8px;align-items:center;
  }
  .action-btn{
    width:60px;height:50px;background:rgba(255,255,255,.2);
    border:2px solid rgba(255,255,255,.4);border-radius:12px;
    display:flex;flex-direction:column;align-items:center;justify-content:center;
    font-size:10px;color:#fff;text-shadow:0 1px 2px rgba(0,0,0,.8);
    user-select:none;touch-action:manipulation;backdrop-filter:blur(2px);
    transition:all 0.1s ease;line-height:1.2;text-align:center;
  }
  .action-btn:active{background:rgba(255,255,255,.4);transform:scale(0.95)}
  .action-btn .emoji{font-size:20px;margin-bottom:2px}
  
  /* Mobile intro screen */
  .intro-screen {
    position:fixed;top:0;left:0;width:100%;height:100%;z-index:100;
    background:linear-gradient(45deg,#1a0033,#330066,#000033);
    display:flex;flex-direction:column;justify-content:center;align-items:center;
    font-family:'Courier New',monospace;color:#00ffff;text-align:center;
    padding:20px;box-sizing:border-box;gap:15px;
  }
  .intro-title {
    font-size:clamp(20px,6vw,36px);font-weight:bold;
    text-shadow:0 0 10px #00ffff,0 0 20px #00ffff;
    letter-spacing:1px;margin:0;animation:glow 2s ease-in-out infinite alternate;
  }
  .intro-subtitle {
    font-size:clamp(12px,3vw,16px);color:#ffff00;
    text-shadow:0 0 5px #ffff00;opacity:.9;line-height:1.3;margin:0;
  }
  .intro-prompt {
    font-size:clamp(12px,2.5vw,14px);color:#ff00ff;
    text-shadow:0 0 5px #ff00ff;animation:blinkGlow 1.2s ease-in-out infinite;
    margin:0;font-weight:bold;letter-spacing:1px;
  }
  @keyframes glow {
    from{text-shadow:0 0 10px #00ffff,0 0 20px #00ffff}
    to{text-shadow:0 0 5px #00ffff,0 0 10px #00ffff}
  }
  @keyframes blinkGlow {
    0%,40%{opacity:1;transform:scale(1)}
    50%,90%{opacity:.4;transform:scale(.98)}
  }
  
  /* Responsive adjustments */
  @media (max-width: 480px) {
    .mobile-controls{height:100px;padding:8px 10px}
    .dpad{width:100px;height:80px;gap:3px}
    .action-btn{width:50px;height:42px;font-size:9px}
    .action-btn .emoji{font-size:16px}
    .chip{font-size:9px;padding:3px 6px}
    .pill{font-size:9px;padding:3px 6px}
  }
  
  @media (max-height: 600px) {
    .mobile-controls{height:90px}
    .inv{max-height:50vh;top:10%}
  }
  
  /* Prevent zoom on double tap */
  * {
    -webkit-touch-callout: none;
    -webkit-user-select: none;
    -khtml-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
  }
  
  /* iOS specific fixes */
  body {
    -webkit-overflow-scrolling: touch;
    position: fixed;
    width: 100%;
    height: 100%;
  }
</style>
</head>
<body>

<!-- Mobile Touch Controls -->
<div class="mobile-controls">
  <div class="dpad">
    <button class="dpad-btn up" data-key="up">‚Üë</button>
    <button class="dpad-btn left" data-key="left">‚Üê</button>
    <button class="dpad-btn right" data-key="right">‚Üí</button>
    <button class="dpad-btn down" data-key="down">‚Üì</button>
  </div>
  <div class="action-buttons">
    <button class="action-btn" data-key="space">
      <span class="emoji">ü¶ò</span>
      <span>Jump</span>
    </button>
    <button class="action-btn" data-key="e">
      <span class="emoji">ü§ù</span>
      <span>Interact</span>
    </button>
    <button class="action-btn" data-key="t">
      <span class="emoji">üì±</span>
      <span>Tweet</span>
    </button>
    <button class="action-btn" data-key="i">
      <span class="emoji">üéí</span>
      <span>Bag</span>
    </button>
  </div>
</div>

<!-- Game UI (same structure as desktop) -->
<div class="ui">
  Touch + Keyboard controls<br/>
  <kbd>D-Pad</kbd>/<kbd>‚Üê‚Üë‚Üì‚Üí</kbd> Move ‚Ä¢ <kbd>ü§ù</kbd>/<kbd>E</kbd> Interact<br/>
  <kbd>ü¶ò</kbd>/<kbd>Space</kbd> Jump ‚Ä¢ <kbd>üì±</kbd>/<kbd>T</kbd> Tweet ‚Ä¢ <kbd>üéí</kbd>/<kbd>I</kbd> Bag
</div>

<div class="inv hidden" id="inventory"></div>
<div class="hud" id="hud"></div>
<div class="areas" id="areas2"></div>
<div class="doombar" style="display:none" id="doombar">
  <span>üåç World Doom</span>
  <div class="doombar-progress"><div class="doombar-fill" id="doombar-fill"></div></div>
  <span id="doom-percent">0%</span>
</div>

<!-- 80s Intro Screen -->
<div class="intro-screen" id="intro">
  <canvas id="introCanvas" width="400" height="300" style="border: 2px solid #00ffff; border-radius: 8px; background: rgba(0,0,0,0.5);"></canvas>
  <h1 class="intro-title">TRUMP GREENLAND</h1>
  <p class="intro-subtitle">Try not to destroy the world, Donald.<br/>It's hard to be the best president ever.</p>
  <p class="intro-prompt">TAP TO START MISSION</p>
</div>

<canvas id="game"></canvas>

<script>
// Mobile-optimized game code starts here
(() => {
  'use strict';
  
  // Mobile detection and setup
  const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || 
                   ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
  
  console.log('Mobile device detected:', isMobile);
  
  // Prevent default touch behaviors
  document.addEventListener('touchmove', e => e.preventDefault(), { passive: false });
  document.addEventListener('touchstart', e => e.preventDefault(), { passive: false });
  
  // Canvas setup with mobile optimizations
  const cvs = document.getElementById('game');
  const ctx = cvs.getContext('2d', {
    alpha: false,
    desynchronized: true,
    powerPreference: 'high-performance'
  });
  
  let W = 800, H = 600; // Base dimensions
  
  function fit() {
    const dpr = Math.min(window.devicePixelRatio || 1, 2); // Limit DPR for performance on mobile
    const rect = cvs.getBoundingClientRect();
    W = rect.width;
    H = rect.height;
    cvs.width = W * dpr;
    cvs.height = H * dpr;
    ctx.scale(dpr, dpr);
    
    // Mobile-specific canvas optimizations
    if (isMobile) {
      ctx.imageSmoothingEnabled = false; // Pixel art optimization
      ctx.textBaseline = 'alphabetic';
    }
  }
  
  addEventListener('resize', fit);
  addEventListener('orientationchange', () => setTimeout(fit, 100));
  fit();
  
  // Configuration with mobile optimizations
  const CFG = {
    SCALE: Math.min(1, Math.min(W/800, H/600)), // Dynamic scaling for mobile
    NON_VIOLENT: false,
    SHOW_FPS: false,
    DEBUG: false,
    MOBILE: isMobile
  };
  
  // Mobile touch control system
  const touchControls = {
    activeKeys: new Set(),
    touchStartTime: 0,
    lastTouchTarget: null
  };
  
  // Add keyboard support for easier testing
  addEventListener('keydown', (e) => {
    const key = e.key.toLowerCase();
    let handled = false;
    
    // Handle intro screen
    if (scene === 'intro') {
      if (key === 'enter' || e.code === 'Enter' || (key.length === 1 && key !== ' ' && key !== 'e')) {
        document.getElementById('intro').style.display = 'none';
        scene = 'greenland';
        resetGreenland();
        ensureAudioInit();
        requestAnimationFrame(gameLoop);
        handled = true;
      }
      if (handled) e.preventDefault();
      return;
    }
    
    // Game controls
    if (choiceOverlay) {
      console.log('Choice overlay active, key pressed:', key);
      if (key === '1' || key === '2' || key === '3') {
        console.log('Valid choice key, calling callback');
        if (choiceOverlay.onKey) {
          console.log('Executing choice callback with key:', key);
          choiceOverlay.onKey(key);
        } else {
          console.log('No callback function found!');
        }
        handled = true;
      }
      else if (key === 'escape' || key === 'esc') {
        closeChoice();
        handled = true;
      }
    } else {
      // Movement keys
      if (['arrowup', 'arrowdown', 'arrowleft', 'arrowright'].includes(key)) {
        keys.add(key);
        handled = true;
      }
      // Action keys
      else if (key === ' ') { doJump(); handled = true; }
      else if (key === 'e') { interact(); handled = true; }
      else if (key === 't') { doTweet(); handled = true; }
      else if (key === 'i') { toggleInventory(); handled = true; }
      // Reset
      else if (key === 'r' && e.shiftKey) { 
        location.reload(); 
        handled = true; 
      }
    }
    
    if (handled) e.preventDefault();
  });
  
  addEventListener('keyup', (e) => {
    const key = e.key.toLowerCase();
    keys.delete(key);
  });
  
  // Touch event handlers for mobile controls
  function setupTouchControls() {
    const controlBtns = document.querySelectorAll('[data-key]');
    
    controlBtns.forEach(btn => {
      // Touch start
      btn.addEventListener('touchstart', (e) => {
        e.preventDefault();
        e.stopPropagation();
        
        const key = btn.dataset.key;
        touchControls.activeKeys.add(key);
        touchControls.touchStartTime = performance.now();
        touchControls.lastTouchTarget = btn;
        
        // Ensure audio is initialized on any touch
        if (!audioInitialized) {
          ensureAudioInit();
        }
        
        // Immediate key press for responsive feel
        simulateKeyEvent(key, true);
        
        // Visual feedback
        btn.style.background = 'rgba(255,255,255,.5)';
        btn.style.transform = 'scale(0.95)';
      }, { passive: false });
      
      // Touch end
      btn.addEventListener('touchend', (e) => {
        e.preventDefault();
        e.stopPropagation();
        
        const key = btn.dataset.key;
        touchControls.activeKeys.delete(key);
        
        simulateKeyEvent(key, false);
        
        // Reset visual state
        btn.style.background = '';
        btn.style.transform = '';
      }, { passive: false });
      
      // Touch cancel (when finger moves off button)
      btn.addEventListener('touchcancel', (e) => {
        const key = btn.dataset.key;
        touchControls.activeKeys.delete(key);
        simulateKeyEvent(key, false);
        
        btn.style.background = '';
        btn.style.transform = '';
      }, { passive: false });
    });
    
    // Canvas touch handling for tap-to-interact and gestures
    cvs.addEventListener('touchstart', (e) => {
      if (e.touches.length === 1) {
        const touch = e.touches[0];
        const rect = cvs.getBoundingClientRect();
        mouse.x = touch.clientX - rect.left;
        mouse.y = touch.clientY - rect.top;
        mouse.active = true;
        
        // Double tap detection for interaction
        const now = performance.now();
        if (now - touchControls.lastTapTime < 300) {
          simulateKeyEvent('e', true);
          setTimeout(() => simulateKeyEvent('e', false), 100);
        }
        touchControls.lastTapTime = now;
      }
    }, { passive: false });
    
    cvs.addEventListener('touchend', (e) => {
      mouse.active = false;
    }, { passive: false });
    
    cvs.addEventListener('touchmove', (e) => {
      if (e.touches.length === 1) {
        const touch = e.touches[0];
        const rect = cvs.getBoundingClientRect();
        mouse.x = touch.clientX - rect.left;
        mouse.y = touch.clientY - rect.top;
      }
    }, { passive: false });
  }
  
  touchControls.lastTapTime = 0;
  
  // Simulate keyboard events from touch
  function simulateKeyEvent(key, isDown) {
    const mappedKey = {
      'up': 'arrowup',
      'down': 'arrowdown', 
      'left': 'arrowleft',
      'right': 'arrowright',
      'space': ' ',
      'e': 'e',
      't': 't',
      'i': 'i'
    }[key] || key;
    
    if (isDown) {
      keys.add(mappedKey);
    } else {
      keys.delete(mappedKey);
    }
  }
  
  // Initialize mobile controls
  if (isMobile) {
    setupTouchControls();
    
    // Hide desktop UI instructions, show mobile
    const desktopUI = document.querySelector('.ui');
    if (desktopUI) {
      desktopUI.innerHTML = `
        Mobile controls active<br/>
        <kbd>D-Pad</kbd> Move ‚Ä¢ <kbd>ü§ù</kbd> Interact ‚Ä¢ <kbd>üì±</kbd> Tweet<br/>
        <kbd>ü¶ò</kbd> Jump ‚Ä¢ <kbd>üéí</kbd> Inventory
      `;
    }
  }
  
  // Performance optimizations for mobile
  let lastFrameTime = 0;
  const targetFPS = isMobile ? 30 : 60; // Lower FPS target on mobile for battery life
  const frameInterval = 1000 / targetFPS;
  
  // ========== COMPLETE TRUMP GREENLAND GAME LOGIC ==========
  
  // Input and choice system
  let choiceOverlay = null; // {text, onKey(k)}
  let tweetCount = 0;
  const keys = new Set();
  const mouse = { x: 0, y: 0, active: false };
  
  // Game state variables
  let scene = 'intro'; // 'intro' | 'greenland' | 'oval' | 'kremlin'
  let introStartTime = 0;
  const world = { floor: 120 };
  let borderDraw = null;
  
  // Helicopter intro system
  let introPlayed = false;
  let introRunning = false;
  const entryHeli = { 
    active: false, 
    x: 0, 
    y: 0, 
    start: 0, 
    dur: 1600, 
    targetX: 0, 
    startY: 0, 
    targetY: 0, 
    vertical: true, 
    line: '' 
  };
  
  // Walk animation system
  let walkTween = null; // {start, dur, fromX, toX, onComplete}
  
  // Infection state
  let infected = false;
  let infectionStartTime = 0;
  let contaminationRadius = 0;
  
  // Game State
  const GS = {
    timeLeftMs: 6*60*1000,
    doom: 0,
    cleared: { greenland:0, oval:0, kremlin:0 },
    needPerArea: 5,
    over: false,
    overText: '',
    achievements: {
      perfectDiplomat: false,
      speedRunner: false,
      collector: false,
      peacemaker: false,
      twitterAddict: false,
      bearWhisperer: false
    }
  };
  
  // Relationship System
  const RELATIONSHIPS = {
    mette: { respect: 50, trust: 50, fear: 20, lastInteraction: 'neutral' },
    putin: { respect: 30, trust: 20, fear: 10, lastInteraction: 'neutral' }
  };
  
  function adjustRelationship(character, changes, reason) {
    const rel = RELATIONSHIPS[character];
    if (!rel) return;
    
    Object.keys(changes).forEach(stat => {
      if (rel.hasOwnProperty(stat)) {
        rel[stat] = Math.max(0, Math.min(100, rel[stat] + changes[stat]));
      }
    });
    
    rel.lastInteraction = reason;
    rel.lastChange = changes;
    rel.lastChangeTime = nowMs();
    
    ensureAudioInit();
    const totalChange = Object.values(changes).reduce((sum, val) => sum + val, 0);
    if (totalChange > 5) SFX.success();
    else if (totalChange < -5) SFX.error();
    else SFX.click();
  }
  
  function getRelationshipEmoji(character) {
    const rel = RELATIONSHIPS[character];
    if (!rel) return 'üòê';
    
    const avg = (rel.respect + rel.trust - rel.fear) / 3;
    if (avg >= 70) return 'üòç';
    if (avg >= 50) return 'üòä';
    if (avg >= 30) return 'üòê';
    if (avg >= 10) return 'üò†';
    return 'ü§¨';
  }
  
  // Audio System
  const AUDIO = { enabled: true, masterVolume: 0.5 };
  let audioContext = null;
  let audioInitialized = false;
  
  function initAudio() {
    // Don't create AudioContext until user interaction
    if (!audioContext) {
      console.log('Audio system ready for initialization');
    }
  }
  
  function createAudioContext() {
    if (!audioContext) {
      try {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        console.log('AudioContext created:', audioContext.state);
        return true;
      } catch (e) {
        console.warn('AudioContext creation failed:', e);
        AUDIO.enabled = false;
        return false;
      }
    }
    return true;
  }
  
  function playSound(frequency, duration, type = 'sine', volume = 0.3) {
    if (!AUDIO.enabled) return;
    
    // Create audio context on first sound play
    if (!createAudioContext()) return;
    
    // Resume context if suspended (required for mobile)
    if (audioContext.state === 'suspended') {
      audioContext.resume().then(() => {
        playSound(frequency, duration, type, volume);
      }).catch(e => {
        console.warn('Audio resume failed:', e);
      });
      return;
    }
    
    try {
      const oscillator = audioContext.createOscillator();
      const gainNode = audioContext.createGain();
      
      oscillator.connect(gainNode);
      gainNode.connect(audioContext.destination);
      
      oscillator.frequency.value = frequency;
      oscillator.type = type;
      
      gainNode.gain.value = volume * AUDIO.masterVolume;
      gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
      
      oscillator.start();
      oscillator.stop(audioContext.currentTime + duration);
    } catch (e) {
      console.warn('Sound failed:', e);
    }
  }
  
  function playChord(frequencies, duration, volume = 0.2) {
    frequencies.forEach((freq, i) => {
      setTimeout(() => playSound(freq, duration, 'sine', volume), i * 50);
    });
  }
  
  const SFX = {
    click: () => playSound(800, 0.1, 'square', 0.2),
    buttonPress: () => playSound(600, 0.15, 'square', 0.3),
    success: () => playChord([523, 659, 784], 0.5, 0.25),
    error: () => playSound(200, 0.3, 'sawtooth', 0.3),
    helicopter: () => {
      for(let i = 0; i < 8; i++) {
        setTimeout(() => playSound(100 + Math.random()*40, 0.08, 'sawtooth', 0.12), i * 40);
      }
    },
    explosion: () => {
      playSound(60, 0.4, 'sawtooth', 0.3);
      setTimeout(() => playSound(40, 0.6, 'square', 0.25), 80);
    },
    whoosh: () => {
      for(let i = 0; i < 4; i++) {
        setTimeout(() => playSound(400 - i*60, 0.08, 'sine', 0.15), i * 25);
      }
    },
    achievement: () => playChord([523, 659, 784, 1047], 0.8, 0.3),
    tweet: () => {
      playSound(1000, 0.1, 'sine', 0.15);
      setTimeout(() => playSound(1200, 0.1, 'sine', 0.12), 120);
    },
    heartbeat: () => {
      playSound(80, 0.1, 'sine', 0.4);
      setTimeout(() => playSound(80, 0.1, 'sine', 0.4), 150);
    }
  };
  
  function ensureAudioInit() {
    if (!audioInitialized) {
      if (!audioContext) {
        createAudioContext();
      }
      
      if (audioContext) {
        if (audioContext.state === 'suspended') {
          audioContext.resume().then(() => {
            audioInitialized = true;
            console.log('Audio initialized successfully');
          }).catch(e => {
            console.warn('Audio initialization failed:', e);
          });
        } else if (audioContext.state === 'running') {
          audioInitialized = true;
          console.log('Audio already running');
        }
      }
    }
  }
  
  // Player object
  const player = {
    x: 160,
    y: 480,
    w: 24,
    h: 44,
    vy: 0,
    grounded: true,
    speakingUntil: 0,
    say: '',
    speedMul: 1,
    tanLevel: 0,
    capOn: false
  };
  
  // Inventory system
  const inventory = [];
  const maxInventorySlots = 12;
  
  function addToInventory(id, name) {
    if (inventory.length >= maxInventorySlots) return false;
    inventory.push({ id, name });
    renderInv();
    return true;
  }
  
  function renderInv() {
    const invEl = document.getElementById('inventory');
    if (!invEl) return;
    
    invEl.innerHTML = '';
    for (let i = 0; i < maxInventorySlots; i++) {
      const item = inventory[i];
      const slot = document.createElement('div');
      slot.className = item ? 'slot' : 'slot empty';
      
      if (item) {
        const keyEl = document.createElement('b');
        keyEl.textContent = (i < 3) ? (i + 1) : '';
        slot.appendChild(keyEl);
        
        const nameEl = document.createElement('span');
        nameEl.textContent = item.name;
        slot.appendChild(nameEl);
      }
      
      invEl.appendChild(slot);
    }
  }
  
  function toggleInventory() {
    const invEl = document.getElementById('inventory');
    if (invEl) {
      invEl.classList.toggle('hidden');
    }
  }
  
  // HUD system
  function renderHUD() {
    const hudEl = document.getElementById('hud');
    if (!hudEl) return;
    
    hudEl.innerHTML = '';
    
    function addChip(text) {
      const chip = document.createElement('div');
      chip.className = 'chip';
      chip.textContent = text;
      hudEl.appendChild(chip);
    }
    
    addChip('‚è∞ ' + fmtTime(GS.timeLeftMs));
    if (player.capOn) addChip('üß¢');
  }
  
  function fmtTime(ms) {
    const s = Math.max(0, Math.ceil(ms/1000));
    const m = (s/60|0).toString().padStart(2,'0');
    const ss = (s%60).toString().padStart(2,'0');
    return m+':'+ss;
  }
  
  function renderAreas2() {
    const areasEl2 = document.getElementById('areas2');
    if (!areasEl2) return;
    
    areasEl2.innerHTML = '';
    [['greenland','üá¨üá± Gr√∏nland'],['oval','üèõÔ∏è Hvide Hus'],['kremlin','üá∑üá∫ Kremlin']].forEach(([k,label]) => {
      const d = document.createElement('span');
      d.className = 'pill';
      const progress = GS.cleared[k];
      const needed = GS.needPerArea;
      let bgColor = 'rgba(200,0,0,.8)';
      if (progress >= needed) bgColor = 'rgba(0,150,0,.8)';
      else if (progress > 0) bgColor = 'rgba(200,150,0,.8)';
      d.style.background = bgColor;
      d.textContent = `${label}: ${progress}/${needed}`;
      areasEl2.appendChild(d);
    });
  }
  
  // Doom bar
  function renderDoombar() {
    const doombarEl = document.getElementById('doombar');
    const fillEl = document.getElementById('doombar-fill');
    const percentEl = document.getElementById('doom-percent');
    
    if (GS.doom > 0) {
      doombarEl.style.display = 'flex';
      fillEl.style.width = GS.doom + '%';
      percentEl.textContent = Math.round(GS.doom) + '%';
    } else {
      doombarEl.style.display = 'none';
    }
  }
  
  // Scene objects
  const GL = {
    state: { flagPlanted: false, bearGone: false, hasTweeted: false },
    mine: { x: 520, y: 0, w: 36, h: 24, type: 'mine' },
    bear: { x: 760, y: 0, w: 70, h: 40, type: 'bear', alive: true, hp: 3, speakingUntil: 0, say: '' },
    mette: { x: 980, y: 0, w: 26, h: 44, type: 'mette', speakingUntil: 0, say: '' },
    rig: { x: 380, y: 0, w: 30, h: 40, type: 'rig' },
    heli: { x: 160, y: 0, w: 120, h: 42, type: 'heli' },
    items: []
  };
  
  // Game loop with mobile optimizations
  let deltaTime = 16;
  let lastTime = 0;
  
  function gameLoop(currentTime) {
    if (currentTime - lastTime >= frameInterval) {
      deltaTime = Math.min(currentTime - lastTime, 32); // Cap delta time
      
      // Update game systems
      if (!GS.over && !choiceOverlay) {
        updateHelicopterIntro(); // Update intro first
        updatePlayer();
        updateCamera();
        updateGameTimer();
      }
      
      // Render
      render();
      
      lastTime = currentTime;
    }
    
    requestAnimationFrame(gameLoop);
  }
  
  function updatePlayer() {
    // Handle walk animation (only during intro sequence)
    if (walkTween && !introPlayed) {
      const elapsed = nowMs() - walkTween.start;
      const k = Math.min(1, elapsed / walkTween.dur);
      player.x = walkTween.fromX + (walkTween.toX - walkTween.fromX) * k;
      
      if (k >= 1) {
        if (walkTween.onComplete) walkTween.onComplete();
        walkTween = null;
      }
      return; // Don't process manual movement during intro walk animation
    }
    
    // Movement with mobile considerations
    let dx = 0;
    if (keys.has('arrowleft')) dx -= 1;
    if (keys.has('arrowright')) dx += 1;
    
    const speed = 200 * CFG.SCALE * player.speedMul;
    player.x += dx * speed * (deltaTime / 1000);
    
    // Expand movement bounds - allow movement across entire world
    const worldWidth = 1200 * CFG.SCALE;
    player.x = Math.max(20, Math.min(worldWidth - 40, player.x));
    
    // Gravity and ground collision
    if (!player.grounded) {
      player.vy += 800 * CFG.SCALE * (deltaTime / 1000);
      player.y += player.vy * (deltaTime / 1000);
      
      const groundY = H - world.floor;
      if (player.y >= groundY) {
        player.y = groundY;
        player.vy = 0;
        player.grounded = true;
      }
    }
  }
  
  function updateHelicopterIntro() {
    if (entryHeli.active) {
      const elapsed = nowMs() - entryHeli.start;
      const k = Math.min(1, elapsed / entryHeli.dur);
      
      if (entryHeli.vertical) {
        entryHeli.y = entryHeli.startY + (entryHeli.targetY - entryHeli.startY) * k;
      }
      
      if (k >= 1) {
        entryHeli.active = false;
        
        // Start player walk animation after landing
        startWalkTo(player.x + 40 * CFG.SCALE, 500, () => {
          if (entryHeli.line) {
            say(player, entryHeli.line, 1600);
          }
          // Mark intro as complete after walk and speech
          setTimeout(() => {
            introPlayed = true;
          }, 1600);
        });
      }
    }
  }
  
  function updateGameTimer() {
    GS.timeLeftMs -= deltaTime;
    if (GS.timeLeftMs <= 0) {
      checkWin();
    }
  }
  
  function render() {
    // Clear screen first
    ctx.fillStyle = '#dff4ff';
    ctx.fillRect(0, 0, W, H);
    
    ctx.save();
    // Apply camera transform
    ctx.translate(-camera.x, -camera.y);
    
    // Draw world-space objects
    if (scene === 'greenland') {
      drawGreenlandBackdrop();
    }
    
    // Draw player (detailed Trump figure)
    drawTrump(player.x, player.y);
    
    // Draw player speech bubble
    if (player.speakingUntil > nowMs()) {
      drawSpeechBubble(player.say, player.x + player.w * CFG.SCALE / 2, player.y - 10 * CFG.SCALE);
    }
    
    // Draw scene objects based on current scene
    if (scene === 'greenland') {
      renderGreenlandScene();
    }
    
    // Draw entry helicopter animation (in world space)
    if (entryHeli.active) {
      drawHelicopter(entryHeli.x, entryHeli.y);
    }
    
    ctx.restore();
    
    // UI updates (drawn in screen space)
    renderHUD();
    renderAreas2();
    renderDoombar();
    
    // Game over overlay
    if (GS.over) {
      renderGameOver();
    }
    
    // Choice overlay
    if (choiceOverlay) {
      renderChoiceOverlay();
    }
  }
  
  function renderGreenlandScene() {
    // Draw helicopter first (on the left) - but only if not in intro animation
    if (!entryHeli.active) {
      drawHelicopter(GL.heli.x, GL.heli.y);
    }
    
    // Draw mine with detailed graphics
    drawMine(GL.mine.x, GL.mine.y);
    
    // Draw oil rig with detailed graphics
    drawRig(GL.rig.x, GL.rig.y);
    
    // Draw bear with detailed graphics (if alive)
    if (GL.bear.alive) {
      drawBear(GL.bear.x, GL.bear.y, GL.bear.alive);
      drawBearHP(GL.bear);
    }
    
    // Draw Mette with detailed graphics
    drawMette(GL.mette.x, GL.mette.y);
    
    // Draw Mette's speech bubble
    if (GL.mette.speakingUntil > nowMs()) {
      drawSpeechBubble(GL.mette.say, GL.mette.x, GL.mette.y - 10 * CFG.SCALE);
    }
  }
  
  function drawBearHP(bear) {
    if (!bear.alive) return;
    const hp = Math.max(0, bear.hp || 3);
    const max = 3;
    const y = bear.y - 40 * CFG.SCALE;
    const x = bear.x - (max * 10 * CFG.SCALE) / 2;
    
    for (let i = 0; i < max; i++) {
      ctx.fillStyle = i < hp ? '#e33' : 'rgba(255,255,255,.35)';
      ctx.fillRect(x + i * 10 * CFG.SCALE, y, 8 * CFG.SCALE, 4 * CFG.SCALE);
    }
  }
  
  function drawHelicopter(x, y) {
    ctx.save();
    ctx.translate(x, y);
    
    // Helicopter body
    ctx.fillStyle = '#2c3e50';
    ctx.fillRect(-60 * CFG.SCALE, -15 * CFG.SCALE, 150 * CFG.SCALE, 42 * CFG.SCALE);
    
    // Cockpit
    ctx.fillStyle = '#86d0ff';
    ctx.fillRect(69 * CFG.SCALE, -9 * CFG.SCALE, 15 * CFG.SCALE, 24 * CFG.SCALE);
    
    // Main rotor shaft
    ctx.fillStyle = '#333';
    ctx.fillRect(9 * CFG.SCALE, -27 * CFG.SCALE, 6 * CFG.SCALE, 12 * CFG.SCALE);
    
    // Main rotor blades (with rotation effect)
    ctx.fillStyle = '#333';
    const rotorTime = nowMs() * 0.01;
    ctx.save();
    ctx.translate(12 * CFG.SCALE, -21 * CFG.SCALE);
    ctx.rotate(rotorTime);
    ctx.fillRect(-105 * CFG.SCALE, -3 * CFG.SCALE, 210 * CFG.SCALE, 6 * CFG.SCALE);
    ctx.restore();
    
    // Landing skids
    ctx.fillStyle = '#333';
    ctx.fillRect(-45 * CFG.SCALE, 27 * CFG.SCALE, 90 * CFG.SCALE, 6 * CFG.SCALE);
    ctx.fillRect(30 * CFG.SCALE, 27 * CFG.SCALE, 60 * CFG.SCALE, 6 * CFG.SCALE);
    
    ctx.restore();
  }
  
  // Greenland backdrop with proper snow/ice visuals
  function drawGreenlandBackdrop() {
    // Sky gradient
    const skyGrad = ctx.createLinearGradient(0, 0, 0, H);
    skyGrad.addColorStop(0, '#dff4ff');
    skyGrad.addColorStop(1, '#a7dfff');
    ctx.fillStyle = skyGrad;
    ctx.fillRect(camera.x - W, 0, W * 3, H);
    
    // Clouds (simple white ellipses)
    ctx.globalAlpha = 0.3;
    ctx.fillStyle = '#ffffff';
    for (let i = 0; i < 4; i++) {
      const cloudX = (camera.x * 0.3) + i * 200 * CFG.SCALE;
      const cloudY = 60 * CFG.SCALE + Math.sin(i) * 30 * CFG.SCALE;
      ctx.beginPath();
      ctx.ellipse(cloudX, cloudY, 80 * CFG.SCALE, 20 * CFG.SCALE, 0, 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;
    
    // Icebergs/mountains in background
    ctx.fillStyle = '#ebf8ff';
    drawBerg(120 * CFG.SCALE, H - 220 * CFG.SCALE, 220 * CFG.SCALE, 160 * CFG.SCALE);
    drawBerg(420 * CFG.SCALE, H - 240 * CFG.SCALE, 260 * CFG.SCALE, 180 * CFG.SCALE);
    drawBerg(820 * CFG.SCALE, H - 230 * CFG.SCALE, 220 * CFG.SCALE, 170 * CFG.SCALE);
    
    // Snow/ice ground
    const ground = H - world.floor;
    ctx.fillStyle = '#e7fbff';
    ctx.fillRect(camera.x - W, ground, W * 3, world.floor);
    
    // Ice/snow texture lines
    ctx.fillStyle = '#cfeef9';
    for (let i = 0; i < 6; i++) {
      const y = ground + 20 + i * 18 * CFG.SCALE;
      ctx.fillRect(camera.x - W, y, W * 3, 4);
    }
  }
  
  function drawBerg(cx, cy, w, h) {
    ctx.beginPath();
    ctx.moveTo(cx - w/2, cy + h/2);
    ctx.lineTo(cx, cy - h/2);
    ctx.lineTo(cx + w/2, cy + h/2);
    ctx.closePath();
    ctx.fill();
  }
  
  // Detailed character and object drawing functions
  function drawTrump(x, y) {
    const offset = getInteractionOffset({type:'player', x, y});
    ctx.save();
    ctx.translate(x + offset.x, y + offset.y);
    ctx.scale(CFG.SCALE, CFG.SCALE);
    
    // Body (suit)
    ctx.fillStyle = '#2b2b2b';
    ctx.fillRect(-12, 0, 24, 32);
    
    // Shirt
    ctx.fillStyle = '#d8e6ff';
    ctx.fillRect(-9, 3, 18, 24);
    
    // Tie  
    ctx.fillStyle = '#e02424';
    ctx.fillRect(-2, 6, 4, 20);
    
    // Head/face
    ctx.fillStyle = '#ffaa66';
    ctx.fillRect(-10, -20, 20, 20);
    
    // Hair
    ctx.fillStyle = '#ffdd44';
    ctx.fillRect(-12, -28, 24, 12);
    
    // Eyes
    ctx.fillStyle = '#fff';
    ctx.fillRect(-7, -14, 3, 2);
    ctx.fillRect(4, -14, 3, 2);
    ctx.fillStyle = '#0066ff';
    ctx.fillRect(-6, -13, 1, 1);
    ctx.fillRect(5, -13, 1, 1);
    
    // Mouth
    ctx.fillStyle = '#ff6666';
    ctx.fillRect(-3, -8, 6, 2);
    
    // Legs
    ctx.fillStyle = '#2b2b2b';
    ctx.fillRect(-8, 32, 7, 12);
    ctx.fillRect(1, 32, 7, 12);
    
    // MAGA hat (if equipped)
    if (player.capOn) {
      ctx.fillStyle = '#c41e3a';
      ctx.fillRect(-14, -32, 28, 8);
      ctx.fillRect(-10, -24, 20, 4);
      ctx.fillStyle = '#fff';
      ctx.font = '6px system-ui';
      ctx.textAlign = 'center';
      ctx.fillText('MAGA', 0, -26);
      ctx.textAlign = 'left';
    }
    
    ctx.restore();
  }

  function drawBear(x, y, alive = true) {
    const offset = getInteractionOffset({type:'bear', x, y});
    ctx.save();
    ctx.translate(x + offset.x, y + offset.y);
    ctx.scale(CFG.SCALE, CFG.SCALE);
    
    // Bear body (white/cream)
    ctx.fillStyle = alive ? '#ffffff' : '#f0f0f0';
    ctx.fillRect(-30, -20, 60, 18);
    ctx.fillRect(22, -30, 16, 12);
    
    // Bear paws
    ctx.fillRect(-26, -2, 10, 6);
    ctx.fillRect(-6, -2, 10, 6);  
    ctx.fillRect(14, -2, 10, 6);
    
    // Bear face/snout
    ctx.fillStyle = '#222';
    ctx.fillRect(34, -24, 4, 4);
    ctx.fillRect(30, -26, 2, 2);
    
    // Dead bear indicator
    if (!alive) {
      ctx.fillStyle = '#d33';
      ctx.fillRect(30, -26, 2, 2);
      ctx.fillRect(34, -24, 4, 1);
    }
    
    ctx.restore();
  }

  function drawMette(x, y) {
    const offset = getInteractionOffset({type:'mette', x, y});
    ctx.save();
    ctx.translate(x + offset.x, y + offset.y);
    ctx.scale(CFG.SCALE, CFG.SCALE);
    
    // Dress with Danish flag motif (red with white cross)
    ctx.fillStyle = '#c01818';
    ctx.fillRect(-10, 8, 20, 26);
    
    // White cross on dress (Danish flag)
    ctx.fillStyle = '#fff';
    ctx.fillRect(-2, 8, 4, 26); // Vertical stripe
    ctx.fillRect(-10, 20, 20, 4); // Horizontal stripe
    
    // Legs
    ctx.fillStyle = '#2b2b2b';
    ctx.fillRect(-6, 34, 6, 10);
    ctx.fillRect(0, 34, 6, 10);
    
    // Inner shirt
    ctx.fillStyle = '#d7cce5';
    ctx.fillRect(-7, 12, 14, 16);
    
    // Face
    ctx.fillStyle = '#f4c59a';
    ctx.fillRect(-8, -2, 16, 12);
    
    // Eyes
    ctx.fillStyle = '#111';
    ctx.fillRect(-5, 2, 2, 2);
    ctx.fillRect(3, 2, 2, 2);
    
    // Hair
    ctx.fillStyle = '#5a4a2a';
    ctx.fillRect(-9, -5, 18, 5);
    
    ctx.restore();
  }

  function drawMine(x, y) {
    const offset = getInteractionOffset({type:'mine', x, y});
    ctx.save();
    ctx.translate(x + offset.x, y + offset.y);
    ctx.scale(CFG.SCALE, CFG.SCALE);
    
    // Mine shaft entrance (dark)
    ctx.fillStyle = '#1a1a1a';
    ctx.fillRect(-18, -24, 36, 24);
    
    // Mine cart tracks
    ctx.fillStyle = '#8b7355';
    ctx.fillRect(-20, -2, 40, 2);
    ctx.fillRect(-20, 2, 40, 2);
    
    // Wooden support beams
    ctx.fillStyle = '#7b5a2b';
    ctx.fillRect(-20, -24, 4, 24);
    ctx.fillRect(16, -24, 4, 24);
    ctx.fillRect(-18, -22, 36, 4);
    
    // Sign: "RARE MINERALS"
    ctx.fillStyle = '#9b7a3e';
    ctx.fillRect(-22, -50, 44, 22);
    ctx.strokeStyle = 'rgba(0,0,0,.25)';
    ctx.strokeRect(-22, -50, 44, 22);
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 8px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('RARE MINERALS', 0, -36);
    ctx.textAlign = 'left';
    
    ctx.restore();
  }

  function drawRig(x, y) {
    const offset = getInteractionOffset({type:'rig', x, y});
    ctx.save();
    ctx.translate(x + offset.x, y + offset.y);
    ctx.scale(CFG.SCALE, CFG.SCALE);
    
    // Main rig structure (gray metal)
    ctx.fillStyle = '#696969';
    ctx.fillRect(-15, -40, 30, 40);
    
    // Drill tower
    ctx.fillStyle = '#555';
    ctx.fillRect(-3, -60, 6, 20);
    
    // Cross beams
    ctx.fillStyle = '#888';
    ctx.fillRect(-15, -30, 30, 2);
    ctx.fillRect(-15, -20, 30, 2);
    ctx.fillRect(-15, -10, 30, 2);
    
    // Drill bit
    ctx.fillStyle = '#333';
    ctx.fillRect(-1, 0, 2, 8);
    
    // Oil platform base
    ctx.fillStyle = '#7b7b7b';
    ctx.fillRect(-20, -2, 40, 4);
    
    ctx.restore();
  }

  // Interaction offset for visual feedback
  function getInteractionOffset(obj) {
    // Simple hover effect - could be enhanced
    return { x: 0, y: 0 };
  }

  function drawSpeechBubble(text, x, y) {
    if (!text) return;
    
    ctx.save();
    ctx.font = `${12 * CFG.SCALE}px system-ui`;
    ctx.textAlign = 'center';
    
    // Measure text
    const textWidth = ctx.measureText(text).width;
    const padding = 8 * CFG.SCALE;
    const bubbleWidth = textWidth + padding * 2;
    const bubbleHeight = 20 * CFG.SCALE;
    
    // Draw bubble background
    ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
    ctx.strokeStyle = '#333';
    ctx.lineWidth = 1;
    
    // Bubble rectangle
    const bubbleX = x - bubbleWidth / 2;
    const bubbleY = y - bubbleHeight;
    
    ctx.fillRect(bubbleX, bubbleY, bubbleWidth, bubbleHeight);
    ctx.strokeRect(bubbleX, bubbleY, bubbleWidth, bubbleHeight);
    
    // Draw tail
    ctx.beginPath();
    ctx.moveTo(x - 5 * CFG.SCALE, y);
    ctx.lineTo(x, y + 5 * CFG.SCALE);
    ctx.lineTo(x + 5 * CFG.SCALE, y);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
    
    // Draw text
    ctx.fillStyle = '#000';
    ctx.fillText(text, x, y - bubbleHeight / 2 + 3 * CFG.SCALE);
    
    ctx.restore();
  }
  
  function renderGameOver() {
    ctx.fillStyle = 'rgba(0,0,0,.8)';
    ctx.fillRect(0, 0, W, H);
    ctx.fillStyle = '#fff';
    ctx.textAlign = 'center';
    ctx.font = `bold ${20}px system-ui`;
    
    const lines = GS.overText.split('\n');
    lines.forEach((line, i) => {
      ctx.fillText(line, W/2, H/2 - 40 + i*25);
    });
    
    ctx.font = '12px system-ui';
    ctx.fillText('Tap to restart', W/2, H/2 + 60);
    ctx.textAlign = 'left';
  }
  
  function renderChoiceOverlay() {
    ctx.fillStyle = 'rgba(0,0,0,.6)';
    ctx.fillRect(0, 0, W, H);
    ctx.fillStyle = '#fff';
    ctx.textAlign = 'center';
    ctx.font = 'bold 16px system-ui';
    
    const lines = choiceOverlay.text.split('\n');
    lines.forEach((line, i) => {
      ctx.fillText(line, W/2, H/2 + (i-1)*20);
    });
    ctx.textAlign = 'left';
  }
  
  // Game systems
  function doJump() {
    if (!player.grounded || choiceOverlay) return;
    
    player.vy = -400 * CFG.SCALE;
    player.grounded = false;
    SFX.whoosh();
  }
  
  function doTweet() {
    tweetCount++;
    SFX.tweet();
    say(player, `Tweet #${tweetCount}: TREMENDOUS PROGRESS!`, 1500);
    
    if (scene === 'kremlin') {
      adjustRelationship('putin', {trust: -2, fear: 1}, 'tweeting_in_kremlin');
    }
  }
  
  function interact() {
    if (scene === 'greenland') {
      const obj = nearestGL();
      if (!obj) return;
      
      SFX.click();
      
      if (obj.type === 'bear' && obj.alive) {
        const oldHP = obj.hp || 3;
        obj.hp = Math.max(0, oldHP - 1);
        
        if (obj.hp <= 0) {
          obj.alive = false;
          GL.state.bearGone = true;
          if (!infected) {
            GS.achievements.bearWhisperer = true;
          }
          say(player, 'Bear defeated!', 1000);
        } else {
          say(player, `Bear hit! HP: ${obj.hp}`, 1000);
        }
      }
      else if (obj.type === 'mette') {
        say(player, 'Negotiating with Mette!', 1000);
        adjustRelationship('mette', {respect: 1}, 'interaction');
      }
      else if (obj.type === 'mine') {
        say(player, 'Great minerals here!', 1000);
      }
      else if (obj.type === 'rig') {
        say(player, 'Beautiful oil!', 1000);
      }
      else if (obj.type === 'heli') {
        console.log('Opening helicopter choice menu');
        const handleHeliChoice = function(k) {
          console.log('Helicopter choice callback executed with:', k);
          closeChoice();
          if (k === '1') {
            console.log('Selected option 1: Stay in Greenland');
            say(player, 'Staying in Greenland!', 1000);
          }
          else if (k === '2') {
            console.log('Selected option 2: Fly to White House');
            say(player, 'Flying to White House!', 1000);
          }
          else if (k === '3') {
            console.log('Selected option 3: Fly to Kremlin');
            say(player, 'Flying to Kremlin!', 1000);
          }
        };
        openChoice("Board helicopter?\n1) Stay in Greenland\n2) Fly to White House\n3) Fly to Kremlin", handleHeliChoice);
      }
    }
  }
  
  function nearestGL() {
    const objects = [GL.mine, GL.mette, GL.rig, GL.heli];
    if (GL.bear.alive) objects.push(GL.bear);
    
    const interactRange = 60 * CFG.SCALE;
    let closest = null;
    let closestDist = Infinity;
    
    for (const obj of objects) {
      const dx = player.x - obj.x;
      const dy = player.y - obj.y;
      const distance = Math.sqrt(dx * dx + dy * dy);
      
      if (distance < interactRange && distance < closestDist) {
        closest = obj;
        closestDist = distance;
      }
    }
    
    return closest;
  }
  
  // Choice overlay system
  function openChoice(text, onKey) {
    console.log('Opening choice overlay:', text);
    console.log('Callback function:', onKey);
    choiceOverlay = { text, onKey };
    console.log('Choice overlay object created:', choiceOverlay);
  }
  
  function closeChoice() {
    console.log('Closing choice overlay');
    choiceOverlay = null;
  }
  
  function say(character, text, duration) {
    character.say = text;
    character.speakingUntil = nowMs() + duration;
  }
  
  function gameOver(text) {
    GS.over = true;
    GS.overText = text;
    SFX.achievement();
  }
  
  function determineEnding() {
    const cleared = Object.values(GS.cleared).filter(v => v >= GS.needPerArea).length;
    
    if (cleared >= 2) {
      return 'TREMENDOUS SUCCESS!\nYou survived the day!\nMobile gaming mastery!';
    } else if (GS.timeLeftMs <= 0) {
      return 'TIME\'S UP!\nNot enough winning today.\nTry again on mobile!';
    } else {
      return 'GAME OVER!\nBetter luck next time.';
    }
  }
  
  function checkWin() {
    const endingText = determineEnding();
    gameOver(endingText);
  }
  
  // Mobile-specific input handling improvements
  function handleMobileInput(key, isDown) {
    if (isDown) {
      keys.add(key);
      
      // Immediate actions for mobile responsiveness
      switch(key) {
        case ' ':
          doJump();
          break;
        case 'e':
          interact();
          break;
        case 't':
          doTweet();
          break;
        case 'i':
          toggleInventory();
          break;
      }
      
      // Special mobile restart handling
      if (GS.over && key === 'e') {
        location.reload();
      }
      
    } else {
      keys.delete(key);
    }
  }
  
  // Override the simulate function for better mobile handling
  function simulateKeyEvent(key, isDown) {
    const mappedKey = {
      'up': 'arrowup',
      'down': 'arrowdown', 
      'left': 'arrowleft',
      'right': 'arrowright',
      'space': ' ',
      'e': 'e',
      't': 't',
      'i': 'i'
    }[key] || key;
    
    handleMobileInput(mappedKey, isDown);
  }
  
  // Initialize systems
  initAudio();
  renderInv();
  renderAreas2();
  
  // Helper functions
  const clamp = (v,a,b) => Math.max(a, Math.min(b, v));
  const dist = (a,b) => Math.hypot(a.x-b.x, a.y-b.y);
  const nowMs = () => performance.now();
  
  // Helicopter intro system functions
  function playEntryHeli(line, stopX) {
    entryHeli.active = true;
    entryHeli.line = line || '';
    entryHeli.vertical = true;
    entryHeli.targetX = (typeof stopX === 'number') ? stopX : 160 * CFG.SCALE;
    entryHeli.x = entryHeli.targetX;
    entryHeli.startY = -200 * CFG.SCALE;
    entryHeli.targetY = (H - world.floor) - 18 * CFG.SCALE;
    entryHeli.y = entryHeli.startY;
    entryHeli.start = nowMs();
    entryHeli.dur = 1600;
    
    // Play helicopter sound during landing (with delay for audio init)
    setTimeout(() => {
      if (audioInitialized) {
        SFX.helicopter();
      }
    }, 300);
  }
  
  function scheduleHeliIntro(line) {
    playEntryHeli(line || 'Perfect landing! Welcome to Greenland!', 160 * CFG.SCALE);
  }
  
  function startWalkTo(targetX, duration, onComplete) {
    walkTween = {
      start: nowMs(),
      dur: duration || 800,
      fromX: player.x,
      toX: targetX,
      onComplete: onComplete
    };
  }
  
  // Intro graphics functions
  function initIntro() {
    introStartTime = nowMs();
    const introCanvas = document.getElementById('introCanvas');
    if (introCanvas) {
      const rect = introCanvas.getBoundingClientRect();
      const dpr = window.devicePixelRatio || 1;
      introCanvas.width = 400 * dpr;
      introCanvas.height = 300 * dpr;
      const ictx = introCanvas.getContext('2d');
      ictx.scale(dpr, dpr);
      ictx.imageSmoothingEnabled = false;
      drawIntroGraphics(ictx, 400, 300);
    }
  }
  
  function drawIntroGraphics(ctx, w, h) {
    // White background
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0, 0, w, h);
    
    // Draw helicopter and Trump
    drawIntroHeli(ctx, w/2 - 50, h/2);
    drawIntroTrump(ctx, w/2 + 60, h/2 + 40);
  }
  
  function drawIntroHeli(ctx, x, y) {
    ctx.save();
    ctx.translate(x, y);
    
    // Helicopter body
    ctx.fillStyle = '#2c3e50';
    ctx.fillRect(-50, -12, 120, 32);
    
    // Cockpit
    ctx.fillStyle = '#86d0ff';
    ctx.fillRect(55, -8, 12, 18);
    
    // Main rotor shaft
    ctx.fillStyle = '#333';
    ctx.fillRect(7, -22, 5, 10);
    
    // Main rotor blades
    ctx.fillStyle = '#333';
    ctx.fillRect(-50, -26, 170, 4);
    
    // Rotor blur effect
    ctx.globalAlpha = 0.3;
    ctx.fillStyle = '#000';
    ctx.fillRect(-70, -28, 210, 6);
    ctx.globalAlpha = 1;
    
    // Landing skids
    ctx.fillStyle = '#333';
    ctx.fillRect(-35, 20, 70, 4);
    ctx.fillRect(25, 20, 50, 4);
    
    ctx.restore();
  }
  
  function drawIntroTrump(ctx, x, y) {
    ctx.save();
    ctx.translate(x, y);
    
    // Trump figure (mobile-optimized size)
    // Suit
    ctx.fillStyle = '#2b2b2b';
    ctx.fillRect(-12, 12, 24, 48);
    
    // Shirt
    ctx.fillStyle = '#d8e6ff';
    ctx.fillRect(-9, 15, 18, 28);
    
    // Tie
    ctx.fillStyle = '#e02424';
    ctx.fillRect(-2, 18, 4, 22);
    
    // Head/face
    ctx.fillStyle = '#ffaa66';
    ctx.fillRect(-12, -12, 24, 24);
    
    // Hair
    ctx.fillStyle = '#ffdd44';
    ctx.fillRect(-14, -18, 28, 12);
    
    // Eyes
    ctx.fillStyle = '#111';
    ctx.fillRect(-7, -2, 2, 2);
    ctx.fillRect(5, -2, 2, 2);
    
    // Mouth
    ctx.fillStyle = '#ff6b6b';
    ctx.fillRect(-3, 3, 6, 2);
    
    ctx.restore();
  }

  // Initialize intro graphics
  initIntro();

  // Camera system for proper positioning
  const camera = { x: 0, y: 0, target: null };
  
  function setCameraToHelicopter() {
    // Position camera to show helicopter on the left side
    const heliX = GL.heli.x || 160 * CFG.SCALE;
    camera.x = Math.max(0, heliX - W * 0.3); // Show helicopter on left side of screen
    camera.y = 0;
  }
  
  function updateCamera() {
    // Follow player with smooth camera movement
    const targetCameraX = player.x - W * 0.5; // Keep player in center
    const maxCameraX = Math.max(0, 1200 * CFG.SCALE - W); // Don't go past world bounds
    const newCameraX = Math.max(0, Math.min(maxCameraX, targetCameraX));
    
    // Smooth camera movement (lerp)
    const lerpSpeed = 0.1;
    camera.x += (newCameraX - camera.x) * lerpSpeed;
  }
  
  function resetGreenland() {
    const g = H - world.floor;
    player.x = 180 * CFG.SCALE; // Start near helicopter
    player.y = g;
    
    // Reset scene objects
    Object.assign(GL.mine, {x: 520 * CFG.SCALE, y: g});
    Object.assign(GL.rig, {x: 380 * CFG.SCALE, y: g});
    Object.assign(GL.heli, {x: 160 * CFG.SCALE, y: g - 18 * CFG.SCALE});
    Object.assign(GL.bear, {x: 760 * CFG.SCALE, y: g, alive: true, hp: 3, speakingUntil: 0});
    Object.assign(GL.mette, {x: 980 * CFG.SCALE, y: g, speakingUntil: 0});
    
    // Set camera to show helicopter
    setCameraToHelicopter();
    
    GL.state = { flagPlanted: false, bearGone: false, hasTweeted: false };
    
    // Trigger helicopter landing intro if not played yet
    if (!introPlayed) {
      scheduleHeliIntro('Touchdown in Greenland ‚Äî tremendous ice! Helicopter goes anywhere.');
    }
  }

  // Start intro screen handling
  const introEl = document.getElementById('intro');
  if (introEl) {
    if (isMobile) {
      introEl.addEventListener('touchstart', (e) => {
        e.preventDefault();
        introEl.style.display = 'none';
        scene = 'greenland';
        resetGreenland();
        
        // Initialize audio with user interaction
        ensureAudioInit();
        
        requestAnimationFrame(gameLoop);
      }, { passive: false });
    } else {
      // Desktop intro is handled by main keyboard listener - no additional listener needed
    }
  }
  
  console.log('Trump Greenland Mobile initialized');
  
})();
</script>
</body>
</html>