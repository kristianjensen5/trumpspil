<!DOCTYPE html>
<html lang="da">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Gr√∏nlandssatire ‚Äì TrumpV2</title>
<style>
  html,body{margin:0;height:100%;background:#dff4ff;color:#111;font:16px/1.4 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
  canvas{display:block;width:100%;height:100%;touch-action:none}
  .ui{
    position:fixed;left:12px;bottom:12px;z-index:10;
    background:rgba(0,0,0,.7);color:#fff;padding:10px 12px;border-radius:12px;font-size:13px;line-height:1.4;
    box-shadow:0 2px 8px rgba(0,0,0,.4);backdrop-filter:blur(4px);max-width:300px
  }
  .ui kbd{background:rgba(255,255,255,.18);padding:0 .4em;border-radius:6px}
  .notice{
    position:fixed;right:12px;bottom:12px;background:rgba(0,0,0,.5);color:#fff;
    padding:6px 10px;border-radius:8px;font-size:12px
  }
  .inv{
    position:fixed;right:12px;top:50%;transform:translateY(-50%);z-index:9;
    background:rgba(0,0,0,.7);color:#fff;border-radius:12px;padding:8px 6px;display:flex;flex-direction:column;gap:6px;align-items:center;
    max-height:min(80vh, 600px);overflow-y:auto;backdrop-filter:blur(4px);
    box-shadow:0 2px 8px rgba(0,0,0,.4)
  }
  .inv.hidden{display:none}
  .slot{
    width:70px;height:60px;border-radius:8px;background:rgba(255,255,255,.12);
    display:flex;flex-direction:column;align-items:center;justify-content:center;gap:2px;padding:4px 6px;
    box-sizing:border-box; overflow:hidden;flex-shrink:0
  }
  .slot span{font-size:9px;opacity:.9;text-align:center;line-height:1.1;max-width:100%;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;color:#fff}
  .slot b{font-size:10px;text-align:center;max-width:100%;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;color:#fff}
  .slot b, .slot span{display:block;text-shadow:0 1px 1px rgba(0,0,0,.5)}
  .slot.empty{background:rgba(255,255,255,.06);border:1px dashed rgba(255,255,255,.25)}
  .hud{position:fixed;right:12px;top:110px;z-index:10;display:flex;gap:8px;align-items:flex-start;flex-wrap:wrap;flex-direction:column}
  .chip{background:rgba(0,0,0,.7);color:#fff;border-radius:12px;padding:6px 12px;font-size:12px;font-weight:500;box-shadow:0 2px 4px rgba(0,0,0,.3)}
  .slot canvas{display:block;margin:0 auto;}
  .areas{position:fixed;left:50%;top:12px;transform:translateX(-50%);z-index:10;display:flex;gap:8px;flex-wrap:wrap;justify-content:center;max-width:90vw}
  .pill{background:rgba(0,0,0,.7);color:#fff;border-radius:12px;padding:6px 12px;font-size:13px;font-weight:500;white-space:nowrap;box-shadow:0 2px 4px rgba(0,0,0,.3)}
  .doombar{position:fixed;left:50%;top:60px;transform:translateX(-50%);z-index:10;
    background:rgba(0,0,0,.8);color:#fff;border-radius:12px;padding:8px 12px;
    box-shadow:0 2px 8px rgba(0,0,0,.4);backdrop-filter:blur(4px);
    display:flex;align-items:center;gap:10px;font-size:13px;font-weight:500}
  .doombar-progress{width:200px;height:12px;border-radius:8px;background:#1e5631;overflow:hidden;box-shadow:inset 0 0 0 1px rgba(0,0,0,.5)}
  .doombar-fill{display:block;height:100%;background:#c62828;width:0%;transition:width 0.3s ease}
  .bar{width:180px;height:10px;border-radius:6px;background:#2e7d32;overflow:hidden;box-shadow:inset 0 0 0 1px rgba(0,0,0,.3)}
  .bar>i{display:block;height:100%;background:#c62828;width:0%}
  .hint-label{display:none}
  @media (prefers-reduced-motion: reduce){ * { animation: none !important; transition: none !important; } }
  @media (pointer: coarse){ .ui{font-size:12px} }
  
  /* 80s Retro Intro Screen */
  .intro-screen {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 100;
    background: linear-gradient(45deg, #1a0033, #330066, #000033);
    display: flex; flex-direction: column; justify-content: center; align-items: center;
    font-family: 'Courier New', monospace; color: #00ffff; text-align: center;
    animation: scanlines 2s linear infinite; padding: 20px; box-sizing: border-box;
    gap: 20px;
  }
  @keyframes scanlines {
    0% { background-position: 0 0; }
    100% { background-position: 0 4px; }
  }
  .intro-title {
    font-size: clamp(24px, 8vw, 48px); font-weight: bold; 
    text-shadow: 0 0 10px #00ffff, 0 0 20px #00ffff, 0 0 40px #00ffff;
    letter-spacing: 2px; margin: 0;
    animation: glow 2s ease-in-out infinite alternate;
    width: 100%; text-align: center;
  }
  .intro-subtitle {
    font-size: clamp(14px, 4vw, 20px); color: #ffff00; 
    text-shadow: 0 0 5px #ffff00; opacity: 0.9;
    max-width: 90%; line-height: 1.4; margin: 0;
    width: 100%; text-align: center;
  }
  @keyframes glow {
    from { text-shadow: 0 0 10px #00ffff, 0 0 20px #00ffff, 0 0 40px #00ffff; }
    to { text-shadow: 0 0 5px #00ffff, 0 0 10px #00ffff, 0 0 20px #00ffff; }
  }
  .intro-prompt {
    font-size: clamp(14px, 3vw, 18px); color: #ff00ff; 
    text-shadow: 0 0 5px #ff00ff, 0 0 10px #ff00ff, 0 0 15px #ff00ff;
    animation: blinkGlow 1.2s ease-in-out infinite; margin: 0;
    width: 100%; text-align: center; font-weight: bold;
    letter-spacing: 1px;
  }
  @keyframes blinkGlow {
    0%, 40% { 
      opacity: 1; 
      text-shadow: 0 0 5px #ff00ff, 0 0 10px #ff00ff, 0 0 15px #ff00ff, 0 0 20px #ff00ff;
      transform: scale(1);
    }
    50%, 90% { 
      opacity: 0.4; 
      text-shadow: 0 0 2px #ff00ff, 0 0 5px #ff00ff;
      transform: scale(0.98);
    }
    100% { 
      opacity: 1; 
      text-shadow: 0 0 5px #ff00ff, 0 0 10px #ff00ff, 0 0 15px #ff00ff, 0 0 20px #ff00ff;
      transform: scale(1);
    }
  }
  .intro-button {
    appearance: none; border: 2px solid #00ffff; background: rgba(0,0,0,.4);
    color: #00ffff; font-family: 'Courier New', monospace; font-weight: 700;
    padding: 10px 18px; border-radius: 10px; cursor: pointer;
    text-shadow: 0 0 6px #00ffff; box-shadow: 0 0 10px rgba(0,255,255,.3);
    transition: transform .08s ease, box-shadow .12s ease, background .12s ease;
  }
  .intro-button:focus { outline: none; box-shadow: 0 0 0 3px rgba(0,255,255,.4); }
  .intro-button:active { transform: scale(0.98); background: rgba(0,0,0,.6); }
</style>
</head>
<body>
<canvas id="game"></canvas>

<div class="ui">
  ‚Üê‚Üì‚Üí bev√¶gelse ¬∑ <kbd>Space</kbd> hop ¬∑ <kbd>E</kbd> interag√©r ¬∑ <kbd>I</kbd> inventar ¬∑ <kbd>T</kbd> tweet<br>
  <small style="opacity: 0.8;"><kbd>R</kbd> reset ¬∑ <kbd>N</kbd> non-violent ¬∑ <kbd>F</kbd> FPS ¬∑ <kbd>`</kbd> debug</small>
  <span class="hint-label" aria-hidden="true">E: interag√©r</span>
  <!-- .hint-label is used to keep wording centralized if you localize -->
  
</div>
<div id="hud" class="hud"></div>
<div id="inv" class="inv"></div>
<div id="areas2" class="areas"></div>
<div id="doombar" class="doombar"></div>
<div id="intro" class="intro-screen">
  <canvas id="intro-canvas" width="600" height="400" style="image-rendering: pixelated; border: 2px solid #00ffff; background: #000022; max-width: min(90vw, 600px); height: auto; flex-shrink: 0;"></canvas>
  <div class="intro-title">Pr√∏v ikke at √∏del√¶gge verden, Donald.</div>
  <div class="intro-subtitle">Det er et h√•rdt job at v√¶re den bedste pr√¶sident nogensinde!<br>Pr√∏v at overleve i 6 minutter</div>
  <div class="intro-prompt" aria-live="polite">Tryk Enter eller klik Start for at begynde</div>
  <button id="start-btn" class="intro-button" type="button" aria-label="Start spil">Start</button>
</div>

<script>
(() => {
  // ---------- Konfiguration ----------
  const CFG = {
    NON_VIOLENT: false,
    SPEED: 140,
    INTERACT_DIST: 48,
    BUBBLE_TIME: 2000,
    SCALE: 1,
    SHOW_PULSE: false,
    DEBUG: false, // Toggle for debug info
    SHOW_FPS: false // Toggle for FPS counter
  };
  
  // ---------- Game Constants ----------
  const GAME_CONSTANTS = {
    // Character dimensions and positioning
    CHAR: {
      WIDTH: 24,
      HEIGHT: 44,
      BEAR_WIDTH: 70,
      BEAR_HEIGHT: 40
    },
    
    // UI and bubble positioning
    UI: {
      BUBBLE_FONT_SIZE: 12,
      BUBBLE_LINE_HEIGHT: 16,
      BUBBLE_PADDING: 8,
      BUBBLE_TAIL_OFFSET: 18,
      BUBBLE_Y_OFFSET: 46,
      BUBBLE_TAIL_Y: 30,
      PULSE_DISTANCE: 110,
      INTERACTION_FEEDBACK_SIZE: 3,
      CLICK_DISTANCE: 100
    },
    
    // World positioning (base values before scaling)
    WORLD: {
      FLOOR_HEIGHT: 120,
      PLAYER_START_X: 160,
      HELI_Y_OFFSET: 18,
      GREENLAND: {
        MINE_X: 520,
        RIG_X: 380,
        HELI_X: 160,
        BEAR_X: 760,
        METTE_X: 980
      },
      OVAL: {
        DOOR_X: 160,
        AIDE_X: 380,
        HELI_X: 160,
        YES_X: 820
      },
      KREMLIN: {
        DOOR_X: 160,
        PUTIN_X: 380,
        HELI_X: 160
      }
    },
    
    // Physics and movement
    PHYSICS: {
      GRAVITY: 1400,
      BEAR_SPEED: 100,
      BEAR_ANGRY_SPEED: 300,
      BEAR_CHASE_DISTANCE: 30,
      BEAR_ATTACK_CHANCE: 0.02,
      KNOCKBACK_FORCE: 280,
      HORIZONTAL_KNOCKBACK: 60,
      SCREEN_MARGIN: 40,
      BOUNCE_DAMPING: 0.3,
      CHASE_DAMPING: 0.96,
      NORMAL_DAMPING: 0.92,
      GROUND_DAMPING_CHASE: 0.95,
      GROUND_DAMPING_NORMAL: 0.85
    },
    
    // Coins and collectibles positioning
    COINS: {
      GREENLAND_POSITIONS: [
        {x: 250, y: -35},
        {x: 450, y: -45},
        {x: 650, y: -40},
        {x: 850, y: -25}
      ],
      OVAL_POSITIONS: [
        {x: 300, y: -30},
        {x: 500, y: -35},
        {x: 700, y: -25}
      ],
      KREMLIN_POSITIONS: [
        {x: 280, y: -30},
        {x: 480, y: -35},
        {x: 680, y: -25},
        {x: 880, y: -40}
      ]
    },
    
    // Animation and effects
    ANIMATION: {
      BLINK_DURATION: 150,
      NOD_SPEED: 0.8,
      PRESS_EFFECT_DURATION: 200,
      SHAKE_AMPLITUDE: 8,
      SHAKE_DURATION: 600,
      FEEDBACK_DURATION: 500,
      WATER_RISE_SPEED: 480, // frames to rise full height
      EXPLOSION_DELAY: 2000,
      INTRO_UPDATE_MS: 100
    },
    
    // Game timing and scoring
    GAME: {
      TOTAL_TIME_MS: 6 * 60 * 1000, // 6 minutes
      NEEDED_PER_AREA: 3,
      DOOM_CRITICAL: 100,
      DOOM_HIGH: 90,
      UI_THRESHOLDS: { TENSION: 25, WAR: 50, CRITICAL: 80 },
      RELATIONSHIP_THRESHOLDS: {
        TRUST_LOW: 30,
        RESPECT_LOW: 30,
        FEAR_HIGH: 70
      }
    },
    
    // Performance and rendering
    PERFORMANCE: {
      TARGET_FPS: 60,
      MIN_FPS: 30,
      MOUSE_THROTTLE_MS: 16,
      MAX_BORDER_POINTS: 200,
      PARTICLE_LIMITS: {
        BLOOD: 100,
        SPARKS: 50,
        DOWNWASH: 30,
        OIL: 40,
        FLAME: 25
      }
    }
  };
  
  // ---------- Scene System ----------
  class Scene {
    constructor(name) {
      this.name = name;
      this.objects = [];
      this.characters = [];
      this.initialized = false;
    }
    
    init() {
      if (this.initialized) return;
      this.reset();
      this.initialized = true;
    }
    
    reset() {
      // Override in subclasses
    }
    
    update(dt) {
      // Override in subclasses
      this.characters.forEach(char => {
        if (char.update) char.update(dt);
      });
    }
    
    draw(ctx) {
      // Override in subclasses
      this.objects.forEach(obj => {
        if (obj.draw) obj.draw(ctx);
      });
      this.characters.forEach(char => {
        if (char.draw) char.draw(ctx);
      });
    }
    
    handleClick(x, y) {
      // Override in subclasses
      return false; // Return true if click was handled
    }
    
    handleInteraction(obj) {
      // Override in subclasses  
      return false; // Return true if interaction was handled
    }
    
    getNearestObject(x, y, maxDistance = GAME_CONSTANTS.UI.PULSE_DISTANCE) {
      let nearest = null;
      let nearestDist = maxDistance * CFG.SCALE;
      
      [...this.objects, ...this.characters].forEach(obj => {
        if (!obj.x || !obj.y) return;
        const dist = Math.hypot(x - obj.x, y - obj.y);
        if (dist < nearestDist) {
          nearest = obj;
          nearestDist = dist;
        }
      });
      
      return nearest ? { obj: nearest, dist: nearestDist } : null;
    }
  }
  
  // Scene Manager
  const SceneManager = {
    scenes: new Map(),
    currentScene: null,
    
    registerScene(scene) {
      this.scenes.set(scene.name, scene);
    },
    
    switchToScene(sceneName) {
      const scene = this.scenes.get(sceneName);
      if (!scene) {
        console.warn(`Scene '${sceneName}' not found`);
        return false;
      }
      
      this.currentScene = scene;
      scene.init();
      return true;
    },
    
    getCurrentScene() {
      return this.currentScene;
    },
    
    update(dt) {
      if (this.currentScene) {
        safeExecute(() => this.currentScene.update(dt), `Scene ${this.currentScene.name} update`);
      }
    },
    
    draw(ctx) {
      if (this.currentScene) {
        safeDraw(() => this.currentScene.draw(ctx), `Scene ${this.currentScene.name} draw`);
      }
    },
    
    handleClick(x, y) {
      if (this.currentScene) {
        return safeExecute(() => this.currentScene.handleClick(x, y), `Scene ${this.currentScene.name} click`, false);
      }
      return false;
    },
    
    handleInteraction(obj) {
      if (this.currentScene) {
        return safeExecute(() => this.currentScene.handleInteraction(obj), `Scene ${this.currentScene.name} interaction`, false);
      }
      return false;
    }
  };
  
  // Performance monitoring
  const PERF = {
    frameCount: 0,
    lastFpsUpdate: 0,
    fps: 0,
    renderTime: 0,
    particleCount: 0
  };
  
  // ---------- Graphics Configuration System ----------
  const GRAPHICS = {
    // Image cache for loaded custom graphics
    images: new Map(),
    loading: new Set(),
    
    // Configuration for custom graphics URLs
    config: {
      // Characters
      trump: null,           // URL for Trump sprite
      mette: null,          // URL for Mette sprite
      putin: null,          // URL for Putin sprite
      bear: null,           // URL for Bear sprite
      aide: null,           // URL for Aide sprite
      
      // Backgrounds
      greenland_bg: null,   // URL for Greenland background
      oval_bg: null,        // URL for Oval Office background  
      kremlin_bg: null,     // URL for Kremlin background
      
      // Objects
      helicopter: null,     // URL for helicopter sprite
      mine: null,           // URL for mine sprite
      rig: null,            // URL for oil rig sprite
      flag: null,           // URL for flag sprite
      phone: null,          // URL for phone sprite
      door: null,           // URL for door sprite
      gold_bar: null,       // URL for gold bar (coin) sprite
      dynamite: null,       // URL for dynamite item sprite
      yes_member: null,     // URL for praising group member sprite
      glacier: null,        // URL for glacier sprite
      
      // Items
      tan_bottle: null,     // URL for tan bottle item
      maga_cap: null,       // URL for MAGA cap item
      cl_trophy: null,      // URL for CL trophy item
      gold_statue: null,    // URL for gold statue item
      
      // Effects
      missile: null,        // URL for missile sprite
      explosion: null,      // URL for explosion effect
      
      // UI Elements
      inventory_bg: null,   // URL for inventory background
      button: null          // URL for button sprite
    },
    
    // Load an image from URL and cache it
    loadImage(key, url) {
      if (!url) return null;
      if (this.images.has(key)) return this.images.get(key);
      if (this.loading.has(key)) return null;
      
      this.loading.add(key);
      const img = new Image();
      img.crossOrigin = 'anonymous'; // For CORS support
      
      img.onload = () => {
        this.images.set(key, img);
        this.loading.delete(key);
        if (CFG.DEBUG) console.log(`Loaded custom graphic: ${key}`);
      };
      
      img.onerror = () => {
        this.loading.delete(key);
        console.warn(`Failed to load custom graphic: ${key} from ${url}`);
      };
      
      img.src = url;
      return null; // Will be available on next frame
    },
    
    // Get cached image or load if needed
    getImage(key) {
      const url = this.config[key];
      if (!url) return null;
      return this.loadImage(key, url);
    },
    
    // Draw image if available, otherwise use fallback function
    drawOrFallback(ctx, key, fallbackFn, ...args) {
      const img = this.getImage(key);
      if (img && img.complete) {
        // Extract x, y from args for image drawing
        const [x, y] = args;
        return this.drawImage(ctx, img, x, y);
      } else {
        fallbackFn(...args);
        return false;
      }
    },
    
    // Draw image with proper scaling and positioning
    drawImage(ctx, img, x, y, width = null, height = null, centered = true) {
      if (!img || !img.complete) return false;
      
      const w = width || img.width * CFG.SCALE;
      const h = height || img.height * CFG.SCALE;
      const dx = centered ? x - w/2 : x;
      const dy = centered ? y - h/2 : y;
      
      ctx.drawImage(img, dx, dy, w, h);
      return true;
    },

    // Draw full-screen background if available (cover)
    drawBackground(ctx, key) {
      const url = this.config[key];
      if (!url) return false;
      const img = this.images.get(key);
      if (!(img && img.complete)) {
        this.loadImage(key, url);
        return false;
      }
      // Simple stretch to canvas size; callers can layer content atop
      ctx.drawImage(img, 0, 0, W, H);
      return true;
    },

    // Check if an image is loaded and ready
    imageReady(key){ const img = this.images.get(key); return !!(img && img.complete); },
    
    // Update configuration from external source
    updateConfig(newConfig) {
      Object.assign(this.config, newConfig);
      if (CFG.DEBUG) console.log('Updated graphics configuration:', this.config);
    },
    
    // Clear cache (useful for reloading graphics)
    clearCache() {
      this.images.clear();
      this.loading.clear();
    }
  };
  
  // Expose graphics system globally for external configuration
  window.GRAPHICS = GRAPHICS;
  
  // Convenience function for setting graphics URLs
  window.setGraphic = function(key, url) {
    if (GRAPHICS.config.hasOwnProperty(key)) {
      GRAPHICS.config[key] = url;
      if (CFG.DEBUG) console.log(`Set graphic ${key} to: ${url}`);
    } else {
      console.warn(`Unknown graphic key: ${key}. Available keys:`, Object.keys(GRAPHICS.config));
    }
  };
  
  // Function to set multiple graphics at once
  window.setGraphics = function(configObject) {
    GRAPHICS.updateConfig(configObject);
  };
  
  // Function to list all available graphic keys
  window.listGraphics = function() {
    if (CFG.DEBUG) console.log('Available graphics to customize:', Object.keys(GRAPHICS.config));
    return Object.keys(GRAPHICS.config);
  };
  
  // Standard dimensions for graphics (at CFG.SCALE = 1)
  window.GRAPHICS_DIMENSIONS = {
    // Characters (width x height in pixels)
    trump: { width: 24, height: 44, description: 'Trump character sprite' },
    mette: { width: 24, height: 44, description: 'Mette character sprite' },
    putin: { width: 24, height: 44, description: 'Putin character sprite' },
    bear: { width: 60, height: 30, description: 'Polar bear sprite' },
    aide: { width: 24, height: 44, description: 'Aide character sprite' },
    
    // Objects
    helicopter: { width: 140, height: 40, description: 'Helicopter sprite (includes rotor)' },
    mine: { width: 40, height: 20, description: 'Mine entrance sprite' },
    rig: { width: 64, height: 80, description: 'Oil rig sprite' },
    flag: { width: 36, height: 64, description: 'Flag sprite (pole + flag)' },
    phone: { width: 16, height: 20, description: 'Phone sprite' },
    door: { width: 28, height: 80, description: 'Door sprite' },
    gold_bar: { width: 20, height: 12, description: 'Gold bar (coin) sprite' },
    dynamite: { width: 12, height: 24, description: 'Dynamite item sprite' },
    yes_member: { width: 24, height: 44, description: 'Yes-group member sprite' },
    glacier: { width: 120, height: 100, description: 'Glacier sprite (varies)' },
    
    // Items (inventory size)
    tan_bottle: { width: 16, height: 24, description: 'Tan bottle item' },
    maga_cap: { width: 20, height: 12, description: 'MAGA cap item' },
    cl_trophy: { width: 18, height: 24, description: 'Champions League trophy item' },
    gold_statue: { width: 18, height: 30, description: 'Gold statue item' },
    
    // Effects
    missile: { width: 20, height: 56, description: 'Nuclear missile sprite' },
    explosion: { width: 80, height: 80, description: 'Explosion effect sprite' },
    
    // Backgrounds (full screen)
    greenland_bg: { width: 1200, height: 800, description: 'Greenland background (will be scaled to screen)' },
    oval_bg: { width: 1200, height: 800, description: 'Oval Office background (will be scaled to screen)' },
    kremlin_bg: { width: 1200, height: 800, description: 'Kremlin background (will be scaled to screen)' },
    
    // UI Elements
    inventory_bg: { width: 70, height: 60, description: 'Inventory slot background' },
    button: { width: 32, height: 16, description: 'Button sprite' }
  };
  
  // Function to get recommended dimensions
  window.getGraphicDimensions = function(key) {
    const dim = GRAPHICS_DIMENSIONS[key];
    if (dim) {
      if (CFG.DEBUG) console.log(`${key}: ${dim.width}x${dim.height}px - ${dim.description}`);
      return dim;
    } else {
      console.warn(`No dimensions defined for: ${key}`);
      return null;
    }
  };
  
  // Function to show all dimensions
  window.showAllDimensions = function() {
    if (CFG.DEBUG) {
      console.log('=== GRAPHICS DIMENSIONS GUIDE ===');
      Object.entries(GRAPHICS_DIMENSIONS).forEach(([key, dim]) => {
        console.log(`${key.padEnd(15)}: ${dim.width.toString().padEnd(4)}x${dim.height.toString().padEnd(4)}px - ${dim.description}`);
      });
    }
  };

  // ---------- Canvas ----------
  const cvs = document.getElementById('game');
  if (!cvs) {
    console.error('Canvas element "game" not found!');
    return;
  }
  const ctx = cvs.getContext('2d');
  if (!ctx) {
    console.error('2D context not supported!');
    return;
  }
  // Accessibility hint for screen readers
  try { cvs.setAttribute('aria-label','Spilomr√•de'); } catch(_){}
  let W=0,H=0,DPR=1, last=performance.now(), deltaTime=0;
  const TARGET_FPS = (GAME_CONSTANTS.PERFORMANCE && GAME_CONSTANTS.PERFORMANCE.TARGET_FPS) || 60;
  const MAX_DELTA = 1000 / ((GAME_CONSTANTS.PERFORMANCE && GAME_CONSTANTS.PERFORMANCE.MIN_FPS) || 30); // Cap at configured min FPS
  let skyGrad = null; // cached sky gradient
  // ambient clouds
  let CLOUDS = [];
  // Optional background image for border map (set via setMapImage(url))
  const MAP_IMG = new Image();
  let MAP_IMG_READY = false;
  function setMapImage(url){
    MAP_IMG_READY = false;
    MAP_IMG.onload = ()=>{ MAP_IMG_READY = true; };
    MAP_IMG.onerror = ()=>{ MAP_IMG_READY = false; };
    if (url) MAP_IMG.src = url;
  }

  function fit() {
    try {
      DPR = window.devicePixelRatio || 1;
      W = Math.round(innerWidth);
      H = Math.round(innerHeight);
      cvs.width = Math.round(W*DPR);
      cvs.height = Math.round(H*DPR);
      ctx.setTransform(DPR,0,0,DPR,0,0);
      CFG.SCALE = Math.max(0.8, Math.min(1.4, W/1200));
      // cache gradient per size
      skyGrad = ctx.createLinearGradient(0,0,0,H);
      skyGrad.addColorStop(0,'#dff4ff');
      skyGrad.addColorStop(1,'#a7dfff');
    } catch(err) {
      console.warn('Canvas resize failed:', err);
      // Fallback values
      W = W || 800;
      H = H || 600;
      CFG.SCALE = CFG.SCALE || 1;
    }
  }
  fit();
  addEventListener('resize', fit);

  // ---------- Input ----------
  const keys = new Set();
  let choiceOverlay = null; // {text, onKey(k)}
  let flagOverlay = null; // {flagType, startTime} - shows flag planted on Ukraine
  let tweetCount = 0;
  // Consolidated keydown handler for better performance
  addEventListener('keydown', e => {
    const k = e.key.toLowerCase();
    let handled = false;
    
    // Intro screen handling
    if (scene === 'intro') {
      if (k === 'enter' || e.code === 'Enter' || (k.length === 1 && k !== ' ' && k !== 'e')) { startGame(); handled = true; }
      if (handled) e.preventDefault();
      return;
    }
    
    // Game over screen handling - allow Shift+R to restart
    if (GS.over && k === 'r' && e.shiftKey) {
      // Full game restart - go back to intro screen
      resetStateDefaults();
      inventory.length = 0; 
      collectedCoins = 0; // Reset coin counter
      renderInv();
      player.speedMul = 1; 
      player.tanLevel = 0; 
      player.capOn = false; 
      player.speedBoost10 = false; player.healthBoost18 = false; player.masterCollector = false; // Reset coin rewards
      renderHUD();
      GS.over = false;
      GS.overText = '';
      scene = 'intro';
      document.getElementById('intro').style.display = 'block';
      handled = true;
      if (handled) e.preventDefault();
      return;
    }
    
    if (choiceOverlay) {
      if (k==='1' || k==='2' || k==='3' || k==='4') { choiceOverlay.onKey(k); handled = true; }
      else if (k==='escape' || k==='esc') { closeChoice(); handled = true; }
    } else if (infoCard) {
      if (k==='1' || k==='2' || k==='3' || k==='4') { infoCard.onKey(k); handled = true; }
      else if (k==='escape' || k==='esc') { closeInfoCard(); handled = true; }
    } else if (flagOverlay) {
      // Only Enter key closes flag overlay
      if (k==='enter') { closeFlagOverlay(); handled = true; }
    } else if (borderDraw){
      if (k==='enter'){ stopBorderDraw(true); handled = true; }
      else if (k==='escape' || k==='esc'){ stopBorderDraw(false); handled = true; }
      else if (k==='backspace'){ if (borderDraw.points.length>0) borderDraw.points.pop(); handled = true; }
      else if (k==='u' && borderDraw.points.length>2){ smoothBorder(); handled = true; }
      else if (k==='c'){ borderDraw.points = []; isDrawing = false; lastDrawPoint = null; handled = true; }
    } else if (tug && (k==='a' || k==='d')){ 
      handleTugKey(k); handled = true; 
    } else {
      // Normal game controls
      keys.add(k);
      if (k==='n') CFG.NON_VIOLENT = !CFG.NON_VIOLENT;
      else if (k==='f') CFG.SHOW_FPS = !CFG.SHOW_FPS; // Toggle FPS display
      else if (k==='`') CFG.DEBUG = !CFG.DEBUG; // Toggle debug mode
      else if (k==='t') doTweet();
      else if (k===' ') doJump();
      else if (k==='1' || k==='2' || k==='3' || k==='4') { useInventoryKey(k); handled = true; }
      else if (k==='i') toggleInventory();
      else if (k==='e') interact();
      // Reset handling
      else if (k==='r') {
        if (e.shiftKey){ // hard reset
          resetStateDefaults();
          inventory.length = 0; 
          collectedCoins = 0; // Reset coin counter
          renderInv();
          player.speedMul = 1; player.tanLevel = 0; player.capOn = false; 
          player.speedBoost10 = false; player.healthBoost18 = false; player.masterCollector = false; // Reset coin rewards
          renderHUD();
        } else {
          resetStateDefaults();
        }
        if (scene==='greenland') resetGreenland(); else resetOval();
        handled = true;
      }
      
      if (['arrowup','arrowdown','arrowleft','arrowright',' '].includes(e.key)) handled = true;
    }
    
    if (handled) e.preventDefault();
  }, {passive:false});
  addEventListener('keyup', e => keys.delete(e.key.toLowerCase()));

  // ---------- Hj√¶lpere ----------
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const dist = (a,b)=>Math.hypot(a.x-b.x,a.y-b.y);
  const nowMs = ()=>performance.now();
  
  // Helper function to darken colors for button press effect
  function darkenColor(color) {
    if (color.startsWith('#')) {
      const hex = color.slice(1);
      const num = parseInt(hex, 16);
      const r = Math.max(0, (num >> 16) - 40);
      const g = Math.max(0, ((num >> 8) & 0x00FF) - 40);
      const b = Math.max(0, (num & 0x0000FF) - 40);
      return `#${((r << 16) | (g << 8) | b).toString(16).padStart(6, '0')}`;
    }
    return color; // fallback if not hex color
  }

  // ---------- Don't-destroy-the-world Game State ----------
  const GS = {
    timeLeftMs: (GAME_CONSTANTS && GAME_CONSTANTS.GAME && GAME_CONSTANTS.GAME.TOTAL_TIME_MS) || 6*60*1000,
    doom: 0,
    cleared: { greenland:0, oval:0, kremlin:0, epstein:0 },
    // Align required tasks per area with GAME_CONSTANTS
    needPerArea: (GAME_CONSTANTS && GAME_CONSTANTS.GAME && GAME_CONSTANTS.GAME.NEEDED_PER_AREA) || 5,
    over: false,
    overText: '',
    achievements: {
      perfectDiplomat: false, // Win with all relationships > 70
      speedRunner: false, // Win with > 4 minutes remaining
      collector: false, // Win with 10+ inventory items
      peacemaker: false, // Win without increasing doom
      twitterAddict: false, // Tweet 5+ times
      bearWhisperer: false // Defeat bear without infection
    }
  };
  const areasEl2 = document.getElementById('areas2');
  try { areasEl2 && areasEl2.setAttribute('aria-live','polite'); } catch(_){}

  function fmtTime(ms){ const s=Math.max(0,Math.ceil(ms/1000)); const m=(s/60|0).toString().padStart(2,'0'); const ss=(s%60).toString().padStart(2,'0'); return m+':'+ss; }
  function renderAreas2(){ if (!areasEl2) return; areasEl2.innerHTML=''; [['greenland','üá¨üá± Gr√∏nland'],['oval','üèõÔ∏è Hvide Hus'],['kremlin','üá∑üá∫ Kremlin'],['epstein','üìÑ Documents']].forEach(([k,label])=>{ const d=document.createElement('span'); d.className='pill'; const progress = GS.cleared[k] || 0; const needed = GS.needPerArea; let bgColor = 'rgba(200,0,0,.8)'; if (progress >= needed) bgColor = 'rgba(0,150,0,.8)'; else if (progress > 0) bgColor = 'rgba(200,150,0,.8)'; d.style.background = bgColor; d.textContent=`${label}: ${progress}/${needed}`; areasEl2.appendChild(d); }); }
  renderAreas2();
  
  // ---------- Game State Variables ----------
  let scene = 'intro'; // 'intro' | 'greenland' | 'oval' | 'kremlin' | 'epstein'
  let introStartTime = 0;
  const world = { floor: 120 };
  let borderDraw = null; // Add this here too
  
  // Removed infection system - replaced with bear chasing
  
  // ---------- Relationship System ----------
  const RELATIONSHIPS = {
    mette: {
      respect: 50, // 0-100
      trust: 50,
      fear: 20,
      lastInteraction: 'neutral'
    },
    putin: {
      respect: 30,
      trust: 20, 
      fear: 10,
      lastInteraction: 'neutral'
    }
  };
  
  function adjustRelationship(character, changes, reason) {
    const rel = RELATIONSHIPS[character];
    if (!rel) return;
    
    // Apply changes with bounds checking
    Object.keys(changes).forEach(stat => {
      if (rel.hasOwnProperty(stat)) {
        rel[stat] = Math.max(0, Math.min(100, rel[stat] + changes[stat]));
      }
    });
    
    // Store context
    rel.lastInteraction = reason;
    rel.lastChange = changes;
    rel.lastChangeTime = nowMs();
    
    if (CFG.DEBUG) console.log(`Relationship with ${character}:`, rel, `(${reason})`);
    
    // Play audio feedback
    ensureAudioInit();
    const totalChange = Object.values(changes).reduce((sum, val) => sum + val, 0);
    if (totalChange > 5) SFX.success();
    else if (totalChange < -5) SFX.error();
    else SFX.click();
  }
  
  function getRelationshipLevel(character, stat) {
    const value = RELATIONSHIPS[character]?.[stat] || 50;
    if (value >= 80) return 'excellent';
    if (value >= 60) return 'good';
    if (value >= 40) return 'neutral';
    if (value >= 20) return 'poor';
    return 'terrible';
  }
  
  function getRelationshipEmoji(character) {
    const rel = RELATIONSHIPS[character];
    if (!rel) return 'üòê';
    
    const avg = (rel.respect + rel.trust - rel.fear) / 3;
    if (avg >= 70) return 'üòç'; // Love
    if (avg >= 50) return 'üòä'; // Like
    if (avg >= 30) return 'üòê'; // Neutral
    if (avg >= 10) return 'üò†'; // Dislike
    return 'ü§¨'; // Hate
  }
  
  // Enhanced drawing state
  let isDrawing = false;
  let lastDrawPoint = null;
  const drawingSettings = {
    smoothingDistance: 15, // Minimum distance between points
    maxDrawingSpeed: 1000, // Max pixels per second
    showPreview: true
  };
  
  // ---------- Audio System ----------
  const AUDIO = {
    enabled: true,
    masterVolume: 0.7,
    sounds: {},
    music: null,
    currentTrack: null
  };
  
  // Web Audio API context for better sound control
  let audioContext = null;
  
  function initAudio() {
    try {
      audioContext = new (window.AudioContext || window.webkitAudioContext)();
      if (CFG.DEBUG) console.log('Audio system initialized');
    } catch (e) {
      console.warn('Audio not supported:', e);
      AUDIO.enabled = false;
    }
  }
  
  function playSound(frequency, duration, type = 'sine', volume = 0.3) {
    if (!AUDIO.enabled || !audioContext) return;
    
    try {
      const oscillator = audioContext.createOscillator();
      const gainNode = audioContext.createGain();
      
      oscillator.connect(gainNode);
      gainNode.connect(audioContext.destination);
      
      oscillator.frequency.value = frequency;
      oscillator.type = type;
      
      gainNode.gain.value = volume * AUDIO.masterVolume;
      gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
      
      oscillator.start();
      oscillator.stop(audioContext.currentTime + duration);
    } catch (e) {
      console.warn('Sound play failed:', e);
    }
  }
  
  function playChord(frequencies, duration, volume = 0.2) {
    frequencies.forEach((freq, i) => {
      setTimeout(() => playSound(freq, duration, 'sine', volume), i * 50);
    });
  }
  
  // Sound effect library
  const SFX = {
    click: () => playSound(800, 0.1, 'square', 0.2),
    buttonPress: () => playSound(600, 0.15, 'square', 0.3),
    success: () => playChord([523, 659, 784], 0.5, 0.25), // C-E-G
    error: () => playSound(200, 0.3, 'sawtooth', 0.3),
    helicopter: () => {
      // Simulate rotor sound with multiple tones
      for(let i = 0; i < 10; i++) {
        setTimeout(() => playSound(100 + Math.random()*50, 0.1, 'sawtooth', 0.15), i * 50);
      }
    },
    explosion: () => {
      playSound(60, 0.5, 'sawtooth', 0.4);
      setTimeout(() => playSound(40, 0.8, 'square', 0.3), 100);
    },
    whoosh: () => {
      for(let i = 0; i < 5; i++) {
        setTimeout(() => playSound(400 - i*50, 0.1, 'sine', 0.2), i * 30);
      }
    },
    achievement: () => playChord([523, 659, 784, 1047], 0.8, 0.3), // Victory fanfare
    tweet: () => {
      // Twitter notification sound
      playSound(1000, 0.1, 'sine', 0.15);
      setTimeout(() => playSound(1200, 0.1, 'sine', 0.12), 120);
    },
    heartbeat: () => {
      playSound(80, 0.1, 'sine', 0.4);
      setTimeout(() => playSound(80, 0.1, 'sine', 0.4), 150);
    }
  };
  
  // Initialize audio on first user interaction
  let audioInitialized = false;
  function ensureAudioInit() {
    if (!audioInitialized && audioContext?.state === 'suspended') {
      audioContext.resume();
      audioInitialized = true;
    }
  }

  // ---------- Intro Screen ----------
  function initIntro() {
    introStartTime = nowMs();
    const introCanvas = document.getElementById('intro-canvas');
    if (introCanvas) {
      // Ensure canvas is properly sized
      const rect = introCanvas.getBoundingClientRect();
      introCanvas.width = 600;
      introCanvas.height = 400;
      const ictx = introCanvas.getContext('2d');
      if (CFG.DEBUG) console.log('Drawing intro graphics on canvas', introCanvas.width, 'x', introCanvas.height);
      // Enable image smoothing for pixel art
      ictx.imageSmoothingEnabled = false;
      drawIntroGraphics(ictx, introCanvas.width, introCanvas.height);
    } else {
      if (CFG.DEBUG) console.log('Intro canvas not found!');
    }
  }
  
  function drawIntroGraphics(ctx, w, h) {
    // Clear canvas first
    ctx.clearRect(0, 0, w, h);
    
    // White background behind helicopter and Trump
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0, 0, w, h);
    
    // Draw simple helicopter and Trump using basic shapes - safer approach
    drawIntroHeli(ctx, w/2, h/2 + 20);
    drawIntroTrump(ctx, w/2 + 60, h/2 + 40);
  }
  
  function drawIntroHeli(ctx, x, y) {
    ctx.save();
    ctx.translate(x, y);
    
    // Helicopter body
    ctx.fillStyle = '#2c3e50';
    ctx.fillRect(-60, -15, 150, 42);
    
    // Cockpit
    ctx.fillStyle = '#86d0ff';
    ctx.fillRect(69, -9, 15, 24);
    
    // Main rotor shaft
    ctx.fillStyle = '#333';
    ctx.fillRect(9, -27, 6, 12);
    
    // Main rotor blades
    ctx.fillStyle = '#333';
    ctx.fillRect(-60, -33, 210, 6);
    
    // Rotor blur effect
    ctx.globalAlpha = 0.3;
    ctx.fillStyle = '#000';
    ctx.fillRect(-90, -34, 270, 9);
    ctx.globalAlpha = 1;
    
    // Landing skids
    ctx.fillStyle = '#333';
    ctx.fillRect(-45, 27, 90, 6);
    ctx.fillRect(30, 27, 60, 6);
    
    ctx.restore();
  }
  
  function drawIntroTrump(ctx, x, y) {
    ctx.save();
    ctx.translate(x, y);
    
    // Trump figure (simplified)
    // Suit
    ctx.fillStyle = '#2b2b2b';
    ctx.fillRect(-15, 15, 30, 60);
    
    // Shirt
    ctx.fillStyle = '#d8e6ff';
    ctx.fillRect(-12, 18, 24, 36);
    
    // Tie
    ctx.fillStyle = '#e02424';
    ctx.fillRect(-3, 24, 6, 28);
    
    // Head/face
    ctx.fillStyle = '#ffaa66';
    ctx.fillRect(-15, -15, 30, 30);
    
    // Hair
    ctx.fillStyle = '#ffdd44';
    ctx.fillRect(-18, -24, 36, 15);
    
    // Eyes
    ctx.fillStyle = '#111';
    ctx.fillRect(-9, -3, 3, 3);
    ctx.fillRect(6, -3, 3, 3);
    
    // Mouth
    ctx.fillStyle = '#c2185b';
    ctx.fillRect(-6, 6, 12, 3);
    
    ctx.restore();
  }
  
  function drawPixelMissile(ctx, x, y, scale) {
    ctx.save();
    ctx.translate(x, y);
    ctx.scale(scale, scale);
    
    // Missile body (gray)
    ctx.fillStyle = '#666';
    ctx.fillRect(-8, -60, 16, 60);
    
    // Missile nose (dark gray)  
    ctx.fillStyle = '#444';
    ctx.fillRect(-6, -70, 12, 10);
    ctx.fillRect(-4, -80, 8, 10);
    ctx.fillRect(-2, -85, 4, 5);
    
    // Fins
    ctx.fillStyle = '#555';
    ctx.fillRect(-12, -20, 8, 12);
    ctx.fillRect(4, -20, 8, 12);
    
    // Nuclear symbol (yellow)
    ctx.fillStyle = '#ffff00';
    ctx.fillRect(-6, -40, 12, 2);
    ctx.fillRect(-1, -45, 2, 12);
    ctx.fillRect(-4, -42, 2, 2);
    ctx.fillRect(2, -42, 2, 2);
    ctx.fillRect(-4, -36, 2, 2);
    ctx.fillRect(2, -36, 2, 2);
    
    // Flames (animated)
    const t = (nowMs() / 100) % 4;
    const flameColors = ['#ff4400', '#ff8800', '#ffaa00'];
    for(let i = 0; i < 3; i++) {
      ctx.fillStyle = flameColors[i];
      const offset = Math.floor(t + i) % 3;
      ctx.fillRect(-6 + i*4, 0, 4, 8 + offset*2);
    }
    
    ctx.restore();
  }
  
  function drawPixelDonald(ctx, x, y, scale) {
    ctx.save();
    ctx.translate(x, y);
    ctx.scale(scale, scale);
    
    // Face (orange/tan)
    ctx.fillStyle = '#ffaa66';
    ctx.fillRect(-12, -16, 24, 20);
    ctx.fillRect(-10, -18, 20, 2);
    ctx.fillRect(-8, -20, 16, 2);
    
    // Hair (yellow/blonde)
    ctx.fillStyle = '#ffdd44';
    ctx.fillRect(-14, -22, 20, 8);
    ctx.fillRect(-16, -20, 4, 6);
    ctx.fillRect(8, -24, 8, 4);
    
    // Eyes (white with blue)
    ctx.fillStyle = '#fff';
    ctx.fillRect(-8, -12, 4, 3);
    ctx.fillRect(4, -12, 4, 3);
    ctx.fillStyle = '#0066ff';
    ctx.fillRect(-7, -11, 2, 2);
    ctx.fillRect(5, -11, 2, 2);
    
    // Eyebrows (darker)
    ctx.fillStyle = '#cc8844';
    ctx.fillRect(-9, -14, 5, 1);
    ctx.fillRect(4, -14, 5, 1);
    
    // Nose (slightly darker)
    ctx.fillStyle = '#ee9955';
    ctx.fillRect(-1, -8, 2, 3);
    
    // Mouth (dark)
    ctx.fillStyle = '#442222';
    ctx.fillRect(-4, -4, 8, 2);
    
    // Suit collar (dark blue)
    ctx.fillStyle = '#003366';
    ctx.fillRect(-14, 4, 28, 8);
    
    // Tie (red)
    ctx.fillStyle = '#cc0000';
    ctx.fillRect(-2, 2, 4, 10);
    
    ctx.restore();
  }
  
  // Doom bar rendering
  const doombarEl = document.getElementById('doombar');
  function renderDoombar(){
    if (!doombarEl) return;
    const doomPercent = Math.round(GS.doom);
    let statusText = 'üåç Verdensfred';
    let statusColor = '#1e5631';
    
    const T = GAME_CONSTANTS.GAME.UI_THRESHOLDS;
    if (doomPercent >= T.CRITICAL) {
      statusText = '‚ò¢Ô∏è Dommedag n√¶r!';
      statusColor = '#8b0000';
    } else if (doomPercent >= T.WAR) {
      statusText = '‚ö†Ô∏è Fare for krig';
      statusColor = '#cc6600';
    } else if (doomPercent >= T.TENSION) {
      statusText = 'üò∞ Sp√¶ndinger';
      statusColor = '#996600';
    }
    
    try { doombarEl.setAttribute('aria-live','polite'); } catch(_){}
    doombarEl.innerHTML = `
      <span>${statusText}</span>
      <div role="progressbar" aria-label="Dommedagsniveau" aria-valuemin="0" aria-valuemax="100" aria-valuenow="${doomPercent}" class="doombar-progress">
        <span class="doombar-fill" style="width: ${doomPercent}%; background: ${doomPercent > T.CRITICAL ? '#ff4444' : doomPercent > T.WAR ? '#ff8800' : '#c62828'}"></span>
      </div>
      <span style="font-size: 11px; opacity: 0.9">${doomPercent}%</span>
    `;
  }
  renderDoombar(); // Initial render
  
  // Initialize intro screen
  initIntro();
  
  // Initialize audio system
  initAudio();
  
  // Unified start function to avoid duplication
  function startGame(){
    const introEl = document.getElementById('intro');
    if (introEl) introEl.style.display = 'none';
    scene = 'greenland';
    resetGreenland();
    scheduleHeliIntro('Perfect landing! Welcome to Greenland!');
  }

  // Add click handlers to intro UI
  const introEl = document.getElementById('intro');
  if (introEl) {
    introEl.addEventListener('click', e => {
      if (scene === 'intro') startGame();
    });
  }
  const startBtn = document.getElementById('start-btn');
  if (startBtn) {
    startBtn.addEventListener('click', e => { e.stopPropagation(); startGame(); });
    startBtn.addEventListener('keydown', e => { if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); startGame(); } });
  }

  function addSafe(sceneKey,id){ const S = sceneKey==='greenland'?GL:sceneKey==='oval'?OV:sceneKey==='kremlin'?KR:EP; if (!S._safe) S._safe=new Set(); if (S._safe.has(id)) return; S._safe.add(id); GS.cleared[sceneKey]++; renderAreas2(); }
  function bumpDoom(amount, reason){ GS.doom = Math.max(0, Math.min(100, GS.doom + amount)); hudToast = reason||null; renderDoombar(); if (GS.doom>=100) checkWin(); }
  function gameOver(text){ 
    GS.over=true; 
    GS.overText=text;
    SFX.achievement();
  }
  
  function determineEnding() {
    const cleared = Object.values(GS.cleared).filter(v=>v>=GS.needPerArea).length;
    const metteRel = RELATIONSHIPS.mette;
    const putinRel = RELATIONSHIPS.putin;
    const totalInventory = inventory.length;
    
    // Calculate relationship averages
    const metteAvg = (metteRel.respect + metteRel.trust - metteRel.fear) / 3;
    const putinAvg = (putinRel.respect + putinRel.trust - putinRel.fear) / 3;
    
    // Check for achievements
    if (metteAvg >= 70 && putinAvg >= 70) GS.achievements.perfectDiplomat = true;
    if (GS.timeLeftMs > 4*60*1000) GS.achievements.speedRunner = true;
    if (totalInventory >= 10) GS.achievements.collector = true;
    if (GS.doom === 0) GS.achievements.peacemaker = true;
    if (tweetCount >= 5) GS.achievements.twitterAddict = true;
    
    // Count achievements for ending bonuses
    const achievementCount = Object.values(GS.achievements).filter(Boolean).length;
    
    // Multiple ending scenarios
    if (GS.doom >= 100) {
      return 'Du har lige √∏delagt hele verden\nTotal destruction achieved.'; // World destruction ending
    }
    
    if (cleared >= 3) {
      // Perfect completion endings
      if (GS.achievements.perfectDiplomat && GS.achievements.speedRunner) {
        return 'LEGENDARY PRESIDENT!\nüèÜ Perfect diplomacy in record time!\nüåç World peace AND Greenland secured!\n‚ö° HISTORIC ACHIEVEMENT ‚ö°';
      } else if (GS.achievements.perfectDiplomat) {
        return 'DIPLOMATIC MASTERPIECE!\nü§ù Greenland acquired through mutual respect.\n‚òÆÔ∏è World peace achieved!\nüéñÔ∏è Perfect Diplomat';
      } else if (achievementCount >= 3) {
        return 'TREMENDOUS SUCCESS!\nüéØ Greenland deal complete!\nüèÖ Multiple achievements unlocked!\n‚≠ê The Art of Excellence!';
      } else if (metteAvg >= 60 || putinAvg >= 60) {
        return 'TREMENDOUS SUCCESS!\nü§ù Greenland deal complete.\nüí™ Strong relationships forged!';
      } else {
        return 'DEAL CLOSED!\nüè¢ Greenland acquired through determination.\nüìò The Art of the Deal!';
      }
    } else if (cleared >= 2) {
      // Standard success endings
      if (GS.achievements.speedRunner && GS.achievements.peacemaker) {
        return 'SWIFT & PEACEFUL VICTORY!\n‚ö° Lightning-fast diplomacy!\n‚òÆÔ∏è No conflict, all solutions!\nüéä Tremendous efficiency!';
      } else if (GS.achievements.collector) {
        return 'COLLECTOR\'S TRIUMPH!\nüóÉÔ∏è Strategic resource mastery!\nüíé Tremendous acquisitions!\nüè™ Ultimate dealmaker!';
      } else if (metteAvg >= 50 && putinAvg >= 50) {
        return 'DIPLOMATIC VICTORY!\n‚öñÔ∏è Survived with honor intact.\nü§ù All relationships preserved!';
      } else {
        return 'You survived the day!\nüí™ A hard-fought victory.';
      }
    } else if (cleared >= 1) {
      // Partial success endings  
      if (GS.achievements.twitterAddict) {
        return 'SOCIAL MEDIA PRESIDENT!\nüì± Twitter mastery achieved!\nüì¢ Message delivered worldwide!\n‚ö†Ô∏è Minimal other progress...';
      } else if (metteAvg <= 20 && putinAvg <= 20) {
        return 'BRIDGES BURNED!\nüî• Survived, but diplomatic disaster.\nüòû Very sad relationships.\nüíî Tremendous damage done.';
      } else {
        return 'NARROW ESCAPE!\nüòÖ Minimal progress made.\nüìà Must try harder next time.';
      }
    } else {
      // Failure endings
      if (GS.timeLeftMs <= 0) {
        return 'TIME\'S UP!\n‚è∞ Ran out of time.\nüò§ Not enough winning today.\n‚åõ Poor time management!';
      } else {
        return 'TOTAL FAILURE!\n‚ùå No progress made anywhere.\nüòû Very disappointing performance!\nüö´ Sad!';
      }
    }
  }
  
  function checkWin(){ 
    const endingText = determineEnding();
    gameOver(endingText);
  }

  function spriteShadow(x,y,w=40,h=10,a=0.2){ ctx.save(); ctx.globalAlpha=a; ctx.fillStyle='#000'; ctx.beginPath(); ctx.ellipse(x,y,w,h,0,0,Math.PI*2); ctx.fill(); ctx.restore(); }
  function roundRect(x,y,w,h,r){ ctx.beginPath(); ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath(); }
  // Colored speech bubbles by speaker: 'trump' | 'mette' | 'bear' | 'aide' | 'default'
  function textBubble(text,x,y,right=false, speaker='default', yOffset=0){
    const pad = GAME_CONSTANTS.UI.BUBBLE_PADDING; 
    ctx.font=`${GAME_CONSTANTS.UI.BUBBLE_FONT_SIZE*CFG.SCALE}px/1.2 system-ui`;
    const lines = String(text).split('\n');
    const lineH = GAME_CONSTANTS.UI.BUBBLE_LINE_HEIGHT*CFG.SCALE;
    const w = Math.max(80, Math.max(...lines.map(ln=>ctx.measureText(ln).width)) + pad*2);
    const h = (lines.length*lineH + 8);
    const bx = right? x - w - GAME_CONSTANTS.UI.BUBBLE_TAIL_OFFSET : x + GAME_CONSTANTS.UI.BUBBLE_TAIL_OFFSET, 
          by = y - GAME_CONSTANTS.UI.BUBBLE_Y_OFFSET*CFG.SCALE + yOffset;
    // palette
    const palettes = {
      trump:  { fill:'rgba(255,165,0,.85)', stroke:'rgba(60,40,0,.9)', text:'#111', tail:'#ffbf47' },
      mette:  { fill:'rgba(90,60,140,.85)', stroke:'rgba(220,205,255,.9)', text:'#fff', tail:'rgba(90,60,140,.85)' },
      bear:   { fill:'rgba(240,240,240,.85)', stroke:'rgba(50,50,50,.7)', text:'#111', tail:'rgba(240,240,240,.85)' },
      aide:   { fill:'rgba(40,80,140,.85)',  stroke:'rgba(220,230,255,.9)', text:'#fff', tail:'rgba(40,80,140,.85)' },
      default:{ fill:'rgba(0,0,0,.7)',        stroke:'rgba(255,255,255,.85)', text:'#fff', tail:'rgba(0,0,0,.7)' }
    };
    const pal = palettes[speaker] || palettes.default;
    ctx.fillStyle=pal.fill; ctx.strokeStyle=pal.stroke;
    roundRect(bx,by,w,h,8); ctx.fill(); ctx.stroke();
    ctx.fillStyle=pal.text; lines.forEach((ln,i)=>ctx.fillText(ln, bx+pad, by+lineH*(i+0.7)));
    ctx.beginPath();
    ctx.fillStyle=pal.tail;
    if (right){ ctx.moveTo(x-10,y-GAME_CONSTANTS.UI.BUBBLE_TAIL_Y*CFG.SCALE); ctx.lineTo(bx+w-6,by+h/2-4); ctx.lineTo(bx+w-6,by+h/2+4); }
    else { ctx.moveTo(x+10,y-GAME_CONSTANTS.UI.BUBBLE_TAIL_Y*CFG.SCALE); ctx.lineTo(bx+6,by+h/2-4); ctx.lineTo(bx+6,by+h/2+4); }
    ctx.closePath(); ctx.fill();
  }

  // Helper: place bubble to avoid overlap with previously placed bubbles
  function placeBubble(text, x, y, right, placedRects){
    ctx.font=`${12*CFG.SCALE}px/1.2 system-ui`;
    const pad=8;
    const w = Math.max(80, ctx.measureText(text).width + pad*2);
    const h = 22*CFG.SCALE;
    const bx = right? x - w - 18 : x + 18;
    let by = y - 46*CFG.SCALE;
    const spacing = 8*CFG.SCALE;
    let tries = 0;
    function overlaps(r1, r2){ return !(r1.x + r1.w < r2.x || r2.x + r2.w < r1.x || r1.y + r1.h < r2.y || r2.y + r2.h < r1.y); }
    let rect = {x:bx, y:by, w, h};
    while (placedRects.some(r => overlaps(rect, r)) && tries < 10){
      by -= (h + spacing);
      rect = {x:bx, y:by, w, h};
      tries++;
    }
    placedRects.push(rect);
    const base = y - 46*CFG.SCALE;
    return by - base; // yOffset for textBubble
  }

  // ---------- Spiller ----------
  const player = { x: 240, y: 0, w: 26, h: 44, facing: 1, speakingUntil: 0, say: '', speedMul:1, tanLevel:0, capOn:false, nextBlink:0, blinkUntil:0, nodPhase:Math.random()*6.28, walkCycle:0, lastX:240, walking:false, selectedItem:null };
  
  // Interaction feedback system
  const interactions = new Map(); // Store active interaction effects
  
  function addInteractionFeedback(obj, type='press') {
    const key = obj.type + '_' + (obj.x || 0) + '_' + (obj.y || 0);
    interactions.set(key, {
      obj: obj,
      type: type,
      start: nowMs(),
      duration: type === 'press' ? 200 : 300
    });
  }
  
  function getInteractionOffset(obj) {
    const key = obj.type + '_' + (obj.x || 0) + '_' + (obj.y || 0);
    const interaction = interactions.get(key);
    if (!interaction) return { x: 0, y: 0 };
    
    const elapsed = nowMs() - interaction.start;
    if (elapsed > interaction.duration) {
      interactions.delete(key);
      return { x: 0, y: 0 };
    }
    
    const progress = elapsed / interaction.duration;
    if (interaction.type === 'press') {
      const pushDown = Math.sin(progress * Math.PI) * 3 * CFG.SCALE;
      return { x: 0, y: pushDown };
    }
    return { x: 0, y: 0 };
  }
  let phoneBlinkUntil = 0;
  let speedBoostUntil = 0;
  let introPlayed = false, introRunning = false;
  const entryHeli = { active:false, x:0, y:0, start:0, dur:1600, targetX:0, startY:0, targetY:0, vertical:true, line:'' };
  function say(who, txt, ms){ who.speakingUntil = nowMs() + (ms||CFG.BUBBLE_TIME); who.say = txt; }

  // ---------- Inventar ----------
  const invEl = document.getElementById('inv');
  const ITEM_META = {
    tan:  { id:'tan',  name:'Selvbruner', stats:{ karisma:+2, visdom:-1, stil:+1 } },
    cl:   { id:'cl',   name:'CL-pokal',   stats:{ pral:+10, ydmyghed:-3 } },
    maga: { id:'maga', name:'MAGA-cap',   stats:{ karisma:+5, visdom:-5 } },
    dynamite: { id:'dynamite', name:'Dynamit', stats:{ destruction:+999 } }
  };
  const MAX_SLOTS = 6;
  const inventory = []; // [{id,name,stats}]
  let collectedCoins = 0; // Global coin counter
  function addToInventory(id,name){
    if (inventory.find(i=>i.id===id)) return;
    const meta = ITEM_META[id] || {id,name,stats:null};
    inventory.push({id:meta.id, name:meta.name||name, stats:meta.stats||null});
    renderInv();
  }
  // small icons for inventory
  function drawInvIcon(ctx, id){
    ctx.save();
    ctx.translate(19,14); // center-ish for 38x24 canvas
    ctx.scale(0.8,0.8);
    if (id==='tan'){ ctx.fillStyle='#8b5e3c'; ctx.fillRect(-8,6,16,10); ctx.fillStyle='#bbb'; ctx.fillRect(-6,2,12,4); ctx.fillStyle='#ddd'; ctx.fillRect(-2,-2,4,4); }
    else if (id==='cl'){ ctx.fillStyle='#c0c8ff'; ctx.fillRect(-10,0,20,16); ctx.fillStyle='#ffd700'; ctx.fillRect(-6,-2,12,4); ctx.fillStyle='#b0b8ff'; ctx.fillRect(-8,2,16,2); }
    else if (id==='maga'){ ctx.fillStyle='#c22'; ctx.fillRect(-12,6,24,8); ctx.fillRect(-10,0,20,6); ctx.fillStyle='#a00'; ctx.fillRect(2,2,4,2); }
    else if (id==='dynamite'){ 
      // Two narrow red sticks side by side with black bands
      ctx.fillStyle='#d32f2f'; ctx.fillRect(-8,0,6,16); // left stick
      ctx.fillStyle='#d32f2f'; ctx.fillRect(2,0,6,16); // right stick
      ctx.fillStyle='#333'; ctx.fillRect(-8,4,6,2); // left black band
      ctx.fillStyle='#333'; ctx.fillRect(2,4,6,2); // right black band
      ctx.fillStyle='#333'; ctx.fillRect(-8,10,6,2); // left bottom band
      ctx.fillStyle='#333'; ctx.fillRect(2,10,6,2); // right bottom band
    }
    else if (id && id.startsWith('stat')){ ctx.fillStyle='#d4af37'; ctx.fillRect(-6,-2,12,12); ctx.fillStyle='#8a6b2f'; ctx.fillRect(-8,10,16,4); }
    else { ctx.fillStyle='#999'; ctx.fillRect(-8,2,16,12); }
    ctx.restore();
  }
  function renderInv(){
    invEl.innerHTML='';
    // desired slot order: known item types first, then extras, then placeholders to MAX_SLOTS
    const slotIds = Object.keys(ITEM_META);
    let rendered = 0;
    // render fixed placeholders or filled slots for known items
    slotIds.forEach(id => {
      const item = inventory.find(it=>it.id===id) || null;
      const isSelected = player.selectedItem === id;
      const d=document.createElement('div'); 
      d.className='slot' + (item? '' : ' empty');
      // Add selected highlight
      if (isSelected) {
        d.style.border = '2px solid #ffff00';
        d.style.backgroundColor = 'rgba(255,255,0,0.2)';
        d.style.boxShadow = '0 0 10px rgba(255,255,0,0.5)';
      }
      const c=document.createElement('canvas'); c.className='slotcvs';
      // draw all text inside the canvas for reliability
      const pxW = 62, pxH = 50, DPRui = Math.max(1, Math.floor((window.devicePixelRatio||1)));
      c.width = pxW*DPRui; c.height = pxH*DPRui; c.style.width=pxW+'px'; c.style.height=pxH+'px';
      d.appendChild(c); invEl.appendChild(d);
      const ictx=c.getContext('2d');
      ictx.setTransform(DPRui,0,0,DPRui,0,0);
      paintSlot(ictx, item);
      rendered++;
    });
    // render any extra, unknown items after the fixed slots
    inventory.filter(it=>!ITEM_META[it.id]).forEach(it => {
      const d=document.createElement('div'); d.className='slot';
      const c=document.createElement('canvas'); c.className='slotcvs';
      const pxW = 62, pxH = 50, DPRui = Math.max(1, Math.floor((window.devicePixelRatio||1)));
      c.width = pxW*DPRui; c.height = pxH*DPRui; c.style.width=pxW+'px'; c.style.height=pxH+'px';
      d.appendChild(c); invEl.appendChild(d);
      const ictx=c.getContext('2d'); ictx.setTransform(DPRui,0,0,DPRui,0,0); paintSlot(ictx, it);
      rendered++;
    });
    // fill remaining placeholders to MAX_SLOTS
    while (rendered < MAX_SLOTS){
      const d=document.createElement('div'); d.className='slot empty';
      const c=document.createElement('canvas'); c.className='slotcvs';
      const pxW = 62, pxH = 50, DPRui = Math.max(1, Math.floor((window.devicePixelRatio||1)));
      c.width = pxW*DPRui; c.height = pxH*DPRui; c.style.width=pxW+'px'; c.style.height=pxH+'px';
      d.appendChild(c); invEl.appendChild(d);
      const ictx=c.getContext('2d'); ictx.setTransform(DPRui,0,0,DPRui,0,0); paintSlot(ictx, null);
      invEl.appendChild(d);
      rendered++;
    }
  }
  function paintSlot(g, item){
    // background glass
    g.fillStyle='rgba(255,255,255,.08)'; g.fillRect(0,0,62,50);
    // icon
    g.save(); g.translate(31,10); g.scale(0.6,0.6);
    if (item) {
      // reuse icon shapes
      if (item.id==='tan'){ g.fillStyle='#8b5e3c'; g.fillRect(-8,6,16,10); g.fillStyle='#bbb'; g.fillRect(-6,2,12,4); g.fillStyle='#ddd'; g.fillRect(-2,-2,4,4); }
      else if (item.id==='cl'){ g.fillStyle='#c0c8ff'; g.fillRect(-10,0,20,16); g.fillStyle='#ffd700'; g.fillRect(-6,-2,12,4); g.fillStyle='#b0b8ff'; g.fillRect(-8,2,16,2); }
      else if (item.id==='maga'){ g.fillStyle='#c22'; g.fillRect(-12,6,24,8); g.fillRect(-10,0,20,6); g.fillStyle='#a00'; g.fillRect(2,2,4,2); }
      else { g.fillStyle='#999'; g.fillRect(-8,2,16,12); }
    } else {
      g.globalAlpha=.6; g.fillStyle='#bbb'; g.fillRect(-10,2,20,12); g.globalAlpha=1;
    }
    g.restore();
    // text lines
    g.fillStyle='#fff'; g.font='bold 9px system-ui'; g.textAlign='center';
    const name = item ? (item.name + (isEquipped(item.id)? ' ‚úì':'')) : 'Tom';
    g.fillText(name, 31, 30);
    // stats split across two lines
    const statsFull = item && item.stats ? statString(item.stats) : '‚Äî';
    const parts = statsFull.split(/\s+/);
    const mid = Math.ceil(parts.length/2);
    const line1 = parts.slice(0, mid).join(' ');
    const line2 = parts.slice(mid).join(' ');
    g.font='8px system-ui'; g.globalAlpha=.95; g.fillText(line1,31,38);
    if (line2){ g.globalAlpha=.9; g.font='7px system-ui'; g.fillText(line2,31,46); }
    g.globalAlpha=1; g.textAlign='left';
    g.globalAlpha=1; g.textAlign='left';
  }
  function statString(stats){
    return Object.entries(stats).map(([k,v])=> (v>=0? '+'+v : v)+' '+k).join(' ');
  }
  function toggleInventory(){ invEl.classList.toggle('hidden'); }

  // equipped flags
  function isEquipped(id){
    if (id==='cl') return (player.speedMul||1) > 1.01;
    if (id==='tan') return (player.tanLevel||0) > 0;
    if (id==='maga') return !!player.capOn;
    return false;
  }

  // ---------- HUD ----------
  const hudEl = document.getElementById('hud');
  let hudToast = null;
  function renderHUD(){
    if (!hudEl) return;
    hudEl.innerHTML = '';
    // Timer
    addChip('‚è∞ '+fmtTime(GS.timeLeftMs));
    // Gold bar counter with custom icon
    const totalCoins = GL.coins.length + OV.coins.length + KR.coins.length;
    addGoldBarChip(collectedCoins, totalCoins);
    // Cap icon
    if (player.capOn) addChip('üß¢');
    // Speed timer chip
    const now = nowMs();
    if (speedBoostUntil > now){ const rem = Math.max(0, Math.ceil((speedBoostUntil - now)/1000)); addChip('Tempo '+rem+'s'); }
  }
  function addChip(text){ const s=document.createElement('span'); s.className='chip'; s.textContent=text; hudEl.appendChild(s); }
  
  function drawGoldBarHUDIcon(canvasEl, x, y) {
    const ctx = canvasEl.getContext('2d');
    ctx.save();
    ctx.translate(x, y);
    
    // HUD-sized gold bar with "GOLD" text (larger than in-game version)
    // Bottom/side shadow (darker gold)
    ctx.fillStyle='#cc9900';
    ctx.fillRect(0, 4, 24, 12); // bottom part
    ctx.fillRect(20, 2, 4, 10); // right side edge
    
    // Main body (bright gold)
    ctx.fillStyle='#ffd700';
    ctx.fillRect(0, 2, 20, 10);
    
    // Top surface highlight (lighter gold)
    ctx.fillStyle='#ffed4e';
    ctx.fillRect(0, 2, 20, 5); // top surface
    ctx.fillRect(0, 0, 3, 3);  // left edge highlight
    
    // "GOLD" text embossed on HUD icon
    ctx.fillStyle='#b8860b'; // darker gold for text
    ctx.font='bold 8px system-ui';
    ctx.textAlign='center';
    ctx.fillText('GOLD', 10, 8);
    ctx.textAlign='left';
    
    ctx.restore();
  }
  
  function addGoldBarChip(count, total) {
    const s = document.createElement('span');
    s.className = 'chip';
    s.style.display = 'inline-flex';
    s.style.alignItems = 'center';
    s.style.gap = '4px';
    
    // Create canvas for gold bar icon
    const iconCanvas = document.createElement('canvas');
    iconCanvas.width = 24;
    iconCanvas.height = 14;
    iconCanvas.style.verticalAlign = 'middle';
    
    // Draw gold bar icon
    drawGoldBarHUDIcon(iconCanvas, 1, 1);
    
    s.appendChild(iconCanvas);
    s.appendChild(document.createTextNode(`${count}/${total}`));
    hudEl.appendChild(s);
  }

  // ---------- Scener ----------

  const GL = {
    state: { flagPlanted:false, bearGone:false, hasTweeted:false, glaciersBlown:false, hasSeenGlaciers:false },
    mine:  {x: 520, y: 0, w:36, h:24, type:'mine'},
    flag:  null,
    bear:  {x: 760, y: 0, w:70, h:40, type:'bear', alive:true, hp:2, speakingUntil:0, say:'', angry:false, chasing:false, speed:100, facing:1},
    mette: {x: 980, y: 0, w:26, h:44, type:'mette', speakingUntil:0, say:''},
    rig:   {x: 380, y: 0, w:30, h:40, type:'rig'},
    heli:  {x: 160, y: 0, w:120, h:42, type:'heli'},
    coins: [], // Mario-style collectible gold bars
    // Interactive glaciers in background
    glaciers: [
      {x: 120, y: 0, w:80, h:120, type:'glacier', blown:false},
      {x: 420, y: 0, w:100, h:140, type:'glacier', blown:false},
      {x: 800, y: 0, w:90, h:110, type:'glacier', blown:false}
    ],
    // pickups
    items: [
      {id:'tan',  name:ITEM_META.tan.name,  x:600, y:0, w:22, h:18, type:'pickup'},
      {id:'cl',   name:ITEM_META.cl.name,   x:680, y:0, w:22, h:26, type:'pickup'},
      {id:'maga', name:ITEM_META.maga.name, x:720, y:0, w:24, h:12, type:'pickup'},
      {id:'dynamite', name:ITEM_META.dynamite.name, x:500, y:0, w:20, h:16, type:'pickup'},
    ]
  };

  const OV = {
    door: {x: 140, y:0, w:40, h:80, type:'door'},
    aide: {x: 720, y:0, w:24, h:44, type:'aide', speakingUntil:0, say:''},
    heli: {x: 160, y:0, w:120, h:42, type:'heli'},
    yes:  {x: 980, y:0, w:26, h:44, type:'yes', speakingUntil:0, say:''},
    buttons: [], // desk buttons
    coins: [] // Mario-style collectible gold bars
  };

  // Kremlin scene (Putin meeting)
  const KR = {
    door: {x: 120, y:0, w:40, h:80, type:'door'},
    putin:{x: 680, y:0, w:24, h:44, type:'putin', speakingUntil:0, say:''},
    heli: {x: 160, y:0, w:120, h:42, type:'heli'},
    statues: [], // will be set in resetKremlin
    ukraineFlag: null, // 'american' or 'russian' - which flag is planted on Ukraine
    camera: {x: 0, y: 0, angle: 0, sweepStart: 0, discovered: false}, // security camera
    coins: [] // Mario-style collectible gold bars
  };

  // ---------- Epstein Files Scene ----------  
  const EP = {
    door: {x: 120, y:0, w:40, h:80, type:'door'},
    papers: [],
    currentLine: 0,
    scrollSpeed: 1.0,
    scrollY: 0,
    timeElapsed: 0,
    missedTrumps: 0,
    foundTrumps: 0,
    gameActive: false,
    gameStartTime: 0,
    trumpLocations: [], // {x,y,width,height,docIndex,lineInDoc,kind:'trump'|'protected'}
    generatedDocs: false,
    totalTrumpTargets: 20,
    missesAllowed: 2,
    failedByProtected: false,
    protectedClicks: 0,
    timeLimitMs: 20000,
    protectedNames: ['Bill Clinton','Bill Gates']
  };

  // ---------- Glacier explosion system ----------
  let glacierExplosion = {
    active: false,
    waterLevel: 0,
    explosions: [],
    iceChunks: []
  };

  function resetStateDefaults(){
    GL.state = { flagPlanted:false, bearGone:false, hasTweeted:false };
  }

  function resetGreenland(){
    const g = H - world.floor;
    player.x = GAME_CONSTANTS.WORLD.PLAYER_START_X*CFG.SCALE; player.y = g;
    Object.assign(GL.mine,  {x:GAME_CONSTANTS.WORLD.GREENLAND.MINE_X*CFG.SCALE, y:g});
    Object.assign(GL.rig,   {x:GAME_CONSTANTS.WORLD.GREENLAND.RIG_X*CFG.SCALE, y:g});
    Object.assign(GL.heli,  {x:GAME_CONSTANTS.WORLD.GREENLAND.HELI_X*CFG.SCALE, y:g-GAME_CONSTANTS.WORLD.HELI_Y_OFFSET*CFG.SCALE});
    Object.assign(GL.bear,  {x:GAME_CONSTANTS.WORLD.GREENLAND.BEAR_X*CFG.SCALE, y:g, alive:true, hp:2, speakingUntil:0, angry:false, chasing:false, speed:GAME_CONSTANTS.PHYSICS.BEAR_SPEED, facing:1});
    Object.assign(GL.mette, {x:GAME_CONSTANTS.WORLD.GREENLAND.METTE_X*CFG.SCALE, y:g, speakingUntil:0, nextBlink:0, blinkUntil:0, nodPhase:Math.random()*6.28});
    // pickups now start in inventory - mark all as collected
    GL.items.forEach(it => it.collected = true);
    GL.flag=null;
    // Reset glaciers - place them on ground level so Trump can interact
    GL.glaciers.forEach((glacier, i) => {
      const baseX = [120, 420, 800][i];
      glacier.x = baseX*CFG.SCALE; 
      glacier.y = g; // Place bottom on ground
      glacier.blown = false;
    });
    GL.state.glaciersBlown = false;
    GL.state.hasSeenGlaciers = false;
    // Initialize floating gold bars (require jumping to collect) - lowered to be reachable
    GL.coins = [
      {x:250*CFG.SCALE, y:g - 35*CFG.SCALE, collected:false, type:'coin'},
      {x:450*CFG.SCALE, y:g - 45*CFG.SCALE, collected:false, type:'coin'},
      {x:650*CFG.SCALE, y:g - 40*CFG.SCALE, collected:false, type:'coin'},
      {x:850*CFG.SCALE, y:g - 42*CFG.SCALE, collected:false, type:'coin'},
      {x:200*CFG.SCALE, y:g - 30*CFG.SCALE, collected:false, type:'coin'},
      {x:750*CFG.SCALE, y:g - 38*CFG.SCALE, collected:false, type:'coin'},
      {x:550*CFG.SCALE, y:g - 43*CFG.SCALE, collected:false, type:'coin'},
      {x:350*CFG.SCALE, y:g - 37*CFG.SCALE, collected:false, type:'coin'},
      {x:950*CFG.SCALE, y:g - 33*CFG.SCALE, collected:false, type:'coin'},
      {x:150*CFG.SCALE, y:g - 41*CFG.SCALE, collected:false, type:'coin'},
      // Bonus MAGA hat gold bars (require super jump)
      {x:400*CFG.SCALE, y:g - 60*CFG.SCALE, collected:false, type:'coin'},
      {x:800*CFG.SCALE, y:g - 65*CFG.SCALE, collected:false, type:'coin'}
    ];
    // Reset glacier explosion state
    glacierExplosion.active = false;
    glacierExplosion.waterLevel = 0;
    glacierExplosion.explosions = [];
    glacierExplosion.iceChunks = [];
    if (!introPlayed) scheduleHeliIntro('Touchdown in Greenland ‚Äî tremendous ice! Helicopter goes anywhere.');
    // init clouds
    CLOUDS = [];
    const n = 6; for (let i=0;i<n;i++){
      CLOUDS.push({ x: Math.random()*W, y: 40*CFG.SCALE + Math.random()*120*CFG.SCALE, w: 80*CFG.SCALE + Math.random()*100*CFG.SCALE, h: 24*CFG.SCALE, vx: (10+Math.random()*20)*CFG.SCALE, a: 0.15+Math.random()*0.1 });
    }
  }
  function resetOval(){
    const g = H - world.floor;
    player.x = 560*CFG.SCALE; player.y = g;
    Object.assign(OV.door,  {x:140*CFG.SCALE, y:g});
    Object.assign(OV.aide,  {x:720*CFG.SCALE, y:g, speakingUntil:0});
    Object.assign(OV.heli,  {x:160*CFG.SCALE, y:g-18*CFG.SCALE});
    Object.assign(OV.yes,   {x:980*CFG.SCALE, y:g, speakingUntil:0});
    // yes-men members state for blink/nod
    // Two women (index 0 and 2) and one man (index 1)
    OV.yes.members = [
      { nextBlink:0, blinkUntil:0, nodPhase:Math.random()*6.28, isF:true },
      { nextBlink:0, blinkUntil:0, nodPhase:Math.random()*6.28, isF:false },
      { nextBlink:0, blinkUntil:0, nodPhase:Math.random()*6.28, isF:true }
    ];
    // Initialize desk buttons positioned on desk top
    const deskTopY = H - world.floor + 30*CFG.SCALE - 36*CFG.SCALE; // from drawOvalDesk
    const deskLeft = 420*CFG.SCALE - 8*CFG.SCALE; const deskRight = deskLeft + (340*CFG.SCALE + 16*CFG.SCALE);
    const cols = 7; OV.buttons = [];
    const palette = ['#c62828','#1565c0','#2e7d32','#6a1b9a','#ef6c00','#00838f','#ad1457'];
    for (let i=0;i<cols;i++){
      const x = deskLeft + (i+0.7)*(deskRight-deskLeft)/(cols+0.5);
      const w = (20 + Math.random()*12)*CFG.SCALE; const h=(10+Math.random()*6)*CFG.SCALE;
      OV.buttons.push({x, y:deskTopY, w, h, color: palette[i%palette.length], type:'button', label: ''});
    }
    if (OV.buttons.length){
      const b0 = OV.buttons[0];
      b0.w *= 1.6; b0.h *= 1.4; b0.color = '#c62828'; b0.type='button'; // nuclear visually big red
    }
    // Initialize floating gold bars in Oval Office - lowered to be reachable
    OV.coins = [
      {x:300*CFG.SCALE, y:g - 40*CFG.SCALE, collected:false, type:'coin'},
      {x:500*CFG.SCALE, y:g - 45*CFG.SCALE, collected:false, type:'coin'},
      {x:700*CFG.SCALE, y:g - 35*CFG.SCALE, collected:false, type:'coin'},
      {x:900*CFG.SCALE, y:g - 43*CFG.SCALE, collected:false, type:'coin'},
      {x:400*CFG.SCALE, y:g - 38*CFG.SCALE, collected:false, type:'coin'},
      {x:800*CFG.SCALE, y:g - 42*CFG.SCALE, collected:false, type:'coin'},
      // Bonus MAGA hat gold bar (require super jump)
      {x:600*CFG.SCALE, y:g - 65*CFG.SCALE, collected:false, type:'coin'}
    ];
  }
  function resetKremlin(){
    const g = H - world.floor;
    player.x = 560*CFG.SCALE; player.y = g;
    Object.assign(KR.door,  {x:120*CFG.SCALE, y:g});
    Object.assign(KR.putin, {x: (W - 220*CFG.SCALE), y:g, speakingUntil:0, nextBlink:0, blinkUntil:0, nodPhase:Math.random()*6.28});
    Object.assign(KR.heli,  {x:160*CFG.SCALE, y:g-18*CFG.SCALE});
    // Initialize security camera
    Object.assign(KR.camera, {x: W/2, y: H/3, angle: Math.PI/4, sweepStart: nowMs(), discovered: false, flashUntil: 0});
    KR.statues = [
      {id:'stat1', name:'Guldstatue I', x:(420*CFG.SCALE), y:g, w:18, h:30, type:'statue', collected:false, variant:1},
      {id:'stat2', name:'Guldstatue II', x:(560*CFG.SCALE), y:g, w:18, h:30, type:'statue', collected:false, variant:2},
      {id:'stat3', name:'Guldstatue III', x:(700*CFG.SCALE), y:g, w:18, h:30, type:'statue', collected:false, variant:3}
    ];
    // Initialize floating gold bars in Kremlin - reduced to only 3 regular bars, lowered to be reachable
    KR.coins = [
      {x:400*CFG.SCALE, y:g - 40*CFG.SCALE, collected:false, type:'coin'}, // Near center/table
      {x:700*CFG.SCALE, y:g - 35*CFG.SCALE, collected:false, type:'coin'}, // Near Putin area
      {x:200*CFG.SCALE, y:g - 38*CFG.SCALE, collected:false, type:'coin'}, // Corner position
      // Bonus MAGA hat gold bar (require super jump)
      {x:500*CFG.SCALE, y:g - 65*CFG.SCALE, collected:false, type:'coin'}  // High above table
    ];
  }
  
  // ---------- Epstein Scene Functions ----------
  const DUMMY_NAMES = [
    'John Anderson', 'Sarah Mitchell', 'Robert Johnson', 'Emily Davis', 'Michael Brown',
    'Jessica Wilson', 'David Martinez', 'Ashley Taylor', 'Christopher Lee', 'Amanda White',
    'James Thompson', 'Nicole Garcia', 'Daniel Rodriguez', 'Melissa Clark', 'Matthew Lopez',
    'Stephanie Hill', 'Kevin Green', 'Lauren Adams', 'Brian Baker', 'Christina Nelson',
    'Ryan Carter', 'Megan Phillips', 'Justin Turner', 'Rachel Collins', 'Tyler Evans',
    'Samantha Stewart', 'Brandon Morris', 'Victoria Reed', 'Jonathan Cook', 'Heather Bell',
    'Nicholas Wright', 'Courtney Murphy', 'Aaron Rivera', 'Danielle Cooper', 'Jeremy King'
  ];
  
  const DOC_TEMPLATES = [
    "Meeting scheduled with {name} on Tuesday at 3:00 PM regarding the Atlantic City project.",
    "{name} called to discuss the upcoming real estate acquisition in Manhattan.",
    "Confidential: {name} was present at the Mar-a-Lago dinner party on November 15th.",
    "Flight manifests show {name} traveled to Nassau on private aircraft N218DT.",
    "{name} contacted the office requesting a private meeting with senior leadership.",
    "Internal memo: {name} has been cleared for access to the VIP guest list.",
    "Phone records indicate multiple calls between {name} and the executive office.",
    "{name} was photographed at the charity gala fundraiser at Trump International.",
    "Security clearance approved for {name} - access level: Executive Floor only.",
    "Travel expenses reimbursement for {name}: $15,000 for Caribbean business trip."
  ];

  function generateDocument() {
    const lines = [];
    const numLines = 15 + Math.floor(Math.random() * 8); // 15-23 lines per document
    for (let i = 0; i < numLines; i++) {
      const template = DOC_TEMPLATES[Math.floor(Math.random() * DOC_TEMPLATES.length)];
      const dummyName = DUMMY_NAMES[Math.floor(Math.random() * DUMMY_NAMES.length)];
      lines.push({
        text: template.replace('{name}', dummyName),
        containsTrump: false,
        protectedName: false,
        redacted: false
      });
    }
    return lines;
  }
  
  function resetEpstein() {
    const g = H - world.floor;
    player.x = 560*CFG.SCALE; 
    player.y = g;
    
    // Reset epstein game state
    Object.assign(EP, {
      papers: [],
      currentLine: 0,
      scrollSpeed: 0.5,
      scrollY: 0,
      timeElapsed: 0,
      missedTrumps: 0,
      foundTrumps: 0,
      gameActive: false,
      gameStartTime: 0,
      trumpLocations: [],
      generatedDocs: false
    });
    
    // Generate documents - base content
    for (let i = 0; i < 12; i++) {
      EP.papers.push(generateDocument());
    }
    EP.generatedDocs = true;

    // Distribute exactly N Trump targets across documents (bias towards later docs)
    let placedTrump = 0;
    const maxAttempts = 2000;
    let attempts = 0;
    const nDocs = EP.papers.length;
    while (placedTrump < EP.totalTrumpTargets && attempts++ < maxAttempts) {
      // Bias: later documents more likely
      const u = Math.random();
      const biased = Math.pow(u, 0.6); // <1 ‚Üí skews to higher indexes
      const d = Math.min(nDocs-1, Math.floor(biased * nDocs));
      const doc = EP.papers[d];
      const li = Math.floor(Math.random() * doc.length);
      const line = doc[li];
      if (line.containsTrump || line.protectedName) continue;
      const template = DOC_TEMPLATES[Math.floor(Math.random() * DOC_TEMPLATES.length)];
      line.text = template.replace('{name}', 'Donald Trump');
      line.containsTrump = true;
      placedTrump++;
    }

    // Ensure last document contains at least one Trump line
    if (nDocs > 0) {
      const last = EP.papers[nDocs-1];
      const hasTrump = last.some(l => l.containsTrump);
      if (!hasTrump) {
        for (let tries=0; tries<200; tries++){
          const li = Math.floor(Math.random()*last.length);
          const line = last[li];
          if (!line.containsTrump && !line.protectedName){
            const template = DOC_TEMPLATES[Math.floor(Math.random() * DOC_TEMPLATES.length)];
            line.text = template.replace('{name}', 'Donald Trump');
            line.containsTrump = true;
            placedTrump++;
            break;
          }
        }
      }
    }
    
    // Insert protected names (Bill Clinton, Bill Gates) ‚Äî e.g., 3 each
    const protectedCounts = { 'Bill Clinton': 3, 'Bill Gates': 3 };
    for (const [pname, count] of Object.entries(protectedCounts)){
      let placed = 0, tries = 0;
      while (placed < count && tries++ < maxAttempts) {
        const d = Math.floor(Math.random() * EP.papers.length);
        const doc = EP.papers[d];
        const li = Math.floor(Math.random() * doc.length);
        const line = doc[li];
        if (line.containsTrump || line.protectedName) continue;
        const template = DOC_TEMPLATES[Math.floor(Math.random() * DOC_TEMPLATES.length)];
        line.text = template.replace('{name}', pname);
        line.protectedName = true;
        placed++;
      }
    }

    // Instruction card
    openInfoCard(
      `CLASSIFIED DOCUMENTS\n\nTrumps er naturligvis ikke n√¶vnt i Epstein-papirerne.\nOverstreg de ${EP.totalTrumpTargets} fejltagelser, s√• sandheden ikke √¶ndres.\n\nKlik KUN p√• "Donald Trump".\nUndg√• at overstrege Bill Clinton og Bill Gates.\n\n1) Start`,
      () => { EP.gameActive = true; EP.gameStartTime = nowMs(); closeInfoCard(); }
    );
    
    // Position door for exit
    Object.assign(EP.door, {x: 120*CFG.SCALE, y: g});
  }
  
  function updateEpsteinGame() {
    if (!EP.gameActive) return;
    
    const currentTime = nowMs();
    EP.timeElapsed = currentTime - (EP.gameStartTime || currentTime);
    
    // Increase scroll speed from higher start to higher end based on scroll progress
    const paperY = H * 0.1;
    const lineHeight = 20 * CFG.SCALE;
    // compute total content height (30px top + headers + lines + gaps)
    let totalHeight = 30 * CFG.SCALE; 
    for (let d = 0; d < EP.papers.length; d++) {
      totalHeight += lineHeight * 1.5; // header
      totalHeight += EP.papers[d].length * lineHeight; // lines
      totalHeight += lineHeight; // gap
    }
    const startY = paperY + 30 * CFG.SCALE - EP.scrollY;
    const scrolled = Math.max(0, Math.min(totalHeight, (paperY + 30 * CFG.SCALE) - startY));
    const k = totalHeight > 0 ? (scrolled / totalHeight) : 0;
    EP.scrollSpeed = 1.2 + k * 2.8; // 1.2x -> 4.0x
    
    // Update scroll position - reduced base speed
    EP.scrollY += EP.scrollSpeed * 0.75 * CFG.SCALE;
    
    // Check for missed Trump names
    checkMissedTrumps();
    
    // End conditions (no timer): finish when last content scrolled out
    if (EP.failedByProtected) { endEpsteinGame('protected'); return; }
    if (EP.missedTrumps > EP.missesAllowed) { endEpsteinGame('misses'); return; }
    const finished = (startY + totalHeight) < (paperY - 200 * CFG.SCALE);
    if (finished) {
      if (EP.foundTrumps >= EP.totalTrumpTargets) endEpsteinGame('success');
      else endEpsteinGame('misses');
      return;
    }
  }
  
  function drawEpsteinScene() {
    // Desktop background
    ctx.fillStyle = '#8B4513'; // Dark wood desk
    ctx.fillRect(0, 0, W, H);
    
    // Paper area (white background)
    const paperX = W * 0.2;
    const paperY = H * 0.1; 
    const paperW = W * 0.6;
    const paperH = H * 0.8;
    
    ctx.fillStyle = '#f8f8f8'; // Off-white paper
    ctx.fillRect(paperX, paperY, paperW, paperH);
    
    // Paper shadow
    ctx.fillStyle = 'rgba(0,0,0,0.2)';
    ctx.fillRect(paperX + 4, paperY + 4, paperW, paperH);
    
    // Draw document lines
    if (EP.papers.length > 0) {
      ctx.save();
      
      // Clip to paper area
      ctx.beginPath();
      ctx.rect(paperX, paperY, paperW, paperH);
      ctx.clip();
      
      drawDocumentContent(paperX, paperY, paperW, paperH);
      
      ctx.restore();
    }
    
    // Draw HUD
    drawEpsteinHUD();
    
    // Update trump locations for click detection
    updateTrumpLocations(paperX, paperY, paperW, paperH);
    
    // Debug: Draw click areas (optional - remove later)
    if (CFG.DEBUG) {
      ctx.strokeStyle = '#00ff00';
      ctx.lineWidth = 1;
      EP.trumpLocations.forEach(trump => {
        ctx.strokeRect(trump.x, trump.y, trump.width, trump.height);
      });
    }
    
    // Draw door when game is not active
    if (!EP.gameActive) {
      drawDoor(EP.door.x, EP.door.y);
    }
    
    // Update game logic
    updateEpsteinGame();
  }
  
  function drawDocumentContent(paperX, paperY, paperW, paperH) {
    const lineHeight = 20 * CFG.SCALE;
    const fontSize = Math.floor(13 * CFG.SCALE);
    const leftMargin = paperX + 20 * CFG.SCALE;
    
    ctx.fillStyle = '#222';
    ctx.font = `${fontSize}px monospace`; // Monospace for document feel
    ctx.textAlign = 'left';
    
    let yPos = paperY + 30 * CFG.SCALE - EP.scrollY;
    let lineIndex = 0;
    
    // Clear trump locations for this frame
    EP.trumpLocations = [];
    
    // Draw all document lines
    EP.papers.forEach((document, docIndex) => {
      // Document header
      ctx.fillStyle = '#666';
      ctx.font = `bold ${fontSize}px monospace`;
      ctx.fillText(`--- CLASSIFIED DOCUMENT ${docIndex + 1} ---`, leftMargin, yPos);
      yPos += lineHeight * 1.5;
      lineIndex++;
      
      ctx.fillStyle = '#222';
      ctx.font = `${fontSize}px monospace`;
      
      document.forEach((line, idx) => {
        if (yPos > paperY - lineHeight && yPos < paperY + paperH + lineHeight) {
          if (line.redacted) {
            // Draw redaction (black bar)
            ctx.fillStyle = '#000';
            const textWidth = ctx.measureText(line.text).width;
            ctx.fillRect(leftMargin, yPos - fontSize * 0.7, textWidth, fontSize);
          } else {
            // Normal text
            if (line.containsTrump || line.protectedName) {
              // Highlight targets
              const isTrump = !!line.containsTrump;
              const bg = isTrump ? '#ffcccc' : '#cce5ff';
              const tx = isTrump ? '#d32f2f' : '#1565c0';
              ctx.fillStyle = bg; // background
              // Measure with bold font to match draw
              ctx.font = `bold ${fontSize}px monospace`;
              const textWidth = ctx.measureText(line.text).width;
              ctx.fillRect(leftMargin - 2, yPos - fontSize * 0.8, textWidth + 4, fontSize * 1.1);
              ctx.fillStyle = tx;
              ctx.fillText(line.text, leftMargin, yPos);
              ctx.font = `${fontSize}px monospace`; // Reset font
            } else {
              ctx.fillStyle = '#222';
              ctx.fillText(line.text, leftMargin, yPos);
            }
            
            // Store click targets for detection (Trump + protected) with generous padding
            if ((line.containsTrump || line.protectedName) && !line.redacted) {
              ctx.font = `bold ${fontSize}px monospace`;
              const textWidth = ctx.measureText(line.text).width;
              ctx.font = `${fontSize}px monospace`;
              const kind = line.containsTrump ? 'trump' : 'protected';
              // Dynamic padding grows with speed to keep clicks easy at high tempo
              const padX = (40 + (EP.scrollSpeed||1)*30) * CFG.SCALE;
              const padY = (18 + (EP.scrollSpeed||1)*12) * CFG.SCALE;
              EP.trumpLocations.push({
                x: (leftMargin - 2) - padX,
                y: (yPos - fontSize * 0.8) - padY,
                width: (textWidth + 4) + 2*padX,
                height: (fontSize * 1.1) + 2*padY,
                lineIndex: lineIndex,
                docIndex: docIndex,
                lineInDoc: idx,
                kind
              });
            }
          }
        }
        
        yPos += lineHeight;
        lineIndex++;
      });
      
      yPos += lineHeight; // Space between documents
    });
  }
  
  function drawEpsteinHUD() {
    // Timer
    const timeLeft = Math.max(0, Math.ceil((EP.timeLimitMs - EP.timeElapsed)/1000));
    ctx.fillStyle = 'rgba(0,0,0,0.8)';
    ctx.fillRect(W - 200, 20, 180, 130);
    
    ctx.fillStyle = '#fff';
    ctx.font = `bold ${16 * CFG.SCALE}px system-ui`;
    ctx.textAlign = 'left';
    // No time constraint shown
    ctx.fillText(`Speed: ${EP.scrollSpeed.toFixed(1)}x`, W - 190, 45);
    ctx.fillText(`Found: ${EP.foundTrumps}/${EP.totalTrumpTargets}`, W - 190, 70);
    ctx.fillText(`Missed: ${EP.missedTrumps}/${EP.missesAllowed}`, W - 190, 95);
    ctx.fillText(`Penalties: ${EP.protectedClicks||0}`, W - 190, 120);
    
    // Instructions
    ctx.fillStyle = 'rgba(0,0,0,0.8)';
    ctx.fillRect(20, H - 100, 350, 80);
    ctx.fillStyle = '#fff';
    ctx.font = `${14 * CFG.SCALE}px system-ui`;
    ctx.fillText('üéØ Klik p√• R√òDE (Donald Trump)', 30, H - 75);
    ctx.fillText('üõë Undg√• BL√Ö (Clinton/Gates)', 30, H - 55);
    ctx.fillText(`‚ö†Ô∏è ${EP.missesAllowed+1}+ miss = nederlag`, 30, H - 35);
  }
  
  function updateTrumpLocations(paperX, paperY, paperW, paperH) {
    // Locations are rebuilt each frame inside drawDocumentContent.
    // This function intentionally kept for future use.
  }
  
  function checkMissedTrumps() {
    // Compute from document structure rather than transient locations,
    // so lines that scrolled off-screen still count as missed.
    const paperY = H * 0.1;
    const lineHeight = 20 * CFG.SCALE;
    const startY = paperY + 30 * CFG.SCALE - EP.scrollY;
    
    for (let d = 0; d < EP.papers.length; d++) {
      const doc = EP.papers[d];
      // y at start of this document header
      let y = startY;
      for (let pd = 0; pd < d; pd++) {
        y += lineHeight * 1.5; // header
        y += EP.papers[pd].length * lineHeight; // lines
        y += lineHeight; // gap
      }
      
      // header of current doc
      y += lineHeight * 1.5;
      
      for (let li = 0; li < doc.length; li++) {
        const line = doc[li];
        if (line.containsTrump && !line.redacted) {
          const lineY = y + li * lineHeight;
          if (lineY < paperY - 150) { // missed threshold above paper
            line.redacted = true;
            EP.missedTrumps++;
            SFX.error();
            triggerShake(5 * CFG.SCALE, 200);
          }
        }
      }
    }
    // Note: EP.trumpLocations is still used for click detection; it is rebuilt during draw.
  }
  
  function endEpsteinGame(reason) {
    EP.gameActive = false;
    let text = '';
    if (reason === 'success') {
      const total = EP.totalTrumpTargets;
      const prot = EP.protectedClicks||0;
      text = `INTET AT SE HER!\n\nAlle ${total} "Donald Trump" er overstreget.\n${prot>0?`(Men du fors√∏gte at overstrege ${prot} bl√• linje${prot>1?'r':''} ‚Äî det blev noteret)\n`:''}"Selvf√∏lgelig er jeg ikke n√¶vnt ‚Äî never met the guy."`;
      addSafe('epstein', 'documents-redacted');
      SFX.achievement();
    } else if (reason === 'protected_click') {
      const prot = EP.protectedClicks||1;
      text = `FEJL I OVERSTREGNING!\n\nDu overstreger ${prot} bl√• linje${prot>1?'r':''} (Clinton/Gates).\nTrump: "Jeg sags√∏ger ALLE!"`;
      SFX.error();
    } else if (reason === 'misses') {
      const total = EP.totalTrumpTargets;
      text = `FOR MANGE SLIP!\n\n${EP.missedTrumps} af ${total} slap igennem.\nTrump: "Jeg sags√∏ger ALLE!"`;
      SFX.error();
    } else if (reason === 'timeout') {
      text = 'TIDEN L√òB UD!\n\nIkke alle fejltagelser blev fjernet i tide.\nTrump: "Fake news ‚Äî jeg sags√∏ger!"';
      SFX.error();
    } else {
      // Fallback
      text = 'DOKUMENTGENNEMGANG SLUT.';
    }
    gameOver(text);
  }
  
  function handleEpsteinClick(mouseX, mouseY) {
    if (!EP.gameActive) {
      // If game is not active, check for door exit
      const doorDist = Math.hypot(mouseX - EP.door.x, mouseY - EP.door.y);
      if (doorDist < 80 * CFG.SCALE) {
        // Exit back to helicopter menu
        openChoice("Leave document review?\n1) Continue redacting\n2) Back to helicopter", k=>{
          closeChoice();
          if (k==='2') switchScene('greenland');
        });
      }
      return;
    }
    
    // Check if click is on a target area (Trump or protected)
    for (let i = 0; i < EP.trumpLocations.length; i++) {
      const trump = EP.trumpLocations[i];
      
      if (mouseX >= trump.x && mouseX <= trump.x + trump.width &&
          mouseY >= trump.y && mouseY <= trump.y + trump.height) {
        
        // Locate the actual line
        const document = EP.papers[trump.docIndex];
        const line = document[trump.lineInDoc];
        
        if (!line || line.redacted) continue;
        
        if (trump.kind === 'protected') {
          // Protected click: count penalty, keep playing, and show toast
          line.redacted = true;
          EP.protectedClicks = (EP.protectedClicks||0) + 1;
          SFX.error();
          triggerShake(6*CFG.SCALE, 300);
          hudToast = 'Penalty: Overstreg ikke bl√• (Clinton/Gates)';
          EP.trumpLocations.splice(i, 1);
          return;
        } else if (trump.kind === 'trump') {
          // Successfully redacted Trump line
          line.redacted = true;
          EP.foundTrumps++;
          SFX.success();
          spawnSparks(mouseX, mouseY, 8);
          EP.trumpLocations.splice(i, 1);
          return;
        }
      }
    }
    
    // No Trump name clicked - maybe add small penalty sound
    SFX.click();
  }
  function switchScene(to){
    scene = to;
    if (scene==='greenland') { resetGreenland(); }
    else if (scene==='oval') { resetOval(); playEntryHeli('Back at the Resolute Desk ‚Äî the best!', 160*CFG.SCALE); }
    else if (scene==='kremlin') { resetKremlin(); playEntryHeli('Very strong handshake incoming.', 160*CFG.SCALE); }
    else if (scene==='epstein') { resetEpstein(); }
  }
  resetGreenland();
  // ensure inventory renders placeholders on load (no preloaded items)
  renderInv();
  renderHUD();

  // Reset handler consolidated in main keydown listener above

  // ---------- Interaktioner ----------
  function nearestGL(){
    const arr = [GL.mine, GL.mette, GL.rig, GL.heli, ...(GL.bear.alive ? [GL.bear] : []), ...GL.items.filter(it=>!it.collected), ...GL.glaciers.filter(g=>!g.blown), ...GL.coins.filter(c=>!c.collected)];
    let best=null, bd=1e9; for (const o of arr){ const d=dist(player,o); if (d<bd){bd=d; best=o;} }
    return (bd < CFG.INTERACT_DIST*CFG.SCALE) ? best : null;
  }
  function nearestOV(){
    const arr = [OV.door, OV.heli, OV.yes, ...OV.buttons, ...OV.coins.filter(c=>!c.collected)];
    let best=null, bd=1e9; for (const o of arr){ const d=dist(player,o); if (d<bd){bd=d; best=o;} }
    return (bd < CFG.INTERACT_DIST*CFG.SCALE) ? best : null;
  }
  function nearestKR(){
    const arr = [KR.door, KR.putin, KR.heli, ...KR.statues.filter(s=>!s.collected), ...KR.coins.filter(c=>!c.collected)];
    let best=null, bd=1e9; for (const o of arr){ const d=dist(player,o); if (d<bd){bd=d; best=o;} }
    return (bd < CFG.INTERACT_DIST*CFG.SCALE) ? best : null;
  }

  function interact(){
    if (scene==='greenland'){
      const obj = nearestGL(); if (!obj) return;
      addInteractionFeedback(obj); // Add visual feedback
      if (obj.type==='mine'){
        if (!GL.flag){ GL.flag = {x:GL.mine.x - 60*CFG.SCALE, y:H - world.floor}; GL.state.flagPlanted=true; say(player,"Planter frihed üá∫üá∏ (satire)",1500); }
        else say(player,"Flag er allerede her.",1000);
      }
      else if (obj.type==='bear'){
        if (!GL.bear.alive){ say(player,"‚Ä¶den er v√¶k.",900); return; }
        if (CFG.NON_VIOLENT){
          say(player,"S√∏d bj√∏rn. Tag en fisk üêü",1400); say(GL.bear,"Brumm?",1000);
          addSafe('greenland', 'bear-peace');
        } else {
          const oldHP = GL.bear.hp || 2;
          GL.bear.hp = Math.max(0, oldHP-1);
          
          // 2nd hit - bear gets ANGRY and starts chasing!
          if (oldHP === 1 && GL.bear.hp === 0) {
            say(GL.bear,"ROAAAAR! üò°",1500);
            say(player,"Uh oh... that bear looks MAD!",2000);
            spawnBlood(player.x, player.y-20*CFG.SCALE, 15);
            
            // Bear becomes angry and starts chasing
            GL.bear.angry = true;
            GL.bear.chasing = true;
            GL.bear.speed = 300; // Super fast when angry
            
            // Sound effects for angry bear
            ensureAudioInit();
            SFX.error();
            setTimeout(SFX.heartbeat, 500);
            
            // Camera shake for dramatic effect
            triggerShake(8*CFG.SCALE, 600);
            
            // Visual feedback - angry sparks
            for (let i = 0; i < 15; i++) {
              spawnSparks(GL.bear.x, GL.bear.y - 20*CFG.SCALE, 8);
            }
            
          } else {
            say(GL.bear,"Ufff!",800);
          }
          
          spawnBlood(GL.bear.x+8*CFG.SCALE, GL.bear.y-16*CFG.SCALE, 10);
          // knockback physics
          GL.bear.vy = (GL.bear.vy||0) - 280*CFG.SCALE;
          GL.bear.vx = (GL.bear.vx||0) + 60*CFG.SCALE;
          
          // Bear no longer dies, just gets angry when HP reaches 0
          // Remove the death logic since bear stays alive but angry
        }
      }
      else if (obj.type==='glacier'){
        const hasDynamite = inventory.find(i => i.id === 'dynamite');
        const dynamiteSelected = player.selectedItem === 'dynamite';
        
        if (!GL.state.hasSeenGlaciers) {
          // First interaction - complaint about view
          say(player, "These massive ice walls are blocking my BEAUTIFUL view! Need something explosive to clear them.", 2500);
          GL.state.hasSeenGlaciers = true;
        } else if (!hasDynamite) {
          // Subsequent interactions without dynamite in inventory
          say(player, "Still need something to blast through these glaciers! Where's my dynamite?", 2000);
        } else if (!dynamiteSelected) {
          // Has dynamite but not selected - more provocative
          say(player, "Look in the inventory, dummy!", 1500);
        } else {
          // Has dynamite and it's selected - BOOM!
          say(player, "Perfect! Let's blow these ice walls for a TREMENDOUS view!", 2000);
          
          setTimeout(() => {
            say(player, "BOOM! Now THAT'S what I call progress!", 1500);
            
            // Mark all glaciers as blown
            GL.glaciers.forEach(g => g.blown = true);
            GL.state.glaciersBlown = true;
            
            // Remove dynamite from inventory
            const dynIndex = inventory.findIndex(i => i.id === 'dynamite');
            if (dynIndex !== -1) inventory.splice(dynIndex, 1);
            renderInv();
            
            // Start explosion effects and water rising
            startGlacierExplosion();
          }, 1000);
        }
      }
      else if (obj.type==='mette'){
        const rel = RELATIONSHIPS.mette;
        let line, relationshipChange, trumpResponse;
        
        if (player.capOn) {
          line = "Den r√∏de kasket √¶ndrer ikke svaret.";
          relationshipChange = {respect: -3, trust: -2};
          trumpResponse = "The hat stays on!";
          adjustRelationship('mette', relationshipChange, 'wearing MAGA cap');
        } else {
          // Dynamic responses based on relationship and game state
          if (rel.respect >= 60) {
            if (!GL.state.flagPlanted) {
              line = "M√•ske kan vi diskutere handel i stedet?";
              trumpResponse = "Now we're talking business!";
              relationshipChange = {trust: 2};
              addSafe('greenland', 'mette-trade-talk');
            } else {
              line = "Jeg respekterer din position, men vi m√• v√¶re uenige.";
              trumpResponse = "Mutual respect. I like that.";
              relationshipChange = {respect: 1};
              addSafe('greenland', 'mette-respect-talk');
            }
          } else if (rel.respect <= 30) {
            if (GL.state.hasTweeted) {
              line = "Stop med at tweete om vores √∏, din narcissist!";
              trumpResponse = "Twitter is tremendous!";
              relationshipChange = {respect: -2, fear: 3};
            } else if (GL.state.flagPlanted) {
              line = "Fjern det flag NU, eller jeg ringer til NATO!";
              trumpResponse = "NATO loves me!";
              relationshipChange = {respect: -3, fear: 2};
            } else {
              line = "Du er ikke velkommen her!";
              trumpResponse = "Sad! Very unfair!";
              relationshipChange = {respect: -1, fear: 1};
            }
          } else {
            // Neutral responses (original dialogue)
            if (!GL.state.flagPlanted && !GL.state.hasTweeted) {
              line = "Gr√∏nland er ikke til salg.";
              trumpResponse = "Everything has a price!";
              relationshipChange = {trust: -1};
            } else if (GL.state.flagPlanted && !GL.state.hasTweeted) {
              line = "Seri√∏st, stop med at plante flag.";
              trumpResponse = "Best flags ever!";
              relationshipChange = {respect: -2};
            } else if (GL.state.hasTweeted) {
              line = "Stop venligst med at tweete om vores √∏.";
              trumpResponse = "Twitter is my platform!";
              relationshipChange = {trust: -2};
            }
          }
          adjustRelationship('mette', relationshipChange, 'conversation');
        }
        
        say(GL.mette, line, 2000);
        say(player, trumpResponse, 1400);
        GL.mette.nextBlink = nowMs() + 2000 + Math.random()*3000;
        GL.mette.blinkUntil = 0;
      }
      else if (obj.type==='rig'){
        GL.rig.burstUntil = nowMs() + 900;
        // emit oil burst from the top and falling to ground
        const topX = GL.rig.x, topY = GL.rig.y - 90*CFG.SCALE - 12*CFG.SCALE;
        spawnOil(topX, topY, 24);
        say(player,'Huge energy play. Beautiful, clean oil!',1600);
      }
      else if (obj.type==='heli'){
        addSafe('greenland', 'heli-travel');
        openChoice("Board helicopter?\n1) Bliv p√• Gr√∏nland\n2) Flyv til The White House\n3) Flyv til Moskva (m√∏de)\n4) Classified Documents", k=>{
          closeChoice();
          if (k==='2'){ switchScene('oval'); }
          if (k==='3'){ switchScene('kremlin'); }
          if (k==='4'){ switchScene('epstein'); }
        });
      }
      else if (obj.type==='pickup'){
        obj.collected=true;
        addToInventory(obj.id, obj.name);
        say(player, `Samlet: ${obj.name}`, 1000);
        addSafe('greenland', obj.id);
      }
    } else {
      if (scene==='oval'){
        const obj = nearestOV(); if (!obj) return;
        addInteractionFeedback(obj); // Add visual feedback
        if (obj.type==='door'){
          openChoice("Forlade The Oval Office?\n1) Bliv her\n2) Tilbage til Gr√∏nland", k=>{
            closeChoice();
            if (k==='2') switchScene('greenland');
          });
        }
        // aide disabled in this scene layout
        else if (obj.type==='yes'){
          praiseChoir();
          addSafe('oval', 'praise-choir');
        }
        else if (obj.type==='button'){
          const i = OV.buttons.indexOf(obj);
          // Add visual press effect
          obj.pressed = true;
          setTimeout(() => { if (obj) obj.pressed = false; }, 200);
          
          // Sound effects
          ensureAudioInit();
          if (i === 0) {
            SFX.error(); // Dramatic sound for nuclear button
            setTimeout(SFX.explosion, 500);
          } else {
            SFX.buttonPress();
          }
          
          if (i===0){ launchMissile(); return; }
          const r = Math.random();
          if (r<0.5){ const country = pickRandomCountry(); say(player,'Raise tariffs on '+country+'. Tremendous!',1600); }
          else { say(player,'Great governance!',1200); }
          praiseChoir();
          addSafe('oval', `button-${i}`);
        }
        else if (obj.type==='heli'){
          ensureAudioInit();
          SFX.helicopter();
          addSafe('oval', 'heli-travel');
          openChoice("Board helicopter?\n1) Bliv her\n2) Flyv til Gr√∏nland\n3) Flyv til Moskva (m√∏de)\n4) Classified Documents", k=>{
            closeChoice();
            if (k==='2') { SFX.whoosh(); switchScene('greenland'); }
            if (k==='3') { SFX.whoosh(); switchScene('kremlin'); }
            if (k==='4') { SFX.whoosh(); switchScene('epstein'); }
          });
        }
      } else if (scene==='kremlin'){
        const obj = nearestKR(); if (!obj) return;
        addInteractionFeedback(obj); // Add visual feedback
        if (obj.type==='door'){
          openChoice("Forlade m√∏det?\n1) Bliv her\n2) Tilbage til Gr√∏nland", k=>{ closeChoice(); if (k==='2') switchScene('greenland'); });
        }
        else if (obj.type==='putin'){
          startHandshake();
        }
        else if (obj.type==='statue'){
          // Check if Trump is caught by security camera
          if (isStatueUnderSurveillance(obj)) {
            // BUSTED! Discovery system activates
            triggerSecurityDiscovery(obj);
            return; // Don't collect the statue
          }
          
          obj.collected=true;
          addToInventory(obj.id, obj.name);
          addSafe('kremlin', obj.id);
          const boast=[
            'Only I could get this deal.',
            'They love me here. Tremendous!',
            'Beautiful piece. I deserve it.',
            'Everyone says it belongs with me.'
          ];
          say(player, boast[Math.floor(Math.random()*boast.length)], 1400);
        }
        else if (obj.type==='heli'){
          addSafe('kremlin', 'heli-travel');
          openChoice("Board helicopter?\n1) Bliv her\n2) Flyv til Gr√∏nland\n3) Flyv til The White House\n4) Classified Documents", k=>{
            closeChoice();
            if (k==='2') switchScene('greenland');
            if (k==='3') switchScene('oval');
            if (k==='4') switchScene('epstein');
          });
        }
      } else if (scene==='epstein') {
        // Epstein scene interactions (door exit when game is over)
        if (!EP.gameActive) {
          const obj = {type: 'door', x: EP.door.x, y: EP.door.y};
          const d = Math.hypot(player.x - obj.x, player.y - obj.y);
          if (d < CFG.INTERACT_DIST*CFG.SCALE) {
            openChoice("Leave document review?\n1) Stay here\n2) Back to helicopter", k=>{
              closeChoice();
              if (k==='2') switchScene('greenland');
            });
          }
        }
      }
    }
  }
  // Interact handler consolidated in main keydown listener above

  // ---------- Tweet logic ----------
  function doTweet(){
    const text = nextTweet();
    GL.state.hasTweeted = true;
    const wrapped = wrapTwoLines(text, 220*CFG.SCALE);
    const msg = wrapped.length>1 ? ('Tweet: "'+wrapped[0]+'\n'+wrapped[1]+'"') : ('Tweet: "'+wrapped[0]+'"');
    say(player, msg, 2400);
    tweetCount++;
    phoneBlinkUntil = nowMs() + 600;
    
    // Adjust relationships based on tweet context in different scenes
    if (scene === 'kremlin') {
      adjustRelationship('putin', {trust: -2, fear: 1}, 'tweeting_in_kremlin');
      SFX.tweet();
      // Putin might react to aggressive tweeting
      if (tweetCount > 3 && RELATIONSHIPS.putin.trust < 30) {
        setTimeout(() => {
          KR.putin.speakingUntil = nowMs() + 1500;
          KR.putin.say = 'Perhaps less... social media?';
        }, 1000);
      }
    } else if (scene === 'greenland') {
      adjustRelationship('mette', {respect: -1, trust: -2}, 'public_tweeting');
      SFX.tweet();
    }
  }
  function wrapTwoLines(text, maxW){
    ctx.save(); ctx.font=`${12*CFG.SCALE}px/1.2 system-ui`;
    const words = String(text).split(/\s+/);
    let line1='', line2='';
    for (const w of words){
      const test = line1 ? line1+' '+w : w;
      if (ctx.measureText(test).width <= maxW) line1 = test;
      else { line2 = line2 ? line2+' '+w : w; }
    }
    if (!line1 && line2){ line1=line2; line2=''; }
    ctx.restore();
    return line2 ? [line1, line2] : [line1];
  }
  function hasItem(id){ return inventory.some(it=>it.id===id); }
  
  function checkCoinRewards(){
    if (collectedCoins === 10 && !player.speedBoost10) {
      player.speedBoost10 = true;
      player.speedMul = (player.speedMul || 1) * 1.25;
      say(player, 'Speed boost! +25%', 2000);
    }
    if (collectedCoins === 18 && !player.healthBoost18) {
      player.healthBoost18 = true;
      // Add health regeneration or other bonus
      say(player, 'Health boost unlocked!', 2000);
    }
    // Check if all gold bars collected (total across all scenes: 12+7+4=23)
    const totalCoins = GL.coins.length + OV.coins.length + KR.coins.length;
    if (collectedCoins >= totalCoins && !player.masterCollector) {
      player.masterCollector = true;
      say(player, 'Gold Rush Master! All gold bars found!', 3000);
    }
  }
  function useInventoryKey(k){
    // map 1,2,3 to ITEM_META order
    const order = Object.keys(ITEM_META);
    const idx = parseInt(k,10)-1;
    const id = order[idx];
    if (!id) return;
    if (!hasItem(id)) { say(player, 'Ingen '+(ITEM_META[id].name||id)+' i inventaret', 900); return; }
    if (id==='tan') { player.tanLevel = Math.min(3, (player.tanLevel||0)+1); say(player,'Selvbruner +1',1000); renderInv(); return; }
    if (id==='cl') { player.speedMul = 1.35; speedBoostUntil = nowMs()+12000; say(player,'Tempo ‚Üë',900); renderInv(); renderHUD(); return; }
    if (id==='maga') { player.capOn = !player.capOn; say(player, player.capOn? 'Hat p√•.' : 'Hat af.',900); renderInv(); return; }
    if (id==='dynamite') { 
      player.selectedItem = 'dynamite'; 
      say(player,'Dynamit valgt! Klar til spr√¶ngning!',1200); 
      renderInv(); 
      // Clear selection after 10 seconds
      setTimeout(() => {
        if (player.selectedItem === 'dynamite') {
          player.selectedItem = null;
          say(player, 'Dynamit ikke l√¶ngere valgt', 800);
          renderInv();
        }
      }, 10000);
      return; 
    }
  }
  function nextTweet(){
    const lines = [];
    if (scene==='greenland'){
      if (!GL.state.flagPlanted && !GL.state.bearGone) lines.push('Great day in Greenland. Beautiful ice!');
      if (GL.state.flagPlanted) lines.push('We planted a small flag. Very legal & very cool.');
      if (GL.state.bearGone && CFG.NON_VIOLENT) lines.push('Made peace with a polar bear. Tremendous diplomacy.');
      if (GL.state.bearGone && !CFG.NON_VIOLENT) lines.push('Protected the people from a very dangerous bear!');
    } else {
      lines.push('Working hard in the Oval!');
    }
    if (hasItem('maga')) lines.push('Wearing my favorite hat. Crowds go wild!');
    if (hasItem('cl')) lines.push('Champions League trophy? Might bring it to the WH.');
    if (hasItem('tan')) lines.push('Natural tan. Best you‚Äôve ever seen.');
    const presets = [
      'So much winning!',
      'The Fake News won‚Äôt report this!',
      'MAKE GREENLAND GREAT AGAIN!',
      'Covfefe.',
    ];
    lines.push(presets[tweetCount % presets.length]);
    return lines.slice(0,2).join(' ');
  }

  // ---------- Mouse: hover + click-to-interact ----------
  const mouse = { x:0, y:0, active:false };
  let mouseMoveThrottle = 0;
  cvs.addEventListener('mousemove', e=>{
    const now = performance.now();
    if (now - mouseMoveThrottle < (GAME_CONSTANTS.PERFORMANCE && GAME_CONSTANTS.PERFORMANCE.MOUSE_THROTTLE_MS || 16)) return; // ~60fps throttle
    mouseMoveThrottle = now;
    
    const rect = cvs.getBoundingClientRect();
    mouse.x = e.clientX - rect.left;
    mouse.y = e.clientY - rect.top;
    mouse.active = true;
    
    // Enhanced drawing during drag
    if (isDrawing && borderDraw && borderDraw.mode === 'trump') {
      const card = getBorderCardRect();
      if (mouse.x>=card.x && mouse.x<=card.x+card.w && mouse.y>=card.y && mouse.y<=card.y+card.h){
        addDrawingPoint(mouse.x, mouse.y, now);
      }
    }
  }, { passive: true });
  cvs.addEventListener('mouseleave', ()=>{ mouse.active=false; isDrawing=false; });
  
  // Enhanced drawing events
  cvs.addEventListener('mousedown', e=>{
    if (borderDraw && borderDraw.mode === 'trump') {
      const card = getBorderCardRect();
      const rect = cvs.getBoundingClientRect();
      const mx = e.clientX - rect.left, my = e.clientY - rect.top;
      if (mx>=card.x && mx<=card.x+card.w && my>=card.y && my<=card.y+card.h){
        isDrawing = true;
        lastDrawPoint = {x: mx, y: my, time: nowMs()};
        if (borderDraw.points.length === 0) {
          borderDraw.points.push({x:mx, y:my});
        }
        e.preventDefault();
      }
    }
  });
  
  cvs.addEventListener('mouseup', e=>{
    isDrawing = false;
    lastDrawPoint = null;
  });

  // simple auto-walk tween
  let walkTween = null; // {sx,tx,start,dur}
  function startWalkTo(xTarget, dur, onDone){
    walkTween = { sx: player.x, tx: xTarget, start: nowMs(), dur: Math.max(100, dur), onDone };
    player.facing = Math.sign(xTarget - player.x) || player.facing;
  }
  function stepWalkTween(t){
    if (!walkTween) {
      // Not walking with tween
      if (player.walking && !keys.has('arrowleft') && !keys.has('arrowright') && !keys.has('arrowup') && !keys.has('arrowdown')) {
        player.walking = false;
        player.walkCycle = 0;
      }
      return false;
    }
    const k = Math.min(1, (t - walkTween.start)/walkTween.dur);
    // ease in-out
    const e = k<0.5? 2*k*k : -1 + (4 - 2*k)*k;
    const oldX = player.x;
    player.x = walkTween.sx + (walkTween.tx - walkTween.sx)*e;
    
    // Walking animation during tween
    const dt = 1/60; // Approximate delta time for animation
    if (Math.abs(player.x - oldX) > 0.1) {
      player.walking = true;
      player.walkCycle += dt * 8;
    }
    
    if (k>=1){ 
      const cb=walkTween.onDone; 
      walkTween=null; 
      player.walking = false; 
      player.walkCycle = 0; 
      cb && cb(); 
    }
    return true;
  }
  function nearestToPoint(objs, x, y){
    let best=null, bd=1e9; for (const o of objs){ const d=Math.hypot(x-o.x,y-o.y); if (d<bd){bd=d; best=o;} }
    return {obj:best, dist:bd};
  }
  cvs.addEventListener('click', e=>{
    // Handle intro screen clicks
    if (scene === 'intro') {
      startGame();
      return;
    }
    
    if (choiceOverlay) return;
    if (infoCard) return;
    if (flagOverlay) return;
    // Border drawing now handled by mousedown/drag system
    if (borderDraw){
      return;
    }
    
    // Handle Epstein scene clicks
    if (scene === 'epstein') {
      handleEpsteinClick(mouse.x, mouse.y);
      return;
    }
    const objs = scene==='greenland' ? [GL.mine, GL.bear, GL.mette, GL.rig, GL.heli, ...GL.items.filter(it=>!it.collected)]
                   : scene==='oval' ? [OV.door, OV.aide, OV.heli, OV.yes, ...OV.buttons]
                   : [KR.door, KR.putin, KR.heli, ...KR.statues.filter(s=>!s.collected)];
    const {obj, dist} = nearestToPoint(objs, mouse.x, mouse.y);
    if (!obj) return;
    const maxClickDist = GAME_CONSTANTS.UI.CLICK_DISTANCE*CFG.SCALE;
    if (dist > maxClickDist) return; // click too far from any object
    const pd = Math.hypot(player.x-obj.x, player.y-obj.y);
    const need = CFG.INTERACT_DIST*CFG.SCALE - 2;
    if (pd <= need){ interact(); return; }
    // auto-walk to just within range then interact
    const side = Math.sign(obj.x - player.x) || 1;
    const targetX = clamp(obj.x - side*need, 40*CFG.SCALE, W-40*CFG.SCALE);
    const dx = Math.abs(targetX - player.x);
    const dur = Math.min(900, (dx / (CFG.SPEED*CFG.SCALE)) * 1000 + 150);
    startWalkTo(targetX, dur, () => interact());
  });

  // ---------- Jump ----------
  let jumpTween = null; // {start,dur,height}
  function doJump(){
    if (choiceOverlay) return;
    if (infoCard) return;
    if (flagOverlay) return;
    if (jumpTween) return;
    // MAGA hat gives super jump!
    const jumpHeight = player.capOn ? 50*CFG.SCALE : 26*CFG.SCALE;
    jumpTween = { start: nowMs(), dur: 520, height: jumpHeight };
  }

  function animateExit(who, dir=+1, dist=220){
    const s = nowMs(), d=1400, sx=who.x, sy=who.y;
    function step(t){ const k=Math.min(1,(t-s)/d); who.x = sx + dir*k*dist*CFG.SCALE; who.y = sy - Math.sin(k*Math.PI)*20*CFG.SCALE; if (k<1) requestAnimationFrame(step); }
    requestAnimationFrame(step);
  }

  // slight nudge/knockback tween
  function nudge(who, dx, dy, dur=120){
    const s = nowMs(); const sx=who.x, sy=who.y;
    function step(t){ const k=Math.min(1,(t-s)/dur); const e = 1-Math.cos(k*Math.PI); who.x = sx + dx*e; who.y = sy + dy*e; if (k<1) requestAnimationFrame(step); }
    requestAnimationFrame(step);
  }

  
  function startGlacierExplosion() {
    glacierExplosion.active = true;
    glacierExplosion.waterLevel = 0;
    
    // Create multiple explosion points
    GL.glaciers.forEach(glacier => {
      glacierExplosion.explosions.push({
        x: glacier.x,
        y: glacier.y,
        time: nowMs(),
        duration: 1000
      });
      
      // Create ice chunks falling from each glacier
      for (let i = 0; i < 15; i++) {
        glacierExplosion.iceChunks.push({
          x: glacier.x + (Math.random() - 0.5) * glacier.w * CFG.SCALE,
          y: glacier.y - glacier.h * CFG.SCALE/2,
          vx: (Math.random() - 0.5) * 300 * CFG.SCALE,
          vy: -Math.random() * 100 * CFG.SCALE,
          size: 4 + Math.random() * 8,
          rotation: Math.random() * Math.PI * 2,
          rotSpeed: (Math.random() - 0.5) * 10,
          life: 3000 + Math.random() * 2000
        });
      }
    });
    
    // Camera shake for dramatic effect
    triggerShake(15 * CFG.SCALE, 1200);
    
    // Sound effects
    ensureAudioInit();
    SFX.error(); // Explosion sound
    setTimeout(SFX.heartbeat, 300);
    setTimeout(SFX.heartbeat, 600);
    
    // Start water rising after a delay
    setTimeout(() => {
      startWaterRising();
    }, 2000);
  }
  
  function startWaterRising() {
    // Water level will rise over 8 seconds to create suspense
    const riseInterval = setInterval(() => {
      glacierExplosion.waterLevel += H / 480; // Rise slowly
      
      if (glacierExplosion.waterLevel >= H) {
        clearInterval(riseInterval);
        // Trigger climate catastrophe game over
        setTimeout(() => {
          gameOver('üß® Trump spr√¶ngte Gr√∏nlands gletschere for bedre udsigt!\nüåä Is-tsunami oversv√∏mmede hele verden!\nüè® "Perfect beachfront property now!" - Trump\n‚ò†Ô∏è Global klimakatastrofe udl√∏st');
        }, 500);
      }
    }, 16); // ~60fps
  }

  // ---------- Simple blood particles ----------
  // Object pooling for better performance
  const fx = { blood: [], sparks: [], downwash: [], oil: [], flame: [] };
  const particlePools = {
    blood: [],
    sparks: [],
    downwash: [],
    oil: [],
    flame: []
  };
  
  function getParticle(type) {
    return particlePools[type].pop() || {};
  }
  
  function returnParticle(type, particle) {
    // Reset particle properties
    Object.keys(particle).forEach(key => delete particle[key]);
    particlePools[type].push(particle);
  }
  const NUKE = { active:false, x:0, y:0, start:0, dur:3200, startY:0, endY:0 };
  const SHAKE = { start:0, dur:0, amp:0, until:0 };
  function triggerShake(amp, dur){ SHAKE.start=nowMs(); SHAKE.dur=dur; SHAKE.amp=amp; SHAKE.until=SHAKE.start+dur; }
  function launchMissile(){
    NUKE.active=true; NUKE.start=nowMs(); NUKE.dur=3200; NUKE.x = W/2;
    NUKE.startY = H + 200*CFG.SCALE; NUKE.endY = -260*CFG.SCALE; NUKE.y = NUKE.startY;
    triggerShake(8*CFG.SCALE, 700);
  }
  function spawnBlood(x,y,count=8){
    for (let i=0;i<count;i++){
      const particle = getParticle('blood');
      particle.x = x;
      particle.y = y;
      particle.vx = (Math.random()*60-30)*CFG.SCALE;
      particle.vy = (-Math.random()*60-10)*CFG.SCALE;
      particle.life = 400 + Math.random()*300;
      particle.size = 3 + Math.floor(Math.random()*2);
      fx.blood.push(particle);
    }
  }
  
  function spawnSparks(x,y,count=12){
    for (let i=0;i<count;i++){
      const particle = getParticle('sparks');
      particle.x = x;
      particle.y = y;
      particle.vx = (Math.random()*120-60)*CFG.SCALE;
      particle.vy = (-Math.random()*140-40)*CFG.SCALE;
      particle.life = 300 + Math.random()*300;
      particle.size = 2 + Math.floor(Math.random()*2);
      fx.sparks.push(particle);
    }
  }
  function spawnOil(x,y,count=18){
    for (let i=0;i<count;i++){
      const particle = getParticle('oil');
      particle.x = x;
      particle.y = y;
      particle.vx = (Math.random()*60-30)*CFG.SCALE;
      particle.vy = (-Math.random()*120-80)*CFG.SCALE;
      particle.life = 900 + Math.random()*600;
      particle.size = 3 + Math.floor(Math.random()*3);
      particle.landed = false;
      fx.oil.push(particle);
    }
  }
  function spawnFlame(x,y,count=10){
    for (let i=0;i<count;i++){
      const particle = getParticle('flame');
      particle.x = x;
      particle.y = y;
      particle.vx = (Math.random()*80-40)*CFG.SCALE;
      particle.vy = (40+Math.random()*80)*CFG.SCALE; // tail downward
      particle.life = 300 + Math.random()*250;
      particle.size = 2 + Math.floor(Math.random()*3);
      particle.color = Math.random()<0.5 ? '#ff9800' : '#ffd54f';
      fx.flame.push(particle);
    }
  }
  function spawnDownwash(x,y,scene){
    const count = 4 + Math.floor(Math.random()*3);
    const color = scene==='greenland' ? 'rgba(255,255,255,0.6)' : 'rgba(200,200,200,0.5)';
    for (let i=0;i<count;i++){
      fx.downwash.push({
        x: x + (Math.random()*40-20), y: y + (Math.random()*6-3),
        vx: (Math.random()*60-30)*CFG.SCALE,
        vy: (-Math.random()*40-20)*CFG.SCALE,
        life: 300 + Math.random()*300,
        size: 3 + Math.floor(Math.random()*3),
        color
      });
    }
  }

  // ---------- Choice overlay ----------
  function openChoice(text, onKey){
    choiceOverlay = { text, onKey };
  }
  function closeChoice(){ choiceOverlay = null; }

  // ---------- Info card overlay ----------
  let infoCard = null; // {text, onKey} - styled like flag overlay card
  function openInfoCard(text, onKey){
    infoCard = { text, onKey };
  }
  function closeInfoCard(){ infoCard = null; }

  function drawInfoCard() {
    if (!infoCard) return;
    
    const card = getBorderCardRect();
    
    // Dim background outside card area only
    ctx.fillStyle='rgba(0,0,0,.6)'; 
    ctx.fillRect(0, 0, W, H);
    
    // Clear card area (remove dimming)
    ctx.clearRect(card.x-10, card.y-10, card.w+20, card.h+20);
    
    // Draw card background with border frame
    ctx.fillStyle='#f7f5ee'; 
    ctx.fillRect(card.x, card.y, card.w, card.h);
    
    // Enhanced frame/border around card
    ctx.strokeStyle='#c9a641'; 
    ctx.lineWidth=6; 
    ctx.strokeRect(card.x-6, card.y-6, card.w+12, card.h+12);
    
    // Inner shadow effect
    ctx.strokeStyle='#8b7355'; 
    ctx.lineWidth=2; 
    ctx.strokeRect(card.x-2, card.y-2, card.w+4, card.h+4);
    
    // Draw text content centered in card
    const lines = infoCard.text.split('\n');
    ctx.fillStyle='#333'; 
    ctx.font=`bold ${16*CFG.SCALE}px system-ui`; 
    ctx.textAlign='center';
    
    const lineHeight = 22*CFG.SCALE;
    const totalTextHeight = lines.length * lineHeight;
    const startY = card.y + (card.h - totalTextHeight) / 2 + lineHeight;
    
    lines.forEach((line, i) => {
      ctx.fillText(line, card.x + card.w/2, startY + i * lineHeight);
    });
    
    ctx.textAlign='left';
  }

  // ---------- Tug-of-war mini-game ----------
  let tug = null; // {pos,lastKey,start,dur}
  function startHandshake(){ 
    openInfoCard("HANDTRYKS-KAMP MED PUTIN\n\nHvem har det kraftigste handtryk?\nDig eller Putin?\nDen staerkeste faar Ukraine!\n\nTryk A og D hurtigt for at vinde!\n\n1) Start kampen!\n2) Du kan ikke fortryde", k => {
      closeInfoCard();
      // Begge options starter spillet - ingen vej tilbage!
      startTug();
    });
  }
  function startTug(){
    if (tug) return;
    tug = { pos:0, lastKey:'', start: nowMs(), dur: 4500 };
  }
  function handleTugKey(k){
    if (!tug) return;
    if ((k==='a' || k==='d') && k!==tug.lastKey){ tug.pos += 0.18; tug.lastKey = k; }
  }

  // ---------- Border drawing overlay (Kremlin) ----------
  // borderDraw already declared above
  function startBorderDraw(mode){
    borderDraw = { active:true, points:[], mode: mode==='putin' ? 'putin' : 'trump', gen:false };
  }
  function stopBorderDraw(save){
    if (save && borderDraw){
      // normalize and store in KR.border
      const card = getBorderCardRect();
      const pts = borderDraw.points.map(p=>({ x: (p.x - card.x)/card.w, y: (p.y - card.y)/card.h }));
      KR.border = pts;
      reactToBorder(pts, borderDraw.mode);
    }
    borderDraw = null;
  }
  function getBorderCardRect(){
    const w = Math.min(620*CFG.SCALE, W*0.8), h = w*0.6;
    return { x: W/2 - w/2, y: H/2 - h/2, w, h };
  }

  // ---------- Flag planting system ----------
  function plantFlag(flagType) {
    KR.ukraineFlag = flagType;
    flagOverlay = { 
      flagType, 
      startTime: nowMs(),
      animationStart: nowMs(),
      animationDuration: 2000 // 2 seconds for animation
    };
  }

  function closeFlagOverlay() {
    flagOverlay = null;
  }

  function drawFlagOverlay() {
    if (!flagOverlay) return;
    
    const card = getBorderCardRect();
    
    // Dim background outside card area only
    ctx.fillStyle='rgba(0,0,0,.6)'; 
    ctx.fillRect(0, 0, W, H);
    
    // Clear card area (remove dimming)
    ctx.fillStyle='rgba(0,0,0,0)';
    ctx.clearRect(card.x-10, card.y-10, card.w+20, card.h+20);
    
    // Draw map background with border frame
    ctx.fillStyle='#f7f5ee'; 
    ctx.fillRect(card.x, card.y, card.w, card.h);
    
    // Enhanced frame/border around card
    ctx.strokeStyle='#c9a641'; 
    ctx.lineWidth=6; 
    ctx.strokeRect(card.x-6, card.y-6, card.w+12, card.h+12);
    
    // Inner shadow effect
    ctx.strokeStyle='#8b7355'; 
    ctx.lineWidth=2; 
    ctx.strokeRect(card.x-2, card.y-2, card.w+4, card.h+4);
    
    // Draw world map
    if (MAP_IMG_READY){
      ctx.drawImage(MAP_IMG, card.x, card.y, card.w, card.h);
    } else {
      ctx.save(); 
      ctx.translate(card.x, card.y);
      drawEnhancedWorldMap(ctx, card.w, card.h);
      ctx.restore();
    }
    
    // Draw flag on Ukraine
    drawFlagOnUkraine(card, flagOverlay.flagType);
    
    // Show message inside bottom frame with white text
    ctx.fillStyle='#fff'; 
    ctx.font=`bold ${18*CFG.SCALE}px system-ui`; 
    ctx.textAlign='center';
    const message = flagOverlay.flagType === 'american' ? 'UKRAINE ER NU AMERIKANSK TERRITORIUM!' : 'UKRAINE FORBLIVER UNDER RUSSISK INDFLYDELSE!';
    ctx.fillText(message, W/2, card.y + card.h - 25*CFG.SCALE);
    ctx.fillStyle='#666'; 
    ctx.font=`${14*CFG.SCALE}px system-ui`;
    ctx.fillText('Tryk Enter for at fortsaette...', W/2, card.y + card.h + 70);
    ctx.textAlign='left';
  }

  function drawFlagOnUkraine(card, flagType) {
    // Ukraine position on map (relative to card) - updated for new cropped map
    const ukraineX = card.x + card.w * 0.50;
    const ukraineY = card.y + card.h * 0.50;
    
    // Animation calculations
    const elapsed = nowMs() - flagOverlay.animationStart;
    const progress = Math.min(1, elapsed / flagOverlay.animationDuration);
    
    // Easing function with bounce
    const easeOutBounce = (t) => {
      if (t < 1/2.75) {
        return 7.5625 * t * t;
      } else if (t < 2/2.75) {
        return 7.5625 * (t -= 1.5/2.75) * t + 0.75;
      } else if (t < 2.5/2.75) {
        return 7.5625 * (t -= 2.25/2.75) * t + 0.9375;
      } else {
        return 7.5625 * (t -= 2.625/2.75) * t + 0.984375;
      }
    };
    
    const animatedProgress = easeOutBounce(progress);
    
    // Animation: flag drops from above and scales in
    const startY = ukraineY - 60; // Start position (above Ukraine)
    const currentY = startY + (ukraineY - startY) * animatedProgress;
    const scale = 0.3 + (0.7 * animatedProgress); // Start small, grow to normal
    
    // Draw flag with animation
    const flagWidth = 16 * scale;
    const flagHeight = 12 * scale;
    
    ctx.save();
    // Add slight rotation during fall
    const rotation = (1 - animatedProgress) * 0.3;
    ctx.translate(ukraineX, currentY);
    ctx.rotate(rotation);
    
    if (flagType === 'american') {
      // American flag (simplified)
      ctx.fillStyle='#b22234'; // red
      ctx.fillRect(-flagWidth/2, -flagHeight/2, flagWidth, flagHeight);
      ctx.fillStyle='#ffffff'; // white stripes
      for (let i = 1; i < flagHeight; i += 2) {
        ctx.fillRect(-flagWidth/2, -flagHeight/2+i, flagWidth, 1);
      }
      ctx.fillStyle='#3c3b6e'; // blue canton
      ctx.fillRect(-flagWidth/2, -flagHeight/2, flagWidth/2, flagHeight/2);
    } else if (flagType === 'russian') {
      // Russian flag (simplified)
      ctx.fillStyle='#ffffff'; // white
      ctx.fillRect(-flagWidth/2, -flagHeight/2, flagWidth, flagHeight/3);
      ctx.fillStyle='#0039a6'; // blue  
      ctx.fillRect(-flagWidth/2, -flagHeight/2+flagHeight/3, flagWidth, flagHeight/3);
      ctx.fillStyle='#d52b1e'; // red
      ctx.fillRect(-flagWidth/2, -flagHeight/2+2*flagHeight/3, flagWidth, flagHeight/3);
    }
    
    ctx.restore();
  }
  
  function drawEnhancedWorldMap(ctx, w, h) {
    // Ocean background
    ctx.fillStyle='#4a90e2'; 
    ctx.fillRect(0, 0, w, h);
    
    // Cropped/zoomed view focusing on Europe-Russia-Ukraine area
    // Scale and position everything larger and more centered
    
    // EU (much larger, positioned left)
    ctx.fillStyle='#6c5ce7';
    ctx.beginPath();
    ctx.moveTo(w*0.15, h*0.35);
    ctx.bezierCurveTo(w*0.05, h*0.25, w*0.25, h*0.20, w*0.40, h*0.30);
    ctx.bezierCurveTo(w*0.45, h*0.40, w*0.42, h*0.55, w*0.35, h*0.65);
    ctx.bezierCurveTo(w*0.25, h*0.70, w*0.15, h*0.60, w*0.15, h*0.35);
    ctx.closePath();
    ctx.fill();
    
    // Ukraine (much larger and more central)
    ctx.fillStyle='#ffd32a';
    ctx.beginPath();
    ctx.moveTo(w*0.40, h*0.40);
    ctx.lineTo(w*0.55, h*0.35);
    ctx.lineTo(w*0.65, h*0.45);
    ctx.lineTo(w*0.60, h*0.60);
    ctx.lineTo(w*0.45, h*0.65);
    ctx.lineTo(w*0.35, h*0.55);
    ctx.closePath();
    ctx.fill();
    
    // Russia (large mass, positioned right and top)
    ctx.fillStyle='#d63031';
    ctx.beginPath();
    ctx.moveTo(w*0.55, h*0.10);
    ctx.bezierCurveTo(w*0.45, h*0.05, w*0.70, h*0.02, w*0.95, h*0.15);
    ctx.bezierCurveTo(w*1.00, h*0.25, w*0.95, h*0.50, w*0.85, h*0.60);
    ctx.bezierCurveTo(w*0.70, h*0.65, w*0.60, h*0.55, w*0.55, h*0.40);
    ctx.bezierCurveTo(w*0.50, h*0.25, w*0.55, h*0.10, w*0.55, h*0.10);
    ctx.closePath();
    ctx.fill();

    // China/Asia (smaller, positioned far right)
    ctx.fillStyle='#fdcb6e';
    ctx.beginPath();
    ctx.moveTo(w*0.80, h*0.45);
    ctx.bezierCurveTo(w*0.85, h*0.40, w*0.95, h*0.42, w*0.98, h*0.55);
    ctx.bezierCurveTo(w*0.95, h*0.70, w*0.85, h*0.72, w*0.80, h*0.65);
    ctx.bezierCurveTo(w*0.75, h*0.55, w*0.78, h*0.50, w*0.80, h*0.45);
    ctx.closePath();
    ctx.fill();
    
    // Africa
    ctx.fillStyle='#e17055';
    ctx.beginPath();
    ctx.moveTo(w*0.48, h*0.45);
    ctx.bezierCurveTo(w*0.45, h*0.40, w*0.50, h*0.38, w*0.55, h*0.42);
    ctx.bezierCurveTo(w*0.58, h*0.55, w*0.55, h*0.70, w*0.50, h*0.72);
    ctx.bezierCurveTo(w*0.45, h*0.65, w*0.46, h*0.50, w*0.48, h*0.45);
    ctx.closePath();
    ctx.fill();
    
    // Australia/Oceania
    ctx.fillStyle='#00b894';
    ctx.beginPath();
    ctx.ellipse(w*0.82, h*0.65, w*0.08, h*0.05, 0, 0, Math.PI * 2);
    ctx.fill();
    
    // Greenland (highlighted!)
    ctx.fillStyle='#00cec9';
    ctx.beginPath();
    ctx.ellipse(w*0.25, h*0.12, w*0.04, h*0.06, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.strokeStyle='#00b894';
    ctx.lineWidth=2;
    ctx.stroke();
    
    // Add country labels
    ctx.fillStyle='#2d3436';
    ctx.font = `bold ${Math.floor(h*0.04)}px system-ui`;
    ctx.textAlign='center';
    ctx.fillText('üá∫üá∏ USA', w*0.22, h*0.45);
    ctx.fillText('üá∑üá∫ RUSSIA', w*0.70, h*0.25);
    ctx.fillText('üá®üá≥ CHINA', w*0.78, h*0.45);
    ctx.fillText('üá™üá∫ EU', w*0.50, h*0.32);
    ctx.fillText('üá¨üá±', w*0.25, h*0.08);
    
    // Add strategic markers
    ctx.fillStyle='#e84393';
    // Nuclear symbols
    drawNuclearSymbol(ctx, w*0.22, h*0.35, h*0.02); // USA
    drawNuclearSymbol(ctx, w*0.70, h*0.30, h*0.02); // Russia
    drawNuclearSymbol(ctx, w*0.78, h*0.40, h*0.02); // China
  }
  
  function drawNuclearSymbol(ctx, x, y, size) {
    ctx.save();
    ctx.translate(x, y);
    ctx.fillStyle='#e84393';
    // Nuclear trefoil symbol
    for(let i = 0; i < 3; i++) {
      ctx.save();
      ctx.rotate(i * Math.PI * 2/3);
      ctx.beginPath();
      ctx.arc(0, -size*0.7, size*0.4, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }
    // Center circle
    ctx.beginPath();
    ctx.arc(0, 0, size*0.3, 0, Math.PI * 2);
    ctx.fillStyle='#2d3436';
    ctx.fill();
    ctx.restore();
  }
  function smoothBorder() {
    if (!borderDraw || borderDraw.points.length < 3) return;
    
    // Simple smoothing using average of neighboring points
    const original = [...borderDraw.points];
    for (let i = 1; i < original.length - 1; i++) {
      const prev = original[i-1];
      const curr = original[i];
      const next = original[i+1];
      
      // Average position with neighbors (weighted toward current)
      borderDraw.points[i] = {
        x: (prev.x * 0.2 + curr.x * 0.6 + next.x * 0.2),
        y: (prev.y * 0.2 + curr.y * 0.6 + next.y * 0.2)
      };
    }
  }
  
  function addDrawingPoint(x, y, time) {
    if (!borderDraw || !borderDraw.points) return;
    
    // Check if we should add this point based on distance and time
    if (lastDrawPoint) {
      const dist = Math.hypot(x - lastDrawPoint.x, y - lastDrawPoint.y);
      const timeDiff = time - lastDrawPoint.time;
      const speed = dist / Math.max(timeDiff, 1) * 1000; // pixels per second
      
      // Skip point if too close or moving too fast (likely erratic)
      if (dist < drawingSettings.smoothingDistance) return;
      if (speed > drawingSettings.maxDrawingSpeed && borderDraw.points.length > 2) return;
    }
    
    // Add point with smooth interpolation if gap is large
    if (lastDrawPoint) {
      const dist = Math.hypot(x - lastDrawPoint.x, y - lastDrawPoint.y);
      if (dist > drawingSettings.smoothingDistance * 3) {
        // Add intermediate points for smooth curves
        const steps = Math.floor(dist / drawingSettings.smoothingDistance);
        for (let i = 1; i < steps; i++) {
          const t = i / steps;
          const ix = lastDrawPoint.x + (x - lastDrawPoint.x) * t;
          const iy = lastDrawPoint.y + (y - lastDrawPoint.y) * t;
          borderDraw.points.push({x: ix, y: iy});
        }
      }
    }
    
    borderDraw.points.push({x, y});
    lastDrawPoint = {x, y, time};
    
    // Limit total points to prevent performance issues
    if (borderDraw.points.length > 200) {
      // Remove every other point to reduce complexity while maintaining shape
      borderDraw.points = borderDraw.points.filter((_, i) => i % 2 === 0);
    }
  }
  
  function analyzeBorderLive(pts, card) {
    // Real-time analysis for drawing feedback
    let len=0, turns=0, aggression=0;
    
    for (let i=1;i<pts.length;i++){
      const dx=pts[i].x-pts[i-1].x, dy=pts[i].y-pts[i-1].y;
      len+=Math.hypot(dx,dy);
      
      if (i>1){
        const a=Math.atan2(dy,dx), b=Math.atan2(pts[i-1].y-pts[i-2].y, pts[i-1].x-pts[i-2].x);
        if (Math.abs(a-b)>0.8) turns++;
      }
      
      // Normalized coordinates for aggression check
      const normalX = (pts[i].x - card.x) / card.w;
      if (normalX > 0.6) aggression++;
    }
    
    const lengthDesc = len < 200 ? 'Short' : len < 500 ? 'Medium' : 'Long';
    const strategyDesc = turns < 3 ? 'Direct' : turns < 8 ? 'Diplomatic' : 'Complex';
    const aggressionDesc = aggression < 2 ? 'Peaceful' : aggression < 5 ? 'Assertive' : 'Aggressive';
    
    return { lengthDesc, strategyDesc, aggressionDesc };
  }
  
  function reactToBorder(pts, mode){
    // Enhanced border analysis
    let len=0, turns=0, straightness=0, aggression=0;
    
    for (let i=1;i<pts.length;i++){
      const dx=pts[i].x-pts[i-1].x, dy=pts[i].y-pts[i-1].y;
      len+=Math.hypot(dx,dy);
      
      if (i>1){
        const a=Math.atan2(dy,dx), b=Math.atan2(pts[i-1].y-pts[i-2].y, pts[i-1].x-pts[i-2].x);
        const angleDiff = Math.abs(a-b);
        if (angleDiff>0.8) turns++;
        straightness += angleDiff;
      }
      
      // Check for aggressive land grabs (going into enemy territory)
      if (mode==='trump' && pts[i].x > 0.6) aggression++;
      if (mode==='putin' && pts[i].x < 0.4) aggression++;
    }
    
    const complexity = turns + straightness*10;
    const landGrab = aggression / pts.length;
    
    // Enhanced reactions based on border characteristics
    let trumpLines, putinLines;
    
    if (landGrab > 0.3) {
      trumpLines = ['Tremendous expansion!', 'Best deals, huge territory!', 'Making borders great again!'];
      putinLines = ['Very aggressive move.', 'Bold territorial claim.', 'Interesting strategy.'];
    } else if (complexity < 5) {
      trumpLines = ['Simple and effective!', 'Clean lines, perfect!', 'Straight to the point!'];
      putinLines = ['Efficient boundaries.', 'Practical approach.', 'Minimalist style.'];
    } else if (complexity > 20) {
      trumpLines = ['Complex negotiations!', 'Artistic borders!', 'Very detailed work!'];
      putinLines = ['Complicated boundaries.', 'Intricate design.', 'Many considerations.'];
    } else {
      trumpLines = ['Fair and balanced!', 'Perfect compromise!', 'Diplomatic borders!'];
      putinLines = ['Reasonable solution.', 'Balanced approach.', 'Acceptable terms.'];
    }
    
    const line = (mode==='trump' ? trumpLines : putinLines)[Math.floor(Math.random() * 3)];
    
    if (mode==='trump') {
      say(player, line, 1800);
    } else { 
      KR.putin.speakingUntil=nowMs()+1800; 
      KR.putin.say=line;
    }
    
    // Store border metrics for potential future use
    KR.borderMetrics = { length: len, complexity, aggression: landGrab, mode };
  }

  // ---------- Tegn elementer ----------
  function drawTrump(x,y,dir=1){
    // Check if custom Trump image is available
    if (GRAPHICS.drawOrFallback(ctx, 'trump', drawTrumpFallback, x, y, dir)) {
      return; // Custom image was drawn successfully
    }
    
    drawTrumpFallback(x, y, dir);
  }
  
  function drawTrumpFallback(x,y,dir=1){
    // slight head/torso nod
    const nod = Math.sin(nowMs()/1100 + (player.nodPhase||0)) * 0.6*CFG.SCALE;
    ctx.save(); ctx.translate(x, y-44*CFG.SCALE + nod); ctx.scale(CFG.SCALE, CFG.SCALE);
    
    // Walking animation for legs
    ctx.fillStyle='#2b2b2b'; 
    if (player.walking && Math.floor(player.walkCycle) % 2 === 0) {
      // Walking pose 1 - left leg forward
      ctx.fillRect(-10,34,9,10); // left leg normal
      ctx.fillRect(2,36,9,8);    // right leg back/up
    } else if (player.walking) {
      // Walking pose 2 - right leg forward  
      ctx.fillRect(-10,36,9,8);  // left leg back/up
      ctx.fillRect(2,34,9,10);   // right leg normal
    } else {
      // Standing still - normal pose
      ctx.fillRect(-10,34,9,10); ctx.fillRect(2,34,9,10);
    }
    ctx.fillStyle='#7a5328'; ctx.fillRect(-12,6,24,26);
    ctx.fillStyle='#d8e6ff'; ctx.fillRect(-8,10,16,18);
    ctx.fillStyle='#e02424'; ctx.fillRect(-2,14,4,14);
    ctx.fillStyle=skinColor(); ctx.fillRect(-9,-2,18,12);
    // eyes (blink)
    if (!(player.blinkUntil && nowMs() < player.blinkUntil)){
      ctx.fillStyle='#111'; ctx.fillRect(-6,2,2,2); ctx.fillRect(4,2,2,2);
    } else {
      ctx.fillStyle='#111'; ctx.fillRect(-6,3,2,1); ctx.fillRect(4,3,2,1);
    }
    // hair or cap
    if (player.capOn){
      ctx.fillStyle='#c22'; ctx.fillRect(-10,-6,20,6); ctx.fillRect(-12,-2,24,2);
    } else {
      ctx.fillStyle='#f3a32d'; ctx.fillRect(-10,-6,20,6);
    }
    // phone in hand (bigger + blink)
    const blinking = nowMs() < phoneBlinkUntil && Math.floor(nowMs()/100)%2===0;
    ctx.fillStyle='#111';
    if (dir<0){
      ctx.fillRect(-20,12,10,16);
      ctx.fillStyle = blinking ? '#6ff' : '#09f';
      ctx.fillRect(-17,16,4,8);
    } else {
      ctx.fillRect(10,12,10,16);
      ctx.fillStyle = blinking ? '#6ff' : '#09f';
      ctx.fillRect(13,16,4,8);
    }
    ctx.globalAlpha=.2; ctx.fillStyle='#000'; if (dir<0) ctx.fillRect(-14,15,2,10); else ctx.fillRect(12,15,2,10);
    ctx.restore();
  }
  function skinColor(){
    const levels = ['#f1c08a','#f2b079','#f39f63','#f38f45'];
    return levels[Math.min(levels.length-1, player.tanLevel||0)];
  }
  function drawMette(x,y){
    // removed ground shadow per request
    const nod = Math.sin(nowMs()/1200 + (GL.mette.nodPhase||0)) * 0.5*CFG.SCALE;
    const offset = getInteractionOffset({type:'mette', x, y});
    ctx.save(); ctx.translate(x + offset.x, y-44*CFG.SCALE + nod + offset.y); ctx.scale(CFG.SCALE, CFG.SCALE);
    // dress with Danish flag motif (red with white cross)
    ctx.fillStyle='#c01818'; ctx.fillRect(-10,8,20,26);
    // vertical white stripe
    ctx.fillStyle='#fff'; ctx.fillRect(-2,8,4,26);
    // horizontal white stripe
    ctx.fillRect(-10,20,20,4);
    // legs
    ctx.fillStyle='#2b2b2b'; ctx.fillRect(-6,34,6,10); ctx.fillRect(0,34,6,10);
    // inner shirt
    ctx.fillStyle='#d7cce5'; ctx.fillRect(-7,12,14,16);
    // face + hair
    ctx.fillStyle='#f4c59a'; ctx.fillRect(-8,-2,16,12);
    // eyes
    if (!(GL.mette.blinkUntil && nowMs() < GL.mette.blinkUntil)){
      ctx.fillStyle='#111'; ctx.fillRect(-5,2,2,2); ctx.fillRect(3,2,2,2);
    } else { ctx.fillStyle='#111'; ctx.fillRect(-5,3,2,1); ctx.fillRect(3,3,2,1); }
    ctx.fillStyle='#5a4a2a'; ctx.fillRect(-9,-5,18,5);
    ctx.restore();
  }
  function drawBear(x,y,alive=true){
    // Check if custom bear image is available
    if (GRAPHICS.drawOrFallback(ctx, 'bear', drawBearFallback, x, y, alive)) {
      return; // Custom image was drawn successfully
    }
    
    drawBearFallback(x, y, alive);
  }
  
  function drawBearFallback(x,y,alive=true){
    const offset = getInteractionOffset({type:'bear', x, y});
    ctx.save(); ctx.translate(x + offset.x, y-30*CFG.SCALE + offset.y); ctx.scale(CFG.SCALE, CFG.SCALE);
    
    // Body
    ctx.fillStyle='#ffffff'; 
    ctx.fillRect(-30,10,60,18); // main body
    ctx.fillRect(-26,26,10,6); ctx.fillRect(-6,26,10,6); ctx.fillRect(14,26,10,6); // paws
    
    // Head - bigger when angry, faces direction (only check in Greenland scene)
    const facing = (scene === 'greenland' && GL.bear) ? (GL.bear.facing || 1) : 1;
    
    if (scene === 'greenland' && GL.bear && GL.bear.angry && alive) {
      // BIGGER ANGRY HEAD - position based on facing direction
      ctx.fillStyle='#ffffff';
      const headX = facing > 0 ? 18 : -42; // flip head position
      ctx.fillRect(headX,-8,24,20);   // much bigger head
      
      // ANGRY BEAR - RED EYES, BIG OPEN MOUTH WITH TEETH
      ctx.fillStyle='#ff0000'; // Red angry eyes  
      if (facing > 0) {
        // Facing right
        ctx.fillRect(36,4,6,5); ctx.fillRect(28,2,4,3); // bigger red eyes
        
        // Much bigger open mouth (black)
        ctx.fillStyle='#000';
        ctx.fillRect(24,8,14,8); // much wider and taller mouth
        
        // More sharp white teeth
        ctx.fillStyle='#fff';
        // Top row of teeth
        ctx.fillRect(25,8,2,4); ctx.fillRect(28,8,2,4); ctx.fillRect(31,8,2,4); ctx.fillRect(34,8,2,4); 
        // Bottom row of teeth  
        ctx.fillRect(26,12,2,4); ctx.fillRect(29,12,2,4); ctx.fillRect(32,12,2,4); ctx.fillRect(35,12,2,4);
        
        // Extra angry eyebrows
        ctx.fillStyle='#000';
        ctx.fillRect(26,0,6,2); ctx.fillRect(36,0,6,2); // bigger angry eyebrows
      } else {
        // Facing left - mirror everything
        ctx.fillRect(-42,4,6,5); ctx.fillRect(-32,2,4,3); // bigger red eyes (flipped)
        
        // Much bigger open mouth (black)
        ctx.fillStyle='#000';
        ctx.fillRect(-38,8,14,8); // much wider and taller mouth (flipped)
        
        // More sharp white teeth
        ctx.fillStyle='#fff';
        // Top row of teeth (flipped)
        ctx.fillRect(-37,8,2,4); ctx.fillRect(-34,8,2,4); ctx.fillRect(-31,8,2,4); ctx.fillRect(-28,8,2,4); 
        // Bottom row of teeth (flipped)
        ctx.fillRect(-36,12,2,4); ctx.fillRect(-33,12,2,4); ctx.fillRect(-30,12,2,4); ctx.fillRect(-27,12,2,4);
        
        // Extra angry eyebrows (flipped)
        ctx.fillStyle='#000';
        ctx.fillRect(-42,0,6,2); ctx.fillRect(-32,0,6,2); // bigger angry eyebrows
      }
      
    } else {
      // Normal smaller head - position based on facing direction  
      ctx.fillStyle='#ffffff';
      const headX = facing > 0 ? 22 : -38;
      ctx.fillRect(headX,0,16,12);   // normal head
      // Normal bear eyes - position based on facing
      ctx.fillStyle='#222'; 
      if (facing > 0) {
        ctx.fillRect(34,6,4,4); ctx.fillRect(30,4,2,2);
        
        if (!alive){ 
          ctx.fillStyle='#d33'; 
          ctx.fillRect(30,4,2,2); ctx.fillRect(34,6,4,1); 
        }
      } else {
        // Facing left - flipped eyes
        ctx.fillRect(-38,6,4,4); ctx.fillRect(-32,4,2,2);
        
        if (!alive){ 
          ctx.fillStyle='#d33'; 
          ctx.fillRect(-32,4,2,2); ctx.fillRect(-38,6,4,1); 
        }
      }
    }
    
    ctx.restore();
  }
  function drawBearHP(bear){
    if (!bear.alive) return;
    const hp = Math.max(0, bear.hp||2), max=2;
    const y = bear.y - 40*CFG.SCALE; const x = bear.x - (max*10*CFG.SCALE)/2;
    for (let i=0;i<max;i++){
      ctx.fillStyle = i < hp ? '#e33' : 'rgba(255,255,255,.35)';
      ctx.fillRect(x + i*10*CFG.SCALE, y, 8*CFG.SCALE, 4*CFG.SCALE);
    }
  }
  function drawMine(x,y){
    // Hole in the ice with depth
    const offset = getInteractionOffset({type:'mine', x, y});
    ctx.save(); ctx.translate(x + offset.x, y + offset.y); ctx.scale(CFG.SCALE, CFG.SCALE);
    // rim highlight
    ctx.fillStyle = '#cfeef9';
    ctx.beginPath(); ctx.ellipse(0, -2, 22, 7, 0, 0, Math.PI*2); ctx.fill();
    // top ellipse (opening)
    ctx.fillStyle = '#4a5f6a';
    ctx.beginPath(); ctx.ellipse(0, 0, 18, 6, 0, 0, Math.PI*2); ctx.fill();
    // depth (clipped rectangle)
    ctx.save();
    ctx.beginPath(); ctx.ellipse(0, 0, 18, 6, 0, 0, Math.PI*2); ctx.rect(-18,0,36,34); ctx.clip();
    const shaftDepth = Math.max(40, (H - y)/CFG.SCALE);
    const grad = ctx.createLinearGradient(0,0,0,shaftDepth);
    grad.addColorStop(0,'#22313b'); grad.addColorStop(1,'#0b0f12');
    ctx.fillStyle=grad; ctx.fillRect(-18,0,36,shaftDepth);
    // simple ladder rungs
    ctx.fillStyle='#8b6f3b'; for (let i=6;i<shaftDepth;i+=6){ ctx.fillRect(-4,i,8,2); }
    ctx.restore();
    // scattered ice chunks
    ctx.fillStyle='#a8d3e1'; ctx.fillRect(-20,2,4,2); ctx.fillRect(16,2,4,2);
    // wooden sign: "Rare minerals" (wider)
    const sx=36, sy=-4;
    ctx.fillStyle='#7b5a2b'; ctx.fillRect(sx, sy-30, 3, 30);
    ctx.fillStyle='#9b7a3e'; ctx.fillRect(sx-44, sy-50, 90, 22);
    ctx.strokeStyle='rgba(0,0,0,.25)'; ctx.strokeRect(sx-44, sy-50, 90, 22);
    ctx.fillStyle='#fff'; ctx.font='bold 10px system-ui'; ctx.textAlign='center';
    ctx.fillText('RARE MINERALS', sx, sy-36);
    ctx.textAlign='left';
    ctx.restore();
  }
  // y parameter is pole base (ground contact)
  function drawFlag(x,y){
    const poleH = 40*CFG.SCALE; const flagW = 36*CFG.SCALE; const flagH = 24*CFG.SCALE;
    // pole
    ctx.fillStyle='#666'; ctx.fillRect(x-2, y-poleH, 4, poleH);
    // flag top anchored near pole top
    const topY = y - poleH + 4*CFG.SCALE;
    const fx = x + 2;
    // stripes
    const stripes = 13; const stripeH = flagH/stripes;
    for (let i=0;i<stripes;i++){
      ctx.fillStyle = (i%2===0) ? '#bf0a30' : '#fff';
      ctx.fillRect(fx, topY + i*stripeH, flagW, stripeH);
    }
    // canton
    const cantonW = 14*CFG.SCALE; const cantonH = stripeH*7;
    ctx.fillStyle = '#002868';
    ctx.fillRect(fx, topY, cantonW, cantonH);
    // tiny stars
    ctx.fillStyle='#fff';
    for (let r=0;r<5;r++){
      for (let c=0;c<6;c++){
        const sx = fx + 2 + c* (cantonW/6);
        const sy = topY + 2 + r* (cantonH/5);
        ctx.fillRect(sx, sy, 1, 1);
      }
    }
  }
  function drawPhone(x,y){
    const offset = getInteractionOffset({type:'phone', x, y});
    ctx.save(); ctx.translate(x + offset.x, y-34*CFG.SCALE + offset.y); ctx.scale(CFG.SCALE, CFG.SCALE);
    ctx.fillStyle='#111'; ctx.fillRect(-8,0,16,28);
    ctx.fillStyle='#0af'; ctx.fillRect(-6,4,12,18);
    ctx.restore();
  }
  function drawPickup(it){
    const bob = Math.sin(nowMs()/600 + it.x*0.01)*4*CFG.SCALE;
    const px = it.x, py = it.y-26*CFG.SCALE + bob;
    // Try custom sprites based on item id
    if (it.id==='tan' && GRAPHICS.drawOrFallback(ctx, 'tan_bottle', () => {}, px, py)) return;
    if (it.id==='cl' && GRAPHICS.drawOrFallback(ctx, 'cl_trophy', () => {}, px, py)) return;
    if (it.id==='maga' && GRAPHICS.drawOrFallback(ctx, 'maga_cap', () => {}, px, py)) return;
    if (it.id==='dynamite' && GRAPHICS.drawOrFallback(ctx, 'dynamite', () => {}, px, py)) return;
    // Fallback vector icons
    ctx.save(); ctx.translate(px, py); ctx.scale(CFG.SCALE, CFG.SCALE);
    if (it.id==='tan'){ ctx.fillStyle='#8b5e3c'; ctx.fillRect(-8,8,16,10); ctx.fillStyle='#ccc'; ctx.fillRect(-6,4,12,6); }
    else if (it.id==='cl'){ ctx.fillStyle='#c0c8ff'; ctx.fillRect(-10,2,20,20); ctx.fillStyle='#ffd700'; ctx.fillRect(-6,0,12,4); }
    else if (it.id==='maga'){ ctx.fillStyle='#c22'; ctx.fillRect(-12,10,24,8); ctx.fillRect(-10,4,20,6); }
    else if (it.id==='dynamite'){ ctx.fillStyle='#d32f2f'; ctx.fillRect(-6,0,12,20); ctx.fillStyle='#333'; ctx.fillRect(-6,6,12,2); ctx.fillRect(-6,12,12,2); }
    ctx.restore();
  }
  function drawGoldBar(goldBar){
    // gentle float/bob like pickups
    const bob = Math.sin(nowMs()/400 + goldBar.x*0.01)*3*CFG.SCALE;
    ctx.save(); ctx.translate(goldBar.x, goldBar.y-20*CFG.SCALE + bob); ctx.scale(CFG.SCALE, CFG.SCALE);
    
    // 3D Gold bar design (no text on bar itself)
    // Bottom/side shadow (darker gold)
    ctx.fillStyle='#cc9900';
    ctx.fillRect(-8, -2, 16, 8); // bottom part
    ctx.fillRect(6, -4, 2, 6);   // right side edge
    
    // Main body (bright gold)
    ctx.fillStyle='#ffd700';
    ctx.fillRect(-8, -4, 14, 6);
    
    // Top surface highlight (lighter gold)
    ctx.fillStyle='#ffed4e';
    ctx.fillRect(-8, -4, 14, 3); // top surface
    ctx.fillRect(-8, -6, 2, 2);  // left edge highlight
    
    ctx.restore();
  }
  function drawRig(x,y){
    // Oil rig silhouette aligned to ground (no shadow)
    ctx.save(); ctx.translate(x, y-78*CFG.SCALE); ctx.scale(CFG.SCALE, CFG.SCALE);
    // base
    ctx.fillStyle='#111'; ctx.fillRect(-36,70,72,8); ctx.fillRect(-30,62,60,6);
    // tower legs (triangular)
    ctx.fillStyle='#222';
    ctx.fillRect(-22,10,4,52); ctx.fillRect(18,10,4,52);
    // cross braces
    ctx.strokeStyle='#222'; ctx.lineWidth=4; ctx.beginPath();
    ctx.moveTo(-22,12); ctx.lineTo(18,36); ctx.moveTo(-22,36); ctx.lineTo(18,60);
    ctx.moveTo(18,12); ctx.lineTo(-22,36); ctx.moveTo(18,36); ctx.lineTo(-22,60);
    ctx.stroke();
    // central column
    ctx.fillStyle='#1a1a1a'; ctx.fillRect(-3,4,6,62);
    // top cap
    ctx.fillStyle='#1a1a1a'; ctx.fillRect(-16,-6,32,12); ctx.fillRect(-20,6,40,4);
    ctx.restore();
  }
  function drawHeli(x,y,spin=0.35){
    // Check if custom helicopter image is available
    if (GRAPHICS.drawOrFallback(ctx, 'helicopter', drawHeliFallback, x, y, spin)) {
      return; // Custom image was drawn successfully
    }
    
    drawHeliFallback(x, y, spin);
  }
  
  function drawHeliFallback(x,y,spin=0.35){
    ctx.save(); ctx.translate(x, y); ctx.scale(CFG.SCALE, CFG.SCALE);
    // krop
    ctx.fillStyle='#2c3e50'; ctx.fillRect(-40,-10,100,28); // body
    // cockpit
    ctx.fillStyle='#86d0ff'; ctx.fillRect(46,-6,10,16);
    // rotor
    ctx.fillStyle='#333'; ctx.fillRect(6,-18,4,8); ctx.fillRect(-40,-22,140,4);
    // subtle rotor blur
    const t = nowMs();
    const alpha = Math.min(1, Math.max(0, spin));
    ctx.globalAlpha = 0.18 * alpha; ctx.fillStyle = '#000';
    const blurW = 160 + Math.sin(t/80)*8; ctx.fillRect(-blurW/2, -23, blurW, 6);
    ctx.globalAlpha = 1;
    // ben
    ctx.fillStyle='#333'; ctx.fillRect(-30,18,60,4); ctx.fillRect(20,18,40,4);
    ctx.restore();
  }
  function playEntryHeli(line, stopX){
    entryHeli.active = true; entryHeli.line = line || '';
    entryHeli.vertical = true;
    // Fixed stop X like Greenland, descend from above screen
    entryHeli.targetX = (typeof stopX === 'number') ? stopX : 160*CFG.SCALE;
    entryHeli.x = entryHeli.targetX;
    entryHeli.startY = -200*CFG.SCALE;
    entryHeli.targetY = (H - world.floor) - 18*CFG.SCALE;
    entryHeli.y = entryHeli.startY;
    entryHeli.start = nowMs(); entryHeli.dur = 1600;
  }
  // Intro: land helicopter from offscreen and have Trump step out
  function scheduleHeliIntro(line){
    // Use the same vertical entry animation as other scenes
    playEntryHeli(line || 'Perfect landing! Helicopter takes us anywhere.', 160*CFG.SCALE);
  }
  function drawBerg(cx,cy,w,h){ ctx.beginPath(); ctx.moveTo(cx-w/2, cy+h/2); ctx.lineTo(cx, cy-h/2); ctx.lineTo(cx+w/2, cy+h/2); ctx.closePath(); ctx.fill(); }
  
  function drawGlacier(x, y, w, h, blown = false) {
    if (blown) return; // Don't draw if blown up
    
    const offset = getInteractionOffset({type:'glacier', x, y});
    ctx.save(); 
    ctx.translate(x + offset.x, y + offset.y); 
    ctx.scale(CFG.SCALE, CFG.SCALE);
    // Optional glacier sprite override
    if (GRAPHICS.imageReady('glacier')) {
      const img = GRAPHICS.images.get('glacier');
      const gw = w, gh = h;
      ctx.drawImage(img, -gw/2, -gh/2, gw, gh);
      ctx.restore();
      return;
    }
    
    // Large glacier - more detailed than small bergs
    ctx.fillStyle='#e8f4f8';
    ctx.beginPath();
    ctx.moveTo(-w/2, h/2);
    ctx.lineTo(-w/3, -h/2);
    ctx.lineTo(0, -h/2 - 20);
    ctx.lineTo(w/3, -h/2);
    ctx.lineTo(w/2, h/2);
    ctx.closePath();
    ctx.fill();
    
    // Shading/details
    ctx.fillStyle='#d0e8f0';
    ctx.beginPath();
    ctx.moveTo(-w/4, 0);
    ctx.lineTo(-w/6, -h/3);
    ctx.lineTo(w/6, -h/3);
    ctx.lineTo(w/4, 0);
    ctx.closePath();
    ctx.fill();
    
    ctx.restore();
  }

  // Oval Office
  function drawOvalBackdrop(){
    // v√¶g
    ctx.fillStyle='#f4efe3'; ctx.fillRect(0,0,W,H);
    // vinduer
    ctx.fillStyle='#bcdfff'; for (let i=0;i<3;i++){ const x=380*CFG.SCALE + i*160*CFG.SCALE; ctx.fillRect(x,100*CFG.SCALE,90*CFG.SCALE,140*CFG.SCALE); }
    // paintings with golden frames
    const pY = 90*CFG.SCALE, pW=80*CFG.SCALE, pH=60*CFG.SCALE;
    const frames = [140*CFG.SCALE, 240*CFG.SCALE, 1040*CFG.SCALE];
    frames.forEach(px=>{
      ctx.fillStyle='#c9a641'; ctx.fillRect(px-6, pY-6, pW+12, pH+12);
      ctx.fillStyle='#fdf6e3'; ctx.fillRect(px, pY, pW, pH);
      ctx.fillStyle='#6b8fd6'; ctx.fillRect(px+10, pY+10, pW-20, 12);
      ctx.fillStyle='#d66b6b'; ctx.fillRect(px+10, pY+30, pW-40, 10);
      ctx.fillStyle='#6bd68c'; ctx.fillRect(px+24, pY+48, pW-48, 6);
    });
    // t√¶ppe (larger carpet with soft shadow)
    ctx.fillStyle='#d4c6a6'; ctx.fillRect(0,H-world.floor,W,world.floor);
    // carpet shadow ellipse
    ctx.save(); ctx.globalAlpha=0.18; ctx.fillStyle='#000';
    ctx.beginPath(); ctx.ellipse(W/2, H - world.floor + 60*CFG.SCALE, 200*CFG.SCALE, 40*CFG.SCALE, 0, 0, Math.PI*2); ctx.fill(); ctx.restore();
    // simple presidential seal on carpet (subtle)
    const cy = H - world.floor + 56*CFG.SCALE, cx = W/2;
    ctx.save();
    ctx.translate(cx, cy); ctx.scale(CFG.SCALE, CFG.SCALE);
    ctx.globalAlpha = 0.22; ctx.fillStyle = '#1e3a5f';
    ctx.beginPath(); ctx.arc(0,0,38,0,Math.PI*2); ctx.fill();
    ctx.globalAlpha = 0.9; ctx.strokeStyle='#f6e27d'; ctx.lineWidth=2; ctx.beginPath(); ctx.arc(0,0,40,0,Math.PI*2); ctx.stroke();
    // tiny eagle
    ctx.globalAlpha = 0.9; ctx.fillStyle='#f6e27d';
    ctx.fillRect(-4,-4,8,8); ctx.fillRect(-10,-2,6,4); ctx.fillRect(4,-2,6,4);
    ctx.restore();
    // (Desk body drawn later after Trump for proper layering)
  }

  // Draw desk body (panel/top/legs) and on‚Äëdesk buttons so Trump appears behind it
  function drawOvalDesk(){
    const y = H - world.floor + 30*CFG.SCALE;
    const deskX = 420*CFG.SCALE, deskW = 340*CFG.SCALE;
    // body and top
    ctx.fillStyle='#7a4a22'; ctx.fillRect(deskX, y-40*CFG.SCALE, deskW, 80*CFG.SCALE);
    ctx.fillStyle='#8a5a2a'; ctx.fillRect(deskX-8, y-44*CFG.SCALE, deskW+16, 8*CFG.SCALE);
    // legs
    ctx.fillStyle='#6b3e18';
    ctx.fillRect(deskX+12, y+40*CFG.SCALE, 16*CFG.SCALE, 20*CFG.SCALE);
    ctx.fillRect(deskX+deskW-28*CFG.SCALE, y+40*CFG.SCALE, 16*CFG.SCALE, 20*CFG.SCALE);
    // drawer seams + handles
    ctx.strokeStyle='#5e3415'; ctx.lineWidth=2; ctx.beginPath();
    ctx.moveTo(deskX+deskW*0.33, y-8*CFG.SCALE); ctx.lineTo(deskX+deskW*0.33, y+36*CFG.SCALE);
    ctx.moveTo(deskX+deskW*0.66, y-8*CFG.SCALE); ctx.lineTo(deskX+deskW*0.66, y+36*CFG.SCALE);
    ctx.stroke();
    ctx.fillStyle='#d4af37'; ctx.fillRect(deskX+deskW*0.33-4, y+8*CFG.SCALE, 8, 4); ctx.fillRect(deskX+deskW*0.66-4, y+8*CFG.SCALE, 8, 4);
    // buttons sitting ON the slim top board (y-44..y-36)
    OV.buttons.forEach((b,i)=>{
      const topY = y-44*CFG.SCALE; // top board upper edge
      ctx.save(); ctx.translate(b.x, topY);
      // base (mount) sits inside the 8px top thickness
      const baseH = 4; ctx.fillStyle='#5a4632'; ctx.fillRect(-b.w/2, 0, b.w, baseH);
      
      // cap rises above the top surface - adjust position if pressed
      const pressOffset = b.pressed ? 3 : 0; // Push down when pressed
      const capHeight = b.pressed ? b.h - 2 : b.h; // Slightly shorter when pressed
      ctx.fillStyle = b.pressed ? darkenColor(b.color) : b.color;
      ctx.fillRect(-b.w/2+2, -capHeight-2+pressOffset, b.w-4, capHeight);
      
      // highlight on cap - dimmer when pressed
      ctx.globalAlpha = b.pressed ? 0.1 : 0.25; 
      ctx.fillStyle='#fff'; 
      ctx.fillRect(-b.w/2+4, -capHeight+pressOffset, b.w-8, 2);
      ctx.restore();
    });
  }
  function drawKremlinBackdrop(){
    // walls
    ctx.fillStyle='#f2e6e6'; ctx.fillRect(0,0,W,H);
    // red drapes
    ctx.fillStyle='#b33'; for(let i=0;i<4;i++){ const x=300*CFG.SCALE + i*160*CFG.SCALE; ctx.fillRect(x,80*CFG.SCALE,80*CFG.SCALE,160*CFG.SCALE); }
    // Stalin pictogram in golden frame
    const fx = 160*CFG.SCALE, fy = 90*CFG.SCALE, fw = 90*CFG.SCALE, fh = 70*CFG.SCALE;
    ctx.fillStyle='#c9a641'; ctx.fillRect(fx-6, fy-6, fw+12, fh+12);
    ctx.fillStyle='#f5efe1'; ctx.fillRect(fx, fy, fw, fh);
    ctx.fillStyle='#333'; ctx.fillRect(fx+fw*0.35, fy+fh*0.28, fw*0.3, fh*0.38);
    ctx.fillRect(fx+fw*0.42, fy+fh*0.12, fw*0.16, fh*0.18);
    // carpet
    ctx.fillStyle='#8b0000'; ctx.fillRect(0,H-world.floor,W,world.floor);
    // long black table (main body only - top edge drawn later)
    const y = H - world.floor + 24*CFG.SCALE;
    const tx = 300*CFG.SCALE, tw = (W - 2*300*CFG.SCALE), th = 60*CFG.SCALE;
    ctx.fillStyle='#111'; ctx.fillRect(tx, y-30*CFG.SCALE, tw, th);
    // framed border map if drawn
    if (KR.border && KR.border.length>1){
      const mw=120*CFG.SCALE, mh=80*CFG.SCALE, mx=W - 220*CFG.SCALE, my=100*CFG.SCALE;
      ctx.fillStyle='#c9a641'; ctx.fillRect(mx-6,my-6,mw+12,mh+12);
      ctx.fillStyle='#f5efe1'; ctx.fillRect(mx,my,mw,mh);
      // draw stored polyline
      ctx.strokeStyle='#222'; ctx.lineWidth=3; ctx.beginPath();
      ctx.moveTo(mx + KR.border[0].x*mw, my + KR.border[0].y*mh);
      for (let i=1;i<KR.border.length;i++) ctx.lineTo(mx + KR.border[i].x*mw, my + KR.border[i].y*mh);
      ctx.stroke(); ctx.strokeStyle='#ffd54f'; ctx.lineWidth=2; ctx.stroke();
    }
  }
  function drawDoor(x,y){
    ctx.save(); ctx.translate(x, y-80*CFG.SCALE); ctx.scale(CFG.SCALE, CFG.SCALE);
    ctx.fillStyle='#ddd'; ctx.fillRect(-14,0,28,80); ctx.fillStyle='#bbb'; ctx.fillRect(10,34,4,8);
    ctx.restore();
  }
  function drawAide(x,y){
    ctx.save(); ctx.translate(x, y-44*CFG.SCALE); ctx.scale(CFG.SCALE, CFG.SCALE);
    ctx.fillStyle='#223'; ctx.fillRect(-10,8,20,26);
    ctx.fillStyle='#e8d7c2'; ctx.fillRect(-8,-2,16,12);
    ctx.fillStyle='#444'; ctx.fillRect(-9,-5,18,5);
    ctx.restore();
  }
  function drawYesGroup(x,y){
    // If a custom sprite is provided for group members, draw three of them
    if (GRAPHICS.imageReady('yes_member')){
      const spacing = 34*CFG.SCALE;
      GRAPHICS.drawImage(ctx, GRAPHICS.images.get('yes_member'), x - spacing, y - 22*CFG.SCALE, null, null, true);
      GRAPHICS.drawImage(ctx, GRAPHICS.images.get('yes_member'), x,             y - 22*CFG.SCALE, null, null, true);
      GRAPHICS.drawImage(ctx, GRAPHICS.images.get('yes_member'), x + spacing, y - 22*CFG.SCALE, null, null, true);
      return;
    }
    const men = OV.yes.members || [];
    const spacing = 34*CFG.SCALE;
    const praising = OV.yes.speakingUntil > nowMs();
    for (let i=0;i<3;i++){
      const m = men[i] || { blinkUntil:0, nodPhase:i, isF: i===1 };
      const dx = x + (-spacing + i*spacing);
      // amplify nod a bit so it reads
      const nod = Math.sin(nowMs()/900 + (m.nodPhase||0))*1.0*CFG.SCALE;
      ctx.save(); ctx.translate(dx, y-44*CFG.SCALE + nod); ctx.scale(CFG.SCALE, CFG.SCALE);
      const suits = ['#3a3a5a','#2a4a2a','#4a2a2a'];
      // legs
      ctx.fillStyle='#2b2b2b'; ctx.fillRect(-10,34,9,10); ctx.fillRect(2,34,9,10);
      // torso/dress (left woman = pink w/o flag, right woman = red flag dress)
      if (m.isF){
        if (i===0){ ctx.fillStyle='#e91e63'; ctx.fillRect(-10,8,20,26); }
        else { ctx.fillStyle='#c01818'; ctx.fillRect(-10,8,20,26); ctx.fillStyle='#fff'; ctx.fillRect(-2,8,4,26); ctx.fillRect(-10,20,20,4); }
      }
      else { ctx.fillStyle=suits[i%3]; ctx.fillRect(-10,8,20,26); }
      // head
      ctx.fillStyle='#e8d7c2'; ctx.fillRect(-8,-2,16,12);
      // eyes (blink)
      if (!(m.blinkUntil && nowMs() < m.blinkUntil)){
        ctx.fillStyle='#111'; ctx.fillRect(-5,2,2,2); ctx.fillRect(3,2,2,2);
      } else {
        ctx.fillStyle='#111'; ctx.fillRect(-5,3,2,1); ctx.fillRect(3,3,2,1);
      }
      // hair (long hair for women)
      if (m.isF){
        ctx.fillStyle='#6b4328';
        ctx.fillRect(-9,-5,18,5);            // top
        ctx.fillRect(-10,-2,4,16);           // left strand
        ctx.fillRect(6,-2,4,16);             // right strand
      } else {
        ctx.fillStyle='#444'; ctx.fillRect(-9,-5,18,5);
      }
      // arms: raise when praising
      ctx.globalAlpha=0.9; ctx.fillStyle=suits[i%3];
      if (praising){
        // raised arms near head
        ctx.fillRect(-14,0,4,14); // left up
        ctx.fillRect(10,0,4,14);  // right up
      } else {
        // down arms along sides
        ctx.globalAlpha=.2; ctx.fillStyle='#000';
        ctx.fillRect(-14,15,2,10); ctx.fillRect(12,15,2,10);
      }
      ctx.restore();
    }
  }
  function drawTesla(x,y){
    // align wheels to ground y; larger car
    ctx.save(); ctx.translate(x, y-12*CFG.SCALE); ctx.scale(CFG.SCALE, CFG.SCALE);
    // wheels
    ctx.fillStyle='#111'; ctx.beginPath(); ctx.arc(-20,12,5,0,Math.PI*2); ctx.arc(20,12,5,0,Math.PI*2); ctx.fill();
    // body
    ctx.fillStyle='#c00'; ctx.fillRect(-36,-2,72,18);
    // window strip
    ctx.fillStyle='#222'; ctx.fillRect(-28,-4,56,6);
    // Tesla logo (stylized T)
    ctx.fillStyle='#fff'; ctx.fillRect(-2,0,4,8); ctx.fillRect(-10,-2,20,2);
    ctx.restore();
  }
  function drawButton(x,y,color,label){
    const offset = getInteractionOffset({type:'button', x, y});
    ctx.save(); ctx.translate(x + offset.x, y-10*CFG.SCALE + offset.y); ctx.scale(CFG.SCALE, CFG.SCALE);
    ctx.fillStyle='#444'; ctx.fillRect(-16,10,32,8);
    ctx.fillStyle=color; ctx.fillRect(-14,4,28,8);
    ctx.fillStyle='#fff'; ctx.font='bold 8px system-ui'; ctx.textAlign='center';
    ctx.fillText(label, 0, 0);
    ctx.restore();
  }

  // praising lines for the yes-choir
  const PRAISE = [
    'Genius move, sir!',
    'Historic leadership!',
    'Best decision ever!',
    'Total victory!',
    'Markets love it!'
  ];
  function praiseChoir(){
    const line = PRAISE[Math.floor(Math.random()*PRAISE.length)];
    OV.yes.say = line; OV.yes.speakingUntil = nowMs()+1200;
  }
  function pickRandomCountry(){
    const arr = ['Canada','Mexico','Germany','France','Denmark','China','India','Brazil','Japan','Australia','Norway','Sweden','Finland','UK','Italy'];
    return arr[Math.floor(Math.random()*arr.length)];
  }
  function drawPutin(x,y){
    const nod = Math.sin(nowMs()/1150 + (KR.putin.nodPhase||0)) * 0.4*CFG.SCALE;
    ctx.save(); ctx.translate(x, y-44*CFG.SCALE + nod); ctx.scale(CFG.SCALE, CFG.SCALE);
    ctx.fillStyle='#223'; ctx.fillRect(-10,8,20,26);
    // Ben
    ctx.fillStyle='#111'; ctx.fillRect(-7,34,5,10); // venstre ben
    ctx.fillStyle='#111'; ctx.fillRect(2,34,5,10);  // h√∏jre ben
    ctx.fillStyle='#e6c9a8'; ctx.fillRect(-8,-2,16,12);
    if (!(KR.putin.blinkUntil && nowMs() < KR.putin.blinkUntil)){
      ctx.fillStyle='#111'; ctx.fillRect(-5,2,2,2); ctx.fillRect(3,2,2,2);
    } else { ctx.fillStyle='#111'; ctx.fillRect(-5,3,2,1); ctx.fillRect(3,3,2,1); }
    ctx.fillStyle='#c2a26a'; ctx.fillRect(-9,-5,18,5);
    ctx.restore();
  }
  function drawGoldStatue(x,y,variant=1){
    ctx.save(); ctx.translate(x, y-30*CFG.SCALE); ctx.scale(CFG.SCALE, CFG.SCALE);
    // pedestal
    ctx.fillStyle='#8a6b2f'; ctx.fillRect(-10,16,20,6);
    // statue variants
    ctx.fillStyle='#d4af37';
    if (variant===1){ ctx.fillRect(-3,0,6,14); ctx.fillRect(-8,6,16,6); ctx.fillRect(-2,-6,4,6); }
    else if (variant===2){ ctx.fillRect(-2,0,4,14); ctx.fillRect(-10,8,20,4); ctx.fillRect(-2,-4,4,4); }
    else { ctx.fillRect(-4,2,8,12); ctx.fillRect(-2,-2,4,4); }
    ctx.restore();
  }

  function updateSecurityCamera() {
    const now = nowMs();
    const elapsed = (now - KR.camera.sweepStart) / 1000; // seconds
    const sweepDuration = 8; // 8 seconds for full sweep in one direction
    const fullCycle = sweepDuration * 2; // 16 seconds for full back-and-forth cycle
    
    // Calculate which part of cycle we're in
    const cycleProgress = (elapsed % fullCycle) / fullCycle;
    
    let sweepProgress;
    if (cycleProgress < 0.5) {
      // First half: left to right
      sweepProgress = cycleProgress * 2; // 0 to 1
    } else {
      // Second half: right to left  
      sweepProgress = 2 - (cycleProgress * 2); // 1 to 0
    }
    
    // Calculate sweep angle (30¬∞ to 150¬∞)
    KR.camera.angle = Math.PI/6 + (2*Math.PI/3) * sweepProgress;
  }

  function drawSecurityCamera() {
    updateSecurityCamera();
    
    const cam = KR.camera;
    
    // Draw camera body (3x larger)
    ctx.save();
    ctx.translate(cam.x, cam.y);
    
    // Camera housing (3x size)
    ctx.fillStyle = '#333';
    ctx.fillRect(-24*CFG.SCALE, -18*CFG.SCALE, 48*CFG.SCALE, 36*CFG.SCALE);
    
    // Camera lens - fixed at top center of housing (3x size)
    ctx.fillStyle = '#111';
    ctx.beginPath();
    ctx.arc(0, -18*CFG.SCALE, 12*CFG.SCALE, 0, Math.PI*2);
    ctx.fill();
    
    // Red light when active - fixed position on lens
    ctx.fillStyle = '#ff0000';
    ctx.beginPath();
    ctx.arc(0, -18*CFG.SCALE, 4.5*CFG.SCALE, 0, Math.PI*2);
    ctx.fill();
    
    // Direction indicator (small line showing where camera points)
    ctx.strokeStyle = '#ff0000';
    ctx.lineWidth = 3;
    ctx.beginPath();
    const indicatorLength = 20*CFG.SCALE;
    const endX = Math.cos(cam.angle) * indicatorLength;
    const endY = Math.sin(cam.angle) * indicatorLength;
    ctx.moveTo(0, -18*CFG.SCALE);
    ctx.lineTo(endX, -18*CFG.SCALE + endY);
    ctx.stroke();
    
    ctx.restore();
    
    // Note: Laser cone is now drawn separately after depth sorting to be on top of everything
  }

  function drawLaserCone(x, y, angle) {
    // Calculate laser length to reach the floor
    const floorY = H - world.floor;
    const distanceToFloor = floorY - y;
    const coneLength = distanceToFloor / Math.sin(Math.abs(angle)) * 1.5; // Extended to ensure it reaches floor
    const coneWidth = Math.PI/8; // 22.5 degrees cone width
    
    // Calculate cone points
    const endX = x + Math.cos(angle) * coneLength;
    const endY = y + Math.sin(angle) * coneLength;
    
    const leftAngle = angle - coneWidth/2;
    const rightAngle = angle + coneWidth/2;
    
    const leftX = x + Math.cos(leftAngle) * coneLength;
    const leftY = y + Math.sin(leftAngle) * coneLength;
    const rightX = x + Math.cos(rightAngle) * coneLength;
    const rightY = y + Math.sin(rightAngle) * coneLength;
    
    // Draw laser cone
    ctx.save();
    ctx.fillStyle = 'rgba(255, 0, 0, 0.15)';
    ctx.strokeStyle = 'rgba(255, 0, 0, 0.4)';
    ctx.lineWidth = 2;
    
    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.lineTo(leftX, leftY);
    ctx.lineTo(rightX, rightY);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
    
    // Center beam
    ctx.strokeStyle = 'rgba(255, 0, 0, 0.8)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.lineTo(endX, endY);
    ctx.stroke();
    
    ctx.restore();
  }

  function isStatueUnderSurveillance(statue) {
    const cam = KR.camera;
    const coneWidth = Math.PI/8; // Same as in drawLaserCone
    
    // Use lens position (same as laser cone)
    const lensX = cam.x;
    const lensY = cam.y - 18*CFG.SCALE;
    
    // Calculate angle from lens to statue
    const dx = statue.x - lensX;
    const dy = statue.y - lensY;
    const statueAngle = Math.atan2(dy, dx);
    
    // Normalize angles to 0-2PI range
    const normalizeAngle = (a) => {
      while (a < 0) a += Math.PI * 2;
      while (a >= Math.PI * 2) a -= Math.PI * 2;
      return a;
    };
    
    const camAngle = normalizeAngle(cam.angle);
    const targetAngle = normalizeAngle(statueAngle);
    
    // Calculate angular difference
    let diff = Math.abs(camAngle - targetAngle);
    if (diff > Math.PI) diff = Math.PI * 2 - diff;
    
    // Check if statue is within camera cone
    const isInCone = diff <= coneWidth/2;
    
    // Debug info
    if (CFG.DEBUG) console.log(`Statue surveillance check: angle diff ${(diff * 180/Math.PI).toFixed(1)}¬∞, inCone: ${isInCone}`);
    
    return isInCone;
  }

  function triggerSecurityDiscovery(statue) {
    if (CFG.DEBUG) console.log('üö® SECURITY DISCOVERY TRIGGERED! üö®');
    
    // Set discovery state
    KR.camera.discovered = true;
    
    // Putin reacts immediately
    KR.putin.speakingUntil = nowMs() + 2500;
    KR.putin.say = 'SECURITY ALERT! We have a thief!';
    
    // Trump's panicked response
    say(player, 'This is fake surveillance!', 2000);
    
    // Damage relationship severely
    adjustRelationship('putin', {respect: -15, trust: -20, fear: 5}, 'caught_stealing');
    
    // Spawn guards from door
    spawnSecurityGuards();
    
    // Screen flash effect (handled in render loop)
    KR.camera.flashUntil = nowMs() + 500;
    
    // Reset discovery state after a while
    setTimeout(() => {
      KR.camera.discovered = false;
      if (CFG.DEBUG) console.log('Discovery state reset');
    }, 5000);
  }

  function spawnSecurityGuards() {
    // For now, just show Putin's angry reaction and relationship damage
    // Future: could spawn actual guard sprites that walk in
    if (CFG.DEBUG) console.log('üî¥ Guards would spawn here!');
    
    // Additional Putin dialogue
    setTimeout(() => {
      if (KR.putin.speakingUntil < nowMs() + 1000) {
        KR.putin.speakingUntil = nowMs() + 2000;
        KR.putin.say = 'Security has been notified!';
      }
    }, 1500);
  }

  // ---------- Bear AI and Physics ----------
  function updateBearAI(dt, ground) {
    if (!GL.bear || !GL.bear.alive) return;
    
    GL.bear.vx = GL.bear.vx || 0; GL.bear.vy = GL.bear.vy || 0;
    
    // Chasing AI - if angry and on ground, chase Trump! (Only after HP reaches 0)  
    if (GL.bear.angry && GL.bear.chasing && GL.bear.hp <= 0 && GL.bear.y >= ground - 5*CFG.SCALE) {
      updateBearChaseLogic(dt);
    }
    
    updateBearPhysics(dt, ground);
  }
  
  function updateBearChaseLogic(dt) {
    const distToTrump = player.x - GL.bear.x;
    const chaseSpeed = GL.bear.speed * CFG.SCALE * dt;
    
    // Face Trump direction
    GL.bear.facing = distToTrump > 0 ? 1 : -1;
    
    // Move towards Trump
    if (Math.abs(distToTrump) > GAME_CONSTANTS.PHYSICS.BEAR_CHASE_DISTANCE*CFG.SCALE) {
      if (distToTrump > 0) {
        GL.bear.vx += chaseSpeed; // Chase right
      } else {
        GL.bear.vx -= chaseSpeed; // Chase left  
      }
      // Cap chase speed
      const maxSpeed = GL.bear.speed * CFG.SCALE;
      GL.bear.vx = Math.max(-maxSpeed, Math.min(maxSpeed, GL.bear.vx));
    } else {
      // Close enough - try to attack!
      if (Math.random() < GAME_CONSTANTS.PHYSICS.BEAR_ATTACK_CHANCE) {
        executeBearAttack(distToTrump);
      }
    }
  }
  
  function executeBearAttack(distToTrump) {
    say(GL.bear, "CHOMP! ü¶∑", 800);
    spawnBlood(player.x, player.y - 10*CFG.SCALE, 8);
    // Push Trump away
    const pushDir = Math.sign(distToTrump) || 1;
    nudge(player, pushDir * GAME_CONSTANTS.PHYSICS.HORIZONTAL_KNOCKBACK*CFG.SCALE, -20*CFG.SCALE, 200);
    SFX.error();
    
    // Lose some health or game over if caught too many times
    bumpDoom(15, "üêª Bear attack!");
    
    // Check if bear has eaten Trump (high doom from bear attacks)
    if (GS.doom >= GAME_CONSTANTS.GAME.DOOM_HIGH) {
      setTimeout(() => {
        gameOver('üêª Isbj√∏rnen har spist Trump.\nNu g√•r verden ikke under alligevel! üåç');
      }, 1000);
    }
  }
  
  function updateBearPhysics(dt, ground) {
    // Apply physics
    const g = GAME_CONSTANTS.PHYSICS.GRAVITY * dt; // gravity px/s^2 scaled by dt
    GL.bear.vy += g;
    
    // Update position
    GL.bear.y += GL.bear.vy * dt;
    GL.bear.x += GL.bear.vx * dt;
    
    // Horizontal damping (less when chasing)
    const dampingFactor = GL.bear.chasing ? GAME_CONSTANTS.PHYSICS.CHASE_DAMPING : GAME_CONSTANTS.PHYSICS.NORMAL_DAMPING;
    GL.bear.vx *= dampingFactor;
    
    // Ground collision with improved detection
    if (GL.bear.y >= ground) { 
      GL.bear.y = ground; 
      GL.bear.vy = 0;
      // Extra damping when on ground to prevent sliding (less when chasing)
      GL.bear.vx *= GL.bear.chasing ? GAME_CONSTANTS.PHYSICS.GROUND_DAMPING_CHASE : GAME_CONSTANTS.PHYSICS.GROUND_DAMPING_NORMAL;
    }
    
    // Screen bounds to prevent getting stuck off-screen
    const minX = GAME_CONSTANTS.PHYSICS.SCREEN_MARGIN*CFG.SCALE, 
          maxX = W - GAME_CONSTANTS.PHYSICS.SCREEN_MARGIN*CFG.SCALE;
    if (GL.bear.x < minX) {
      GL.bear.x = minX;
      GL.bear.vx = Math.abs(GL.bear.vx) * GAME_CONSTANTS.PHYSICS.BOUNCE_DAMPING; // bounce back gently
    }
    if (GL.bear.x > maxX) {
      GL.bear.x = maxX;
      GL.bear.vx = -Math.abs(GL.bear.vx) * GAME_CONSTANTS.PHYSICS.BOUNCE_DAMPING; // bounce back gently
    }
  }

  // ---------- Actors update ----------
  function updateActors(dt){
    // Bear physics and AI - only in Greenland scene
    if (scene === 'greenland') {
      const ground = H - world.floor;
      updateBearAI(dt, ground);
    } // End greenland scene check
    // clouds (parallax)
    if (CLOUDS && CLOUDS.length){
      CLOUDS.forEach(c=>{ c.x += c.vx*dt; if (c.x > W + c.w) c.x = -c.w; });
    }
    // schedule blinks
    const tnow = nowMs();
    function updBlink(o){
      if (!o) return;
      if (!o.nextBlink || tnow > o.nextBlink){
        o.blinkUntil = tnow + 120;
        // next blink 2‚Äì4.5s later
        o.nextBlink = tnow + 2000 + Math.random()*2500;
      }
    }
    updBlink(player);
    updBlink(GL.mette);
    updBlink(KR.putin);
    // yes-men
    if (OV.yes && OV.yes.members){ OV.yes.members.forEach(m=>{ if (!m.nextBlink || tnow>m.nextBlink){ m.blinkUntil = tnow+120; m.nextBlink = tnow + 2000 + Math.random()*2500; } }); }
  }

  // ---------- FX update/draw ----------
  function updateFx(dt){
    // blood - optimized with object pooling
    const g = 220*CFG.SCALE; // gravity-ish
    const deadBlood = [];
    fx.blood = fx.blood.filter(p => {
      p.life -= dt*1000;
      if (p.life <= 0) {
        deadBlood.push(p);
        return false;
      }
      return true;
    });
    deadBlood.forEach(p => returnParticle('blood', p));
    fx.blood.forEach(p => {
      p.vy += g*dt*0.6;
      p.x += p.vx*dt;
      p.y += p.vy*dt;
    });
    
    // sparks - optimized with object pooling
    const gs = 380*CFG.SCALE;
    const deadSparks = [];
    fx.sparks = fx.sparks.filter(p => {
      p.life -= dt*1000;
      if (p.life <= 0) {
        deadSparks.push(p);
        return false;
      }
      return true;
    });
    deadSparks.forEach(p => returnParticle('sparks', p));
    fx.sparks.forEach(p => {
      p.vy += gs*dt*0.5;
      p.vx *= 0.98; p.vy *= 0.98;
      p.x += p.vx*dt; p.y += p.vy*dt;
    });
    
    // contamination particles
    if (fx.contamination) {
      const deadContamination = [];
      fx.contamination = fx.contamination.filter(p => {
        p.life -= dt*1000;
        if (p.life <= 0) {
          deadContamination.push(p);
          return false;
        }
        return true;
      });
      deadContamination.forEach(p => returnParticle('contamination', p));
      fx.contamination.forEach(p => {
        p.vy += gs*dt*0.3; // Slight gravity
        p.vx *= 0.95; p.vy *= 0.95; // Damping
        p.x += p.vx*dt; p.y += p.vy*dt;
        p.alpha = Math.max(0.1, p.alpha - dt*0.5); // Fade out
      });
    }
    
    // downwash - optimized
    const deadDownwash = [];
    fx.downwash = fx.downwash.filter(p => {
      p.life -= dt*1000;
      if (p.life <= 0) {
        deadDownwash.push(p);
        return false;
      }
      return true;
    });
    deadDownwash.forEach(p => returnParticle('downwash', p));
    fx.downwash.forEach(p => {
      p.vy += 260*CFG.SCALE*dt*0.4;
      p.vx *= 0.96; p.vy *= 0.96;
      p.x += p.vx*dt; p.y += p.vy*dt;
    });
    
    // missile flame - optimized
    const deadFlame = [];
    fx.flame = fx.flame.filter(p => {
      p.life -= dt*1000;
      if (p.life <= 0) {
        deadFlame.push(p);
        return false;
      }
      return true;
    });
    deadFlame.forEach(p => returnParticle('flame', p));
    fx.flame.forEach(p => { p.x += p.vx*dt; p.y += p.vy*dt; p.vx *= 0.96; p.vy *= 0.98; });
    
    // oil particles - optimized
    const ground = H - world.floor;
    const deadOil = [];
    fx.oil = fx.oil.filter(p => {
      p.life -= dt*1000;
      if (p.life <= 0) {
        deadOil.push(p);
        return false;
      }
      return true;
    });
    deadOil.forEach(p => returnParticle('oil', p));
    fx.oil.forEach(p => {
      if (!p.landed){
        p.vy += 900*CFG.SCALE*dt;
        p.x += p.vx*dt; p.y += p.vy*dt;
        if (p.y >= ground){ p.y = ground; p.vy = 0; p.vx *= 0.5; p.landed = true; p.life += 800; }
      } else {
        p.vx *= 0.9; p.x += p.vx*dt; // small spread
      }
    });
    
    // Update ice chunks from glacier explosion
    if (glacierExplosion.active) {
      glacierExplosion.iceChunks = glacierExplosion.iceChunks.filter(chunk => {
        chunk.life -= dt * 1000;
        if (chunk.life <= 0) return false;
        
        // Physics
        chunk.vy += 1400 * dt * 0.8; // Gravity for ice chunks
        chunk.x += chunk.vx * dt;
        chunk.y += chunk.vy * dt;
        chunk.rotation += chunk.rotSpeed * dt;
        
        // Bounce off ground
        if (chunk.y >= ground) {
          chunk.y = ground;
          chunk.vy *= -0.3; // Bounce with damping
          chunk.vx *= 0.8; // Friction
        }
        
        return true;
      });
    }
  }
  function drawFx(){
    // draw blood as pixel squares
    ctx.save();
    fx.blood.forEach(p => {
      const a = Math.max(0, Math.min(1, p.life/400));
      ctx.globalAlpha = a;
      ctx.fillStyle = '#b31217';
      ctx.fillRect(p.x, p.y, p.size, p.size);
    });
    // sparks
    fx.sparks.forEach(p => {
      const a = Math.max(0, Math.min(1, p.life/300));
      ctx.globalAlpha = a;
      ctx.fillStyle = a>0.5 ? '#ffd54f' : '#ff9800';
      ctx.fillRect(p.x, p.y, p.size, p.size);
    });
    // contamination particles
    if (fx.contamination) {
      fx.contamination.forEach(p => {
        ctx.globalAlpha = p.alpha;
        ctx.fillStyle = '#00FF00'; // Bright green
        ctx.fillRect(p.x, p.y, p.size, p.size);
        // Add a slight glow effect
        ctx.globalAlpha = p.alpha * 0.3;
        ctx.fillStyle = '#90EE90';
        ctx.fillRect(p.x-1, p.y-1, p.size+2, p.size+2);
      });
    }
    // downwash
    fx.downwash.forEach(p => {
      const a = Math.max(0, Math.min(1, p.life/400));
      ctx.globalAlpha = a;
      ctx.fillStyle = p.color;
      ctx.fillRect(p.x, p.y, p.size, p.size);
    });
    // oil
    fx.oil.forEach(p => {
      const a = Math.max(0.1, Math.min(1, p.life/900));
      ctx.globalAlpha = a;
      ctx.fillStyle = '#111';
      ctx.fillRect(p.x, p.y, p.size, p.size);
    });
    // flame
    fx.flame.forEach(p => {
      const a = Math.max(0, Math.min(1, p.life/300));
      ctx.globalAlpha = a;
      ctx.fillStyle = p.color;
      ctx.fillRect(p.x, p.y, p.size, p.size);
    });
    
    // Draw glacier explosion effects
    if (glacierExplosion.active) {
      // Draw explosion effects
      glacierExplosion.explosions.forEach(exp => {
        const elapsed = nowMs() - exp.time;
        if (elapsed < exp.duration) {
          const progress = elapsed / exp.duration;
          const size = progress * 100 * CFG.SCALE;
          const alpha = 1 - progress;
          
          // Try custom explosion sprite
          if (!GRAPHICS.drawOrFallback(ctx, 'explosion', () => {}, exp.x, exp.y)) {
            ctx.globalAlpha = alpha;
            ctx.fillStyle = `rgba(255, 165, 0, ${alpha})`;
            ctx.beginPath();
            ctx.arc(exp.x, exp.y, size, 0, Math.PI * 2);
            ctx.fill();
          }
          
          // Inner white flash
          ctx.fillStyle = `rgba(255, 255, 255, ${alpha * 0.7})`;
          ctx.beginPath();
          ctx.arc(exp.x, exp.y, size * 0.5, 0, Math.PI * 2);
          ctx.fill();
        }
      });
      
      // Draw ice chunks
      glacierExplosion.iceChunks.forEach(chunk => {
        const alpha = Math.max(0, chunk.life / 3000);
        ctx.globalAlpha = alpha;
        ctx.fillStyle = '#e8f4f8';
        
        ctx.save();
        ctx.translate(chunk.x, chunk.y);
        ctx.rotate(chunk.rotation);
        ctx.fillRect(-chunk.size/2, -chunk.size/2, chunk.size, chunk.size);
        ctx.restore();
      });
      
      ctx.globalAlpha = 1;
    }
    
    ctx.restore();
  }

  // ---------- Missile overlay ----------
  function drawMissileFallback(x,y){
    ctx.save();
    const s = 4*CFG.SCALE; // 4x bigger
    // body
    ctx.fillStyle='#bbb'; ctx.fillRect(x-10*s, y-40*s, 20*s, 40*s);
    // cone
    ctx.beginPath(); ctx.moveTo(x, y-56*s); ctx.lineTo(x-10*s, y-40*s); ctx.lineTo(x+10*s, y-40*s); ctx.closePath(); ctx.fillStyle='#999'; ctx.fill();
    // fins
    ctx.fillStyle='#777'; ctx.fillRect(x-16*s, y-18*s, 6*s, 12*s);
    ctx.fillRect(x+10*s, y-18*s, 6*s, 12*s);
    // nuclear symbol
    ctx.fillStyle='#111'; ctx.beginPath(); ctx.arc(x, y-26*s, 6*s, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle='#ffd54f';
    ctx.beginPath(); ctx.moveTo(x, y-26*s); ctx.arc(x, y-26*s, 5*s, -Math.PI/6, Math.PI/6); ctx.lineTo(x, y-26*s); ctx.fill();
    ctx.beginPath(); ctx.moveTo(x, y-26*s); ctx.arc(x, y-26*s, 5*s, Math.PI/2 - Math.PI/6, Math.PI/2 + Math.PI/6); ctx.lineTo(x, y-26*s); ctx.fill();
    ctx.beginPath(); ctx.moveTo(x, y-26*s); ctx.arc(x, y-26*s, 5*s, Math.PI - Math.PI/6, Math.PI + Math.PI/6); ctx.lineTo(x, y-26*s); ctx.fill();
    // flame
    ctx.fillStyle='#ff9800'; ctx.fillRect(x-6*s, y, 12*s, 12*s);
    ctx.fillStyle='#ffd54f'; ctx.fillRect(x-3*s, y+2*s, 6*s, 6*s);
    ctx.restore();
  }

  function drawMissile(x,y){
    if (GRAPHICS.drawOrFallback(ctx, 'missile', drawMissileFallback, x, y)) return;
    drawMissileFallback(x,y);
  }

  // ---------- Hint tegning ----------
  
  // pulsating hover outline (disabled by default via CFG.SHOW_PULSE)
  function drawPulseFor(o){
    const t = nowMs()/1000;
    const w = Math.max(18, o.w||22) * CFG.SCALE;
    const h = (o.h? Math.max(10, o.h/2): 12) * CFG.SCALE;
    ctx.save();
    ctx.beginPath();
    ctx.ellipse(o.x, o.y-6, w*0.9 + Math.sin(t*3)*2, h*0.5 + Math.sin(t*3)*1, 0, 0, Math.PI*2);
    ctx.strokeStyle = 'rgba(255,255,255,0.7)';
    ctx.lineWidth = 1.5 + (Math.sin(t*3)*0.6);
    ctx.stroke();
    ctx.restore();
  }
  // Shape-following interact glow outlines
  function drawGlowOutline(obj){
    const maxR = CFG.INTERACT_DIST*2.2*CFG.SCALE;
    const d = Math.hypot(player.x-obj.x, player.y-obj.y);
    if (d>maxR) return;
    const a = Math.max(0, 1 - d/maxR);
    const color = (obj.type==='bear') ? 'rgba(120,170,255,'+(0.6*a).toFixed(3)+')' : 'rgba(255,255,255,'+(0.55*a).toFixed(3)+')';
    ctx.save(); ctx.strokeStyle = color; ctx.lineWidth = 2; ctx.beginPath();
    if (obj.type==='bear'){
      const w=60*CFG.SCALE, h=20*CFG.SCALE; const x=obj.x, y=obj.y-12*CFG.SCALE;
      roundedRectPath(x-w/2, y-h/2, w, h, 10*CFG.SCALE);
      ctx.moveTo(x+w*0.35, y-h*0.6); roundedRectPath(x+w*0.35, y-h*0.9, 22*CFG.SCALE, 14*CFG.SCALE, 4*CFG.SCALE);
    } else if (obj.type==='rig'){
      const x=obj.x, y=obj.y-60*CFG.SCALE; const base=32*CFG.SCALE;
      ctx.moveTo(x-base, y+70*CFG.SCALE); ctx.lineTo(x, y-8*CFG.SCALE); ctx.lineTo(x+base, y+70*CFG.SCALE); ctx.closePath();
      ctx.moveTo(x-36*CFG.SCALE, y+70*CFG.SCALE); ctx.lineTo(x+36*CFG.SCALE, y+70*CFG.SCALE);
    } else if (obj.type==='mine'){
      ctx.ellipse(obj.x, obj.y, 20*CFG.SCALE, 8*CFG.SCALE, 0, 0, Math.PI*2);
    } else if (obj.type==='heli'){
      const x=obj.x, y=obj.y; ctx.rect(x-40*CFG.SCALE, y-10*CFG.SCALE, 100*CFG.SCALE, 28*CFG.SCALE);
    } else if (obj.type==='mette' || obj.type==='putin' || obj.type==='aide'){
      roundedRectPath(obj.x-12*CFG.SCALE, obj.y-44*CFG.SCALE, 24*CFG.SCALE, 44*CFG.SCALE, 6*CFG.SCALE);
    } else if (obj.type==='door'){
      roundedRectPath(obj.x-14*CFG.SCALE, obj.y-80*CFG.SCALE, 28*CFG.SCALE, 80*CFG.SCALE, 4*CFG.SCALE);
    } else if (obj.type==='glacier'){
      const w = obj.w*CFG.SCALE, h = obj.h*CFG.SCALE;
      ctx.beginPath();
      ctx.moveTo(obj.x-w/2, obj.y+h/2);
      ctx.lineTo(obj.x-w/3, obj.y-h/2);
      ctx.lineTo(obj.x, obj.y-h/2-20*CFG.SCALE);
      ctx.lineTo(obj.x+w/3, obj.y-h/2);
      ctx.lineTo(obj.x+w/2, obj.y+h/2);
      ctx.closePath();
    } else if (obj.type==='phone'){
      roundedRectPath(obj.x-8*CFG.SCALE, obj.y-34*CFG.SCALE, 16*CFG.SCALE, 28*CFG.SCALE, 3*CFG.SCALE);
    } else if (obj.type==='statue'){
      roundedRectPath(obj.x-10*CFG.SCALE, obj.y-30*CFG.SCALE, 20*CFG.SCALE, 30*CFG.SCALE, 4*CFG.SCALE);
    } else {
      ctx.restore(); return;
    }
    ctx.stroke(); ctx.restore();
  }
  function roundedRectPath(x,y,w,h,r){
    ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r);
  }
  // (outline hint removed for now per request)

  // ---------- Error Handling Utilities ----------
  function safeExecute(fn, errorMsg, fallback = null) {
    try {
      return fn();
    } catch(err) {
      if (CFG.DEBUG) {
        console.error(`${errorMsg}:`, err);
      }
      return fallback;
    }
  }
  
  function safeDraw(fn, context = 'render') {
    try {
      fn();
    } catch(err) {
      if (CFG.DEBUG) {
        console.error(`Drawing error in ${context}:`, err);
      }
      // Drawing errors shouldn't crash the game
    }
  }

  // ---------- Loop ----------
  function step(t){
    try {
      const renderStart = performance.now();
      
      // Performance monitoring
      PERF.frameCount++;
      if (t - PERF.lastFpsUpdate > 1000) { // Update FPS every second
        PERF.fps = Math.round(PERF.frameCount * 1000 / (t - PERF.lastFpsUpdate));
        PERF.frameCount = 0;
        PERF.lastFpsUpdate = t;
      }
      
      deltaTime = Math.min(MAX_DELTA, t - last);
      const dt = Math.min(0.033, deltaTime/1000); 
      last = t;
    
    // Handle intro screen animation
    if (scene === 'intro') {
      const introCanvas = document.getElementById('intro-canvas');
      if (introCanvas && (t - introStartTime) > (GAME_CONSTANTS.ANIMATION && GAME_CONSTANTS.ANIMATION.INTRO_UPDATE_MS || 100)) { // Update frequency
        const ictx = introCanvas.getContext('2d');
        ictx.imageSmoothingEnabled = false; // Ensure pixel art style
        drawIntroGraphics(ictx, introCanvas.width, introCanvas.height);
        introStartTime = t;
      }
      requestAnimationFrame(step);
      return;
    }
    // game timer
    if (!GS.over && !choiceOverlay && !infoCard && !flagOverlay && !tug) {
      GS.timeLeftMs -= dt*1000;
      if (GS.timeLeftMs<=0){
        checkWin(); // Use the new multiple endings system
      }
    }


    // bev√¶gelse (ingen i choice-overlay). Stopper ved auto-walk tween
    if (!choiceOverlay && !infoCard && !flagOverlay && !walkTween && !introRunning && !tug) {
      let dx=0, dy=0;
      if (keys.has('arrowleft')) dx-=1;
      if (keys.has('arrowright')) dx+=1;
      if (keys.has('arrowup')) dy-=1;
      if (keys.has('arrowdown')) dy+=1;
      const len=Math.hypot(dx,dy)||1;
      const spd = CFG.SPEED * (player.speedMul||1);
      const oldX = player.x;
      player.x += (dx/len)*spd*dt*CFG.SCALE;
      player.y += (dy/len)*spd*dt*CFG.SCALE;
      if (dx) player.facing=Math.sign(dx);
      
      // Walking animation logic
      const isMoving = Math.abs(player.x - oldX) > 0.1 || Math.abs(dx) > 0 || Math.abs(dy) > 0;
      if (isMoving) {
        player.walking = true;
        player.walkCycle += dt * 8; // Walking speed (higher = faster steps)
      } else {
        player.walking = false;
        player.walkCycle = 0; // Reset to neutral pose when stopped
      }
      // bounds
      const g = H-world.floor; const minX=40*CFG.SCALE,maxX=W-40*CFG.SCALE;
      player.x=clamp(player.x,minX,maxX); player.y=g;
    }

    // opdater auto-walk tween
    stepWalkTween(t);

    // speed boost timeout + HUD refresh
    if (speedBoostUntil && nowMs() > speedBoostUntil){ speedBoostUntil=0; player.speedMul=1; }
    renderHUD();

    // opdater hop (jump) tween
    const ground = H - world.floor;
    if (jumpTween){
      const k = Math.min(1, (t - jumpTween.start)/jumpTween.dur);
      const lift = Math.sin(k*Math.PI) * jumpTween.height;
      player.y = ground - lift;
      if (k>=1){ jumpTween=null; if (!entryHeli.active) player.y = ground; }
    } else {
      if (!entryHeli.active) player.y = ground;
    }

    // update actors + fx
    updateActors(dt);
    updateFx(dt);
    
    // Update particle count for monitoring
    PERF.particleCount = fx.blood.length + fx.sparks.length + fx.downwash.length + fx.oil.length + fx.flame.length;

    // ensure player is inside helicopter during entry before drawing
    if (entryHeli.active){
      const ktmp = Math.min(1, (nowMs() - entryHeli.start)/entryHeli.dur);
      if (entryHeli.vertical){
        entryHeli.y = entryHeli.startY + (entryHeli.targetY - entryHeli.startY) * ktmp;
      } else {
        entryHeli.x = -180*CFG.SCALE + (entryHeli.targetX - (-180*CFG.SCALE)) * ktmp;
      }
      player.x = entryHeli.x + 30*CFG.SCALE;
      // keep Trump inside vertically as well (sit in cabin)
      player.y = entryHeli.y + 18*CFG.SCALE;
    }

    // optional camera shake near heli touchdown
    let shakeApplied=false; ctx.save();
    if (entryHeli.active){ const kshake = Math.min(1, (nowMs()-entryHeli.start)/entryHeli.dur); if (kshake>0.8){ const p=(kshake-0.8)/0.2; const amp = 2*CFG.SCALE*p; ctx.translate((Math.random()-0.5)*amp, (Math.random()-0.5)*amp); shakeApplied=true; } }

    // tegning
    if (scene==='greenland'){
      // Background: try custom image first, else fallback gradient + clouds
      const bgDrawn = GRAPHICS.drawBackground(ctx, 'greenland_bg');
      if (!bgDrawn){
        ctx.fillStyle=skyGrad; ctx.fillRect(0,0,W,H);
        CLOUDS.forEach(c=>{ ctx.globalAlpha=c.a; ctx.fillStyle='#ffffff'; ctx.beginPath(); ctx.ellipse(c.x, c.y, c.w/2, c.h/2, 0,0,Math.PI*2); ctx.fill(); ctx.globalAlpha=1; });
        ctx.fillStyle='#ebf8ff';
      }
      
      // Interactive glaciers
      GL.glaciers.forEach(glacier => {
        if (!glacier.blown) {
          drawGlacier(glacier.x, glacier.y, glacier.w, glacier.h, glacier.blown);
        }
      });
      const ground=H-world.floor; ctx.fillStyle='#e7fbff'; ctx.fillRect(0,ground,W,world.floor);
      ctx.fillStyle='#cfeef9'; for(let i=0;i<6;i++){ const y=ground+20+i*18*CFG.SCALE; ctx.fillRect(0,y,W,4); }

      // objekter
      drawMine(GL.mine.x, GL.mine.y);
      drawRig(GL.rig.x, GL.rig.y);
      if (GL.flag) drawFlag(GL.flag.x, GL.flag.y);
      drawBear(GL.bear.x, GL.bear.y, GL.bear.alive);
      drawBearHP(GL.bear);
      drawMette(GL.mette.x, GL.mette.y);
      // during entry, draw only Trump here (heli is drawn in overlay)
      if (entryHeli.active){
        drawTrump(player.x, player.y, player.facing);
      } else {
        drawHeli(GL.heli.x, GL.heli.y, 0.35);
        drawTrump(player.x, player.y, player.facing);
      }
      GL.items.forEach(it=>{ if(!it.collected) drawPickup(it); });
      // Draw coins
      GL.coins.forEach(coin => { if(!coin.collected) drawGoldBar(coin); });
      // blood/sparks/downwash fx
      drawFx();
      
      // Rising water level overlay (drawn on top of everything)
      if (glacierExplosion.active && glacierExplosion.waterLevel > 0) {
        ctx.save();
        ctx.globalAlpha = 0.7;
        ctx.fillStyle = '#4a90e2'; // Ocean blue
        ctx.fillRect(0, H - glacierExplosion.waterLevel, W, glacierExplosion.waterLevel);
        
        // Water surface waves
        ctx.globalAlpha = 0.3;
        ctx.fillStyle = '#ffffff';
        const waveY = H - glacierExplosion.waterLevel;
        for (let x = 0; x < W; x += 40) {
          const waveHeight = Math.sin((nowMs() * 0.005) + (x * 0.02)) * 3;
          ctx.fillRect(x, waveY + waveHeight - 2, 30, 4);
        }
        ctx.restore();
      }

      // bobler
      const n=nowMs();
      const placed=[];
      if (player.speakingUntil>n){
        let yOff = placeBubble(player.say, player.x, player.y, player.facing<0, placed);
        if (player.say){
          const low = player.say.toLowerCase();
          if (low.includes('kick')) yOff -= 10*CFG.SCALE;
          if (low.startsWith('tweet:')) yOff -= 34*CFG.SCALE; // lift to match Mette spacing
        }
        textBubble(player.say, player.x, player.y, player.facing<0, 'trump', yOff);
      }
      if (GL.mette.speakingUntil>n){
        const yOff = placeBubble(GL.mette.say, GL.mette.x, GL.mette.y, true, placed);
        textBubble(GL.mette.say, GL.mette.x, GL.mette.y, true, 'mette', yOff);
      }
      if (GL.bear.speakingUntil>n){
        const yOff = placeBubble(GL.bear.say, GL.bear.x, GL.bear.y, true, placed);
        textBubble(GL.bear.say, GL.bear.x, GL.bear.y, true, 'bear', yOff);
      }

      // interaktionshint
      const near=nearestGL();
      // hover pulse: prefer cursor target if active
      if (CFG.SHOW_PULSE && mouse.active){
        const objs=[GL.mine, GL.bear, GL.mette, GL.rig, GL.heli, ...GL.items.filter(it=>!it.collected)];
        const {obj, dist} = nearestToPoint(objs, mouse.x, mouse.y);
        if (obj && dist < 110*CFG.SCALE) drawPulseFor(obj);
      } else if (CFG.SHOW_PULSE && near){ drawPulseFor(near); }
      // airborne pickup collection: collide with player's head while jumping
      const gnd = H - world.floor;
      if (player.y < gnd - 4*CFG.SCALE){
        const headX = player.x, headY = player.y - 38*CFG.SCALE;
        GL.items.forEach(it=>{
          if (it.collected) return;
          const cx = it.x, cy = it.y - 18*CFG.SCALE;
          const d = Math.hypot(headX - cx, headY - cy);
          if (d < 26*CFG.SCALE){ it.collected=true; addToInventory(it.id, it.name); spawnSparks(cx, cy, 10); }
        });
      }
    }
    
    // Global gold bar collection logic for all scenes (when jumping)
    const gnd = H - world.floor;
    if (player.y < gnd - 4*CFG.SCALE){
      const headX = player.x, headY = player.y - 38*CFG.SCALE;
      const currentCoins = scene==='greenland' ? GL.coins : scene==='oval' ? OV.coins : KR.coins;
      currentCoins.forEach(coin=>{
        if (coin.collected) return;
        const cx = coin.x, cy = coin.y - 20*CFG.SCALE;
        const d = Math.hypot(headX - cx, headY - cy);
        if (d < 20*CFG.SCALE){ 
          coin.collected=true; 
          collectedCoins++; 
          spawnSparks(cx, cy, 15);
          checkCoinRewards();
          renderHUD(); // Update HUD to show new coin count
        }
      });
    }
    
    if (scene==='oval') {
      drawOvalBackdrop();
      drawDoor(OV.door.x, OV.door.y);
      // aide removed from behind the desk for this layout
      drawYesGroup(OV.yes.x, OV.yes.y);
      // draw Trump first so desk can overlay (he stands behind desk)
      if (entryHeli.active){ drawTrump(player.x, player.y, player.facing); }
      else { drawHeli(OV.heli.x, OV.heli.y, 0.35); drawTrump(player.x, player.y, player.facing); }
      // then desk on top, with buttons
      drawOvalDesk();
      // Draw coins
      OV.coins.forEach(coin => { if(!coin.collected) drawGoldBar(coin); });
      drawFx();

      const n=nowMs();
      const placed=[];
      if (player.speakingUntil>n){
        let yOff = placeBubble(player.say, player.x, player.y, player.facing<0, placed);
        if (player.say){
          const low = player.say.toLowerCase();
          if (low.includes('kick')) yOff -= 10*CFG.SCALE;
          if (low.startsWith('tweet:')) yOff -= 34*CFG.SCALE;
        }
        textBubble(player.say, player.x, player.y, player.facing<0, 'trump', yOff);
      }
      if (OV.aide.speakingUntil>n){
        const yOff = placeBubble(OV.aide.say, OV.aide.x, OV.aide.y, true, placed);
        textBubble(OV.aide.say, OV.aide.x, OV.aide.y, true, 'aide', yOff);
      }
      if (OV.yes.speakingUntil>n){
        const centerX = OV.yes.x; const baseY = OV.yes.y - 46*CFG.SCALE;
        const yOff = placeBubble(OV.yes.say, centerX, baseY, false, placed) - 8*CFG.SCALE;
        textBubble(OV.yes.say, centerX, baseY, false, 'default', yOff);
      }

      const near=nearestOV();
      if (CFG.SHOW_PULSE && mouse.active){
        const objs=[OV.door, OV.phone, OV.aide];
        const {obj, dist} = nearestToPoint(objs, mouse.x, mouse.y);
        if (obj && dist < 110*CFG.SCALE) drawPulseFor(obj);
      } else if (CFG.SHOW_PULSE && near){ drawPulseFor(near); }
    } else if (scene==='kremlin') {
      drawKremlinBackdrop();
      drawDoor(KR.door.x, KR.door.y);
      drawSecurityCamera(); // Draw camera body first (but not laser - comes later)
      
      // Depth sorting: collect all drawable objects with y-positions
      const drawables = [];
      
      // Add Putin
      drawables.push({y: KR.putin.y, draw: () => drawPutin(KR.putin.x, KR.putin.y)});
      
      // Add Trump with artificially low y-value to force him behind everything
      if (entryHeli.active) {
        drawables.push({y: 0, draw: () => drawTrump(player.x, player.y, player.facing)});
      } else {
        drawables.push({y: KR.heli.y, draw: () => drawHeli(KR.heli.x, KR.heli.y, 0.35)});
        drawables.push({y: 0, draw: () => drawTrump(player.x, player.y, player.facing)});
      }
      
      // Add statues
      KR.statues.forEach(s => {
        if (!s.collected) {
          drawables.push({y: s.y, draw: () => drawGoldStatue(s.x, s.y, s.variant)});
        }
      });
      
      // Add desk top edge (high y-value to render in front)
      const deskY = H - world.floor + 24*CFG.SCALE;
      const deskX = 300*CFG.SCALE, deskW = (W - 2*300*CFG.SCALE);
      drawables.push({y: deskY, draw: () => {
        ctx.fillStyle='#222'; 
        ctx.fillRect(deskX-6, deskY-34*CFG.SCALE, deskW+12, 6*CFG.SCALE);
      }});
      
      // Sort by y-position (top to bottom) and draw
      drawables.sort((a, b) => a.y - b.y);
      drawables.forEach(drawable => drawable.draw());
      
      // Draw laser cone AFTER everything else so it's always on top
      const cam = KR.camera;
      const lensX = cam.x;
      const lensY = cam.y - 18*CFG.SCALE;
      drawLaserCone(lensX, lensY, cam.angle);
      
      // Draw coins
      KR.coins.forEach(coin => { if(!coin.collected) drawGoldBar(coin); });
      
      drawFx();

      const n=nowMs();
      const placed=[];
      if (player.speakingUntil>n){
        let yOff = placeBubble(player.say, player.x, player.y, player.facing<0, placed);
        if (player.say){
          const low = player.say.toLowerCase();
          if (low.includes('kick')) yOff -= 10*CFG.SCALE;
          if (low.startsWith('tweet:')) yOff -= 34*CFG.SCALE;
        }
        textBubble(player.say, player.x, player.y, player.facing<0, 'trump', yOff);
      }
      if (KR.putin.speakingUntil>n){
        const yOff = placeBubble(KR.putin.say, KR.putin.x, KR.putin.y, true, placed);
        textBubble(KR.putin.say, KR.putin.x, KR.putin.y, true, 'default', yOff);
      }

      const near=nearestKR();
      if (CFG.SHOW_PULSE && mouse.active){
        const objs=[KR.door, KR.putin];
        const {obj, dist} = nearestToPoint(objs, mouse.x, mouse.y);
        if (obj && dist < 110*CFG.SCALE) drawPulseFor(obj);
      } else if (CFG.SHOW_PULSE && near){ drawPulseFor(near); }

      // Security camera flash effect
      if (KR.camera.flashUntil && nowMs() < KR.camera.flashUntil) {
        ctx.save();
        ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
        ctx.fillRect(0, 0, W, H);
        ctx.restore();
      }
    } else if (scene==='epstein') {
      drawEpsteinScene();
    }

    // restore after scene draw
    if (shakeApplied) { /* keep overlay unaffected */ } ctx.restore();

    // entry helicopter overlay
    if (entryHeli.active){
      const k = Math.min(1, (nowMs() - entryHeli.start)/entryHeli.dur);
      if (entryHeli.vertical){
        entryHeli.y = entryHeli.startY + (entryHeli.targetY - entryHeli.startY) * k;
      } else {
        entryHeli.x = -180*CFG.SCALE + (entryHeli.targetX - (-180*CFG.SCALE)) * k;
      }
      // keep player "inside" helicopter as it arrives
      player.x = entryHeli.x + 30*CFG.SCALE;
      player.y = entryHeli.y + 18*CFG.SCALE;
      drawHeli(entryHeli.x, entryHeli.y, 1.0);
      // rotor downwash while arriving
      if (k>0.6) spawnDownwash(entryHeli.x, entryHeli.y + 12*CFG.SCALE, scene);
      if (k>=1){
        entryHeli.active = false;
        introPlayed = true;
        startWalkTo(player.x + 40*CFG.SCALE, 500, ()=>{ if (entryHeli.line) say(player, entryHeli.line, 1600); });
      }
    }

    // missile overlay (in front of everything)
    if (NUKE.active){
      const k = Math.min(1, (nowMs() - NUKE.start)/NUKE.dur);
      NUKE.y = NUKE.startY + (NUKE.endY - NUKE.startY)*k;
      drawMissile(NUKE.x, NUKE.y);
      if (k>=1){ NUKE.active=false; GS.doom = 100; checkWin(); }
    }

    // tug-of-war overlay
    if (tug){
      const elapsed = nowMs() - tug.start; const k = Math.min(1, elapsed/tug.dur);
      // opponent pull
      tug.pos -= 0.22 * (1/60); // approx per frame pull; mild
      tug.pos = Math.max(-1, Math.min(1, tug.pos));
      // UI
      ctx.fillStyle='rgba(0,0,0,.55)'; ctx.fillRect(W/2-180, H/2-50, 360, 100);
      ctx.fillStyle='#fff'; ctx.font = `bold ${16*CFG.SCALE}px system-ui`; ctx.textAlign='center';
      ctx.fillText('Tug of War! Mash A + D', W/2, H/2-12);
      // center bar from -1..1, green to the right, red left
      const barW = 240, barH=12, cx=W/2, cy=H/2+10;
      ctx.strokeStyle='#fff'; ctx.strokeRect(cx-barW/2, cy, barW, barH);
      const px = (tug.pos+1)/2; // 0..1
      ctx.fillStyle = '#4caf50';
      ctx.fillRect(cx, cy, (barW/2)*Math.max(0, tug.pos), barH);
      ctx.fillStyle = '#e53935';
      ctx.fillRect(cx - (barW/2)*Math.max(0, -tug.pos), cy, (barW/2)*Math.max(0, -tug.pos), barH);
      ctx.textAlign='left';
      if (elapsed >= tug.dur){
        const win = tug.pos > 0.5;
        
        // Dynamic Putin dialogue based on relationships
        const putinRel = RELATIONSHIPS.putin;
        let putinResponse, trumpResponse;
        
        if (win) {
          // Trump wins handshake
          if (putinRel.respect >= 70) {
            putinResponse = 'Impressive strength, my friend.';
            trumpResponse = 'Mutual respect achieved!';
          } else if (putinRel.respect >= 40) {
            putinResponse = 'Strong. I respect that.';
            trumpResponse = 'Dominated the handshake!';
          } else {
            putinResponse = 'Strong.';
            trumpResponse = 'Power move successful!';
          }
          adjustRelationship('putin', {respect: 8, fear: -3}, 'handshake_win');
          addSafe('kremlin', 'putin-handshake-win');
        } else {
          // Putin wins handshake
          if (putinRel.trust <= 20) {
            putinResponse = 'Weakness. Disappointing.';
            trumpResponse = 'Strategic retreat...';
          } else if (putinRel.fear >= 60) {
            putinResponse = 'You seem... nervous, Donald.';
            trumpResponse = 'Recalibrating approach...';
          } else {
            putinResponse = 'Too soft.';
            trumpResponse = 'Next time‚Ä¶';
          }
          adjustRelationship('putin', {respect: -5, trust: -3, fear: 2}, 'handshake_loss');
        }
        
        KR.putin.speakingUntil = nowMs()+1600; 
        KR.putin.say = putinResponse;
        say(player, trumpResponse, 1000);
        tug = null;
        // plant flag based on who won
        if (win) plantFlag('american'); else plantFlag('russian');
      }
    }

    // border draw overlay
    if (borderDraw){
      const card = getBorderCardRect();
      // dim
      ctx.fillStyle='rgba(0,0,0,.6)'; ctx.fillRect(0,0,W,H);
      // card background (image if available)
      if (MAP_IMG_READY){
        ctx.drawImage(MAP_IMG, card.x, card.y, card.w, card.h);
      } else {
        ctx.fillStyle='#f7f5ee'; ctx.fillRect(card.x, card.y, card.w, card.h);
      }
      ctx.strokeStyle='#c9a641'; ctx.lineWidth=4; ctx.strokeRect(card.x-6, card.y-6, card.w+12, card.h+12);
      // Enhanced world map with recognizable regions
      if (!MAP_IMG_READY){
        ctx.save(); ctx.translate(card.x, card.y);
        drawEnhancedWorldMap(ctx, card.w, card.h);
        ctx.restore();
      }

      // auto-generate border if putin mode and not generated
      if (borderDraw.mode==='putin' && !borderDraw.gen){
        const pts=[]; const steps=12; for (let i=0;i<=steps;i++){ const t=i/steps; const x=card.x + card.w*(0.35+0.45*t); const y=card.y + card.h*(0.40+0.05*Math.sin(t*Math.PI)); pts.push({x,y}); }
        borderDraw.points = pts; borderDraw.gen = true;
      }
      // draw user path with enhanced visual feedback
      if (borderDraw.points.length){
        // Main border line
        const borderColor = borderDraw.mode === 'trump' ? '#ff6b35' : '#d63031';
        ctx.strokeStyle = borderColor; 
        ctx.lineWidth = 5; 
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        ctx.beginPath(); 
        ctx.moveTo(borderDraw.points[0].x, borderDraw.points[0].y); 
        for (let i=1;i<borderDraw.points.length;i++){ 
          ctx.lineTo(borderDraw.points[i].x, borderDraw.points[i].y); 
        } 
        ctx.stroke();
        
        // Add glow effect
        ctx.strokeStyle = borderColor; 
        ctx.lineWidth = 8; 
        ctx.globalAlpha = 0.3;
        ctx.stroke();
        ctx.globalAlpha = 1;
        
        // Mark start and end points
        if (borderDraw.points.length > 0) {
          const start = borderDraw.points[0];
          const end = borderDraw.points[borderDraw.points.length - 1];
          
          // Start marker (green)
          ctx.fillStyle = '#00b894';
          ctx.beginPath();
          ctx.arc(start.x, start.y, 6, 0, Math.PI * 2);
          ctx.fill();
          
          // End marker (red)
          if (borderDraw.points.length > 1) {
            ctx.fillStyle = '#e84393';
            ctx.beginPath();
            ctx.arc(end.x, end.y, 6, 0, Math.PI * 2);
            ctx.fill();
          }
          
          // Preview line to current mouse position (if drawing mode)
          if (borderDraw.mode === 'trump' && mouse.active && !isDrawing && drawingSettings.showPreview) {
            const card = getBorderCardRect();
            if (mouse.x>=card.x && mouse.x<=card.x+card.w && mouse.y>=card.y && mouse.y<=card.y+card.h) {
              ctx.strokeStyle = '#ff6b35';
              ctx.lineWidth = 2;
              ctx.globalAlpha = 0.5;
              ctx.setLineDash([8, 8]);
              ctx.beginPath();
              ctx.moveTo(end.x, end.y);
              ctx.lineTo(mouse.x, mouse.y);
              ctx.stroke();
              ctx.setLineDash([]);
              ctx.globalAlpha = 1;
            }
          }
        }
        
        // Drawing cursor and tools
        if (borderDraw.mode === 'trump' && mouse.active) {
          const card = getBorderCardRect();
          if (mouse.x>=card.x && mouse.x<=card.x+card.w && mouse.y>=card.y && mouse.y<=card.y+card.h) {
            // Crosshair cursor
            ctx.strokeStyle = isDrawing ? '#ff3333' : '#ff6b35';
            ctx.lineWidth = 1;
            ctx.globalAlpha = 0.8;
            ctx.beginPath();
            ctx.moveTo(mouse.x - 10, mouse.y);
            ctx.lineTo(mouse.x + 10, mouse.y);
            ctx.moveTo(mouse.x, mouse.y - 10);
            ctx.lineTo(mouse.x, mouse.y + 10);
            ctx.stroke();
            
            // Center dot
            ctx.fillStyle = isDrawing ? '#ff3333' : '#ff6b35';
            ctx.beginPath();
            ctx.arc(mouse.x, mouse.y, 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1;
          }
        }
      }
      // Enhanced instructions and live analysis
      ctx.fillStyle='#333'; ctx.font=`bold ${14*CFG.SCALE}px system-ui`; ctx.textAlign='center';
      
      // Enhanced Instructions
      let msg;
      if (borderDraw.mode==='trump') {
        if (borderDraw.points.length === 0) {
          msg = 'üñäÔ∏è Click and drag to draw border ¬∑ Hold mouse button and draw smoothly';
        } else {
          msg = `üñäÔ∏è Drawing (${borderDraw.points.length} points) ¬∑ Enter: Confirm ¬∑ Backspace: Undo ¬∑ C: Clear ¬∑ U: Smooth ¬∑ Esc: Cancel`;
        }
      } else {
        msg = 'ü§ñ Putin\'s Proposed Border';
      }
      
      ctx.fillText(msg, W/2, card.y + card.h + 28);
      
      // Live border analysis and drawing stats
      if (borderDraw.mode === 'trump') {
        ctx.font = `${12*CFG.SCALE}px system-ui`;
        ctx.fillStyle='rgba(0,0,0,.8)';
        const statBoxHeight = borderDraw.points.length > 3 ? 80 : 40;
        ctx.fillRect(card.x + 10, card.y + 10, 200, statBoxHeight);
        ctx.fillStyle='#fff';
        ctx.textAlign='left';
        
        // Drawing progress
        ctx.fillText(`üñäÔ∏è Points: ${borderDraw.points.length}`, card.x + 20, card.y + 28);
        
        if (isDrawing) {
          ctx.fillStyle='#ff3333';
          ctx.fillText(`‚úèÔ∏è Drawing...`, card.x + 120, card.y + 28);
        }
        
        // Border analysis (if enough points)
        if (borderDraw.points.length > 3) {
          const analysis = analyzeBorderLive(borderDraw.points, card);
          ctx.fillStyle='#fff';
          ctx.fillText(`üìè Length: ${analysis.lengthDesc}`, card.x + 20, card.y + 45);
          ctx.fillText(`üéØ Strategy: ${analysis.strategyDesc}`, card.x + 20, card.y + 62);
          ctx.fillText(`‚ö° Aggression: ${analysis.aggressionDesc}`, card.x + 20, card.y + 79);
        }
      }
      ctx.textAlign='left';
      
      // Relationship display (top right corner)
      if (scene === 'greenland' || scene === 'kremlin') {
        ctx.font = `${11*CFG.SCALE}px system-ui`;
        ctx.fillStyle = 'rgba(0,0,0,.8)';
        ctx.fillRect(W - 200, 10, 190, 80);
        ctx.fillStyle = '#fff';
        ctx.textAlign = 'left';
        ctx.fillText('üë• RELATIONSHIPS', W - 195, 28);
        
        // Mette relationship
        if (scene === 'greenland') {
          const metteEmoji = getRelationshipEmoji('mette');
          const metteRel = RELATIONSHIPS.mette;
          ctx.fillText(`${metteEmoji} Mette: R${metteRel.respect} T${metteRel.trust} F${metteRel.fear}`, W - 195, 48);
          
          // Relationship bar
          const barWidth = 60;
          const avg = (metteRel.respect + metteRel.trust - metteRel.fear) / 3;
          ctx.fillStyle = avg >= 50 ? '#4CAF50' : avg >= 25 ? '#FF9800' : '#F44336';
          ctx.fillRect(W - 120, 40, (avg/100) * barWidth, 8);
          ctx.strokeStyle = '#333';
          ctx.strokeRect(W - 120, 40, barWidth, 8);
        }
        
        // Putin relationship  
        if (scene === 'kremlin') {
          const putinEmoji = getRelationshipEmoji('putin');
          const putinRel = RELATIONSHIPS.putin;
          ctx.fillStyle = '#fff';
          ctx.fillText(`${putinEmoji} Putin: R${putinRel.respect} T${putinRel.trust} F${putinRel.fear}`, W - 195, 68);
          
          // Relationship bar
          const barWidth = 60;
          const avg = (putinRel.respect + putinRel.trust - putinRel.fear) / 3;
          ctx.fillStyle = avg >= 50 ? '#4CAF50' : avg >= 25 ? '#FF9800' : '#F44336';
          ctx.fillRect(W - 120, 60, (avg/100) * barWidth, 8);
          ctx.strokeStyle = '#333';
          ctx.strokeRect(W - 120, 60, barWidth, 8);
        }
      }
    }

    // choice overlay
    if (choiceOverlay){
      ctx.fillStyle='rgba(0,0,0,.55)'; ctx.fillRect(0,0,W,H);
      const lines = choiceOverlay.text.split('\n');
      ctx.fillStyle='#fff'; ctx.font=`bold ${18*CFG.SCALE}px system-ui`; ctx.textAlign='center';
      lines.forEach((ln,i)=>ctx.fillText(ln, W/2, H/2 + (i-1)*24*CFG.SCALE));
      ctx.textAlign='left';
    }

    // info card overlay
    if (infoCard){
      drawInfoCard();
    }

    // flag overlay
    if (flagOverlay){
      drawFlagOverlay();
    }

    // HUD toast
    if (hudToast){ ctx.save(); ctx.globalAlpha=0.9; ctx.fillStyle='rgba(0,0,0,.6)'; ctx.fillRect(W-260, 44, 240, 26); ctx.fillStyle='#fff'; ctx.font=`12px system-ui`; ctx.fillText(hudToast, W-248, 62); ctx.restore(); hudToast=null; }

    // game over overlay
    if (GS.over){ 
      ctx.fillStyle='rgba(0,0,0,.8)'; 
      ctx.fillRect(0,0,W,H); 
      ctx.fillStyle='#fff'; 
      ctx.textAlign='center'; 
      
      // Main ending text
      ctx.font=`bold ${24*CFG.SCALE}px system-ui`; 
      const lines = GS.overText.split('\n');
      lines.forEach((line, i) => {
        ctx.fillText(line, W/2, H/2 - 60*CFG.SCALE + i*28*CFG.SCALE);
      });
      
      // Show achievements earned
      const earnedAchievements = Object.entries(GS.achievements).filter(([key, earned]) => earned);
      if (earnedAchievements.length > 0) {
        ctx.font=`bold ${16*CFG.SCALE}px system-ui`;
        ctx.fillText('üèÜ ACHIEVEMENTS UNLOCKED:', W/2, H/2 + 50*CFG.SCALE);
        
        ctx.font=`${12*CFG.SCALE}px system-ui`;
        const achievementNames = {
          perfectDiplomat: 'ü§ù Perfect Diplomat',
          speedRunner: '‚ö° Speed Runner', 
          collector: 'üóÉÔ∏è Master Collector',
          peacemaker: '‚òÆÔ∏è Peacemaker',
          twitterAddict: 'üì± Twitter Master',
          bearWhisperer: 'üêª Bear Whisperer'
        };
        
        earnedAchievements.forEach(([key], i) => {
          ctx.fillText(achievementNames[key], W/2, H/2 + 75*CFG.SCALE + i*18*CFG.SCALE);
        });
      }
      
      ctx.font=`${14*CFG.SCALE}px system-ui`; 
      const restartY = earnedAchievements.length > 0 ? H/2 + 140*CFG.SCALE : H/2 + 80*CFG.SCALE;
      ctx.fillText('Press Shift+R to restart', W/2, restartY); 
      ctx.textAlign='left'; 
    }
    
    // Debug and performance info
    if (CFG.SHOW_FPS || CFG.DEBUG) {
      ctx.save();
      ctx.fillStyle = 'rgba(0,0,0,0.7)';
      ctx.fillRect(10, 10, 150, CFG.DEBUG ? 80 : 40);
      ctx.fillStyle = '#fff';
      ctx.font = '12px monospace';
      ctx.fillText(`FPS: ${PERF.fps}`, 15, 28);
      if (CFG.DEBUG) {
        ctx.fillText(`Particles: ${PERF.particleCount}`, 15, 45);
        ctx.fillText(`Delta: ${deltaTime.toFixed(1)}ms`, 15, 62);
        ctx.fillText(`Render: ${PERF.renderTime.toFixed(1)}ms`, 15, 79);
      }
      ctx.restore();
    }
    
      // Record render time
      PERF.renderTime = performance.now() - renderStart;

      requestAnimationFrame(step);
    } catch(err) {
      console.error('Game loop error:', err);
      // Try to continue running after a short delay
      setTimeout(() => requestAnimationFrame(step), 100);
    }
  }
  
  // Start the game loop with error handling
  try {
    requestAnimationFrame(step);
  } catch(err) {
    console.error('Failed to start game loop:', err);
  }
})();

/*
GRAPHICS SYSTEM USAGE EXAMPLES:

// Show all recommended dimensions
showAllDimensions();

// Get specific dimensions
getGraphicDimensions('trump');  // Shows: trump: 24x44px - Trump character sprite

// Set individual graphics
setGraphic('trump', 'https://your-server.com/trump.png');
setGraphic('helicopter', 'https://your-server.com/heli.png');
setGraphic('greenland_bg', 'https://your-server.com/greenland.jpg');

// Set multiple graphics at once
setGraphics({
  trump: 'https://your-server.com/trump.png',
  mette: 'https://your-server.com/mette.png',
  putin: 'https://your-server.com/putin.png',
  helicopter: 'https://your-server.com/helicopter.png',
  greenland_bg: 'https://your-server.com/greenland-bg.jpg'
});

// List all available graphics to customize
listGraphics();

// Clear image cache (useful when updating graphics)
GRAPHICS.clearCache();

RECOMMENDED DIMENSIONS SUMMARY:
Characters: 24x44px (Trump, Mette, Putin, Aide)
Bear: 60x30px
Helicopter: 140x40px
Backgrounds: 1200x800px (will scale to screen)
Items: 16-20x12-30px (varies by item)
Objects: Various sizes (see showAllDimensions() for details)

NOTE: All dimensions are at scale 1.0. The game will automatically scale 
based on screen size (CFG.SCALE), so your images should be at the base size.
*/
</script>
</body>
</html>
